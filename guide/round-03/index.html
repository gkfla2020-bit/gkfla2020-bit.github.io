<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Round 3 - Data Engineering + Feature Engineering</title>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;500&family=Space+Mono:wght@400&family=Inter:wght@300;400&display=swap" rel="stylesheet">
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:'Inter',sans-serif;background:#fafaf8;color:#1a1a1a;line-height:1.7;overflow-x:hidden}
.sidebar{position:fixed;left:0;top:0;width:260px;height:100vh;background:rgba(255,255,255,.97);border-right:1px solid rgba(0,0,0,.06);padding:32px 24px;z-index:100;overflow-y:auto;display:flex;flex-direction:column}
.sidebar-profile{text-align:center;margin-bottom:28px;padding-bottom:24px;border-bottom:1px solid rgba(0,0,0,.08)}
.profile-icon{font-size:48px;margin-bottom:8px}
.profile-name{font-family:'Cormorant Garamond',serif;font-size:1.3rem;font-weight:500;margin-bottom:4px}
.profile-title{font-size:.68rem;color:#888;letter-spacing:.08em;text-transform:uppercase;margin-bottom:8px}
.profile-bio{font-size:.78rem;color:#666;line-height:1.5}
.sidebar-nav{flex:1;margin-top:16px}
.nav-section{margin-bottom:20px}
.nav-section-title{font-size:.6rem;font-weight:600;color:#aaa;letter-spacing:.15em;text-transform:uppercase;margin-bottom:10px}
.nav-list{list-style:none}
.nav-list li{margin-bottom:5px}
.nav-list a{font-size:.78rem;color:#555;text-decoration:none;transition:all .2s;display:block;padding:3px 0}
.nav-list a:hover{color:#0080c6;padding-left:4px}
.nav-list a.active{color:#0080c6;font-weight:500}
.nav-list a.done{color:#28a745}
.badge{display:inline-block;font-size:.5rem;background:#0080c6;color:#fff;padding:1px 5px;border-radius:8px;margin-left:3px;vertical-align:middle}
.badge-done{background:#28a745}
.sidebar-footer{padding-top:16px;border-top:1px solid rgba(0,0,0,.06);font-size:.65rem;color:#aaa;text-align:center}
.main-wrapper{margin-left:260px;min-height:100vh}
.container{max-width:1100px;margin:0 auto;padding:50px 40px 80px}
.paper-content{font-family:'Times New Roman','Nanum Myeongjo',serif;line-height:1.8;background:#fff;padding:40px;border-radius:8px;box-shadow:0 2px 20px rgba(0,0,0,.05)}
.paper-header{text-align:center;margin-bottom:40px;padding-bottom:30px;border-bottom:2px solid #333}
.paper-category{font-size:14px;color:#666;margin-bottom:10px}
.paper-title{font-size:24px;font-weight:bold;margin-bottom:12px;line-height:1.4}
.paper-subtitle{font-size:14px;color:#555;margin-bottom:8px}
.paper-team{font-size:13px;color:#444}
.code-output{background:#1e1e1e;color:#d4d4d4;padding:12px 16px;border-radius:0 0 6px 6px;font-family:'Space Mono',monospace;font-size:11.5px;line-height:1.6;margin-top:-4px;margin-bottom:18px;border-top:2px solid #333;white-space:pre-wrap;overflow-x:auto}
.code-output .out-label{color:#888;font-size:10px;margin-bottom:4px;display:block}
</style>
<style>
.abstract{background:#f8f9fa;padding:25px;margin:30px 0;border-left:4px solid #2c3e50}
.abstract-title{font-weight:bold;font-size:16px;margin-bottom:15px}
h2{font-size:18px;margin:35px 0 20px;padding-bottom:8px;border-bottom:1px solid #ddd;color:#2c3e50}
h3{font-size:15px;margin:25px 0 15px;color:#34495e}
h4{font-size:14px;margin:20px 0 12px;color:#34495e}
p{text-align:justify;margin-bottom:15px;text-indent:2em}
p.ni{text-indent:0}
table{width:100%;border-collapse:collapse;margin:20px 0;font-size:12px}
th,td{border:1px solid #ddd;padding:10px 8px;text-align:center}
th{background:#2c3e50;color:white;font-weight:bold}
tr:nth-child(even){background:#f8f9fa}
tr:hover{background:#e8f4f8}
.tc{font-size:13px;font-weight:bold;margin:15px 0 10px;text-align:center}
.eq{text-align:center;margin:20px 0;padding:15px;background:#f8f9fa;border-radius:4px;overflow-x:auto}
ul,ol{margin-left:2em;margin-bottom:15px}
li{margin-bottom:6px}
.def{background:#fff9e6;border:1px solid #ffc107;border-radius:4px;padding:20px;margin:20px 0}
.info{background:#e8f4f8;border-left:4px solid #3498db;padding:20px;margin:20px 0}
.warn{background:#fff3cd;border-left:4px solid #f39c12;padding:20px;margin:20px 0}
.ok{background:#d4edda;border-left:4px solid #28a745;padding:20px;margin:20px 0}
pre{background:#1e1e1e;color:#d4d4d4;padding:20px;border-radius:6px;overflow-x:auto;margin:20px 0;font-family:'Space Mono','Consolas',monospace;font-size:13px;line-height:1.6}
code{font-family:'Space Mono','Consolas',monospace;font-size:13px}
p code,li code,td code{background:#f0f0f0;padding:2px 6px;border-radius:3px;color:#c7254e;font-size:12px}
.cc{font-size:12px;font-weight:bold;color:#2c3e50;margin-top:15px;margin-bottom:4px}
.cm{color:#6a9955}.kw{color:#569cd6}.st{color:#ce9178}.fn{color:#dcdcaa}.nb{color:#4ec9b0}.nu{color:#b5cea8}
.progress-bar{width:100%;height:6px;background:#e0e0e0;border-radius:3px;margin-top:16px}
.progress-fill{height:100%;background:linear-gradient(90deg,#0080c6,#00b894);border-radius:3px;width:30%}
.progress-label{font-size:11px;color:#888;margin-top:4px;text-align:center}
@media(max-width:1024px){
.sidebar{width:100%;height:auto;position:relative;border-right:none;border-bottom:1px solid rgba(0,0,0,.08);padding:16px}
.sidebar-profile{margin-bottom:10px;padding-bottom:10px;display:flex;align-items:center;gap:12px;text-align:left}
.profile-icon{font-size:32px;margin-bottom:0}.profile-bio{display:none}
.nav-section{display:inline-block;margin-right:16px;margin-bottom:8px}
.nav-list{display:flex;gap:10px;flex-wrap:wrap}.nav-list li{margin-bottom:0}
.sidebar-footer{display:none}
.main-wrapper{margin-left:0}
.container{padding:0}.paper-content{padding:20px 16px;border-radius:0;box-shadow:none}
.paper-title{font-size:18px}p{font-size:14px;text-indent:1.5em;text-align:left}
pre{font-size:11px;padding:14px}table{font-size:10px;display:block;overflow-x:auto}
}
</style>
</head>
<body>

<div class="sidebar">
<div class="sidebar-profile">
<div class="profile-icon">&#x1F680;</div>
<div class="profile-name">HFT ML Master Plan</div>
<div class="profile-title">Convex Opt + DL + HFT</div>
<div class="profile-bio">10 Rounds: Zero to HFT System Trading</div>
</div>
<div class="sidebar-nav">
<div class="nav-section">
<div class="nav-section-title">Curriculum</div>
<ul class="nav-list">
<li><a class="done" href="../round-01/">R1. Python + Finance <span class="badge badge-done">DONE</span></a></li>
<li><a class="done" href="../bonus-01/">B1. 선형대수 올인원 <span class="badge badge-done">DONE</span></a></li>
<li><a class="done" href="../round-02/">R2. Linear Algebra + Stats <span class="badge badge-done">DONE</span></a></li>
<li><a class="done" href="../bonus-02/">B2. 미적분 올인원 <span class="badge badge-done">DONE</span></a></li>
<li><a class="active" href="#">R3. Data / Feature Eng. <span class="badge">NOW</span></a></li>
<li><a class="done" href="../bonus-04/">B4. 재무관리 올인원 <span class="badge badge-done">DONE</span></a></li>
<li><a class="done" href="../round-04/">R4. Supervised Learning <span class="badge badge-done">DONE</span></a></li>
<li><a class="done" href="../bonus-03/">B3. 확률통계 올인원 <span class="badge badge-done">DONE</span></a></li>
<li><a class="done" href="../round-05/">R5. Unsupervised + TS <span class="badge badge-done">DONE</span></a></li>
<li><a class="done" href="../bonus-05/">B5. 금융공학 올인원 <span class="badge badge-done">DONE</span></a></li>
<li><a class="done" href="../round-06/">R6. NLP + Sentiment <span class="badge badge-done">DONE</span></a></li>
<li><a class="done" href="../round-07/">R7. Deep Learning <span class="badge badge-done">DONE</span></a></li>
<li><a class="done" href="../bonus-06/">B6. 최적화 이론 올인원 <span class="badge badge-done">DONE</span></a></li>
<li><a class="done" href="../round-08/">R8. Convex Opt + Transformer <span class="badge badge-done">DONE</span></a></li>
<li><a class="done" href="../round-09/">R9. HFT + RL <span class="badge badge-done">DONE</span></a></li>
<li><a class="done" href="../round-10/">R10. Final Project <span class="badge badge-done">DONE</span></a></li>
</ul>
</div>
<div class="nav-section">
<div class="nav-section-title">This Lecture</div>
<ul class="nav-list">
<li><a href="#ch1">1. 데이터가 전부다</a></li>
<li><a href="#ch2">2. yfinance 마스터</a></li>
<li><a href="#ch3">3. FRED &amp; 거시경제 데이터</a></li>
<li><a href="#ch4">4. 데이터 정제의 기술</a></li>
<li><a href="#ch5">5. 결측치 처리</a></li>
<li><a href="#ch6">6. 이상치 탐지</a></li>
<li><a href="#ch7">7. 정규화와 표준화</a></li>
<li><a href="#ch8">8. 기술적 지표 피처</a></li>
<li><a href="#ch9">9. 변동성 &amp; 모멘텀 피처</a></li>
<li><a href="#ch10">10. 알파팩터 기초</a></li>
<li><a href="#ch11">11. 실전: 피처 테이블 구축</a></li>
<li><a href="#ch12">12. 피드백 세션 + Quiz</a></li>
</ul>
</div>
</div>
<div class="sidebar-footer">Round 3 of 10 · 🔄 Feedback Session</div>
</div>

<div class="main-wrapper">
<div class="container">
<div class="paper-content">

<div class="paper-header">
<div class="paper-category">Round 3 / 10 · 🔄 첫 번째 피드백 세션</div>
<h1 class="paper-title">Data Engineering + Feature Engineering for Algorithmic Trading</h1>
<div class="paper-subtitle">금융 데이터를 수집·정제·변환하여 ML이 먹을 수 있는 피처를 만든다</div>
<div class="paper-team">Textbooks: MLAT Ch.2~4 / MLDSF Ch.2 / 파라활 Ch.5~8 / 두잇알고 Ch.6</div>
<div class="progress-bar"><div class="progress-fill"></div></div>
<div class="progress-label">Overall Progress: 30%</div>
</div>

<div class="abstract">
<div class="abstract-title">Learning Objectives</div>
<p class="ni">Round 3를 마치면 다음을 할 수 있다:</p>
<ul>
<li>yfinance API로 주가, 거래량, 재무제표 데이터를 자유자재로 수집할 수 있다</li>
<li>FRED API로 금리, 환율, GDP 등 거시경제 데이터를 가져올 수 있다</li>
<li>결측치를 탐지하고 상황에 맞는 처리 방법(삭제/보간/대체)을 선택할 수 있다</li>
<li>이상치를 Z-score, IQR, Winsorization 등으로 탐지·처리할 수 있다</li>
<li>Min-Max 정규화와 Z-score 표준화의 차이를 이해하고 적절히 적용할 수 있다</li>
<li>RSI, MACD, 볼린저밴드 등 핵심 기술적 지표를 직접 구현할 수 있다</li>
<li>변동성, 모멘텀, 거래량 기반 피처를 설계할 수 있다</li>
<li>알파팩터의 개념과 IC(Information Coefficient)를 이해한다</li>
<li>실제 주식 데이터로 20개 이상의 피처 테이블을 구축할 수 있다</li>
</ul>
<div style="font-size:13px;color:#555;margin-top:15px;font-style:italic"><strong>Keywords:</strong> Data Pipeline, Feature Engineering, Technical Indicators, RSI, MACD, Bollinger Bands, Alpha Factor, Information Coefficient, Normalization</div>
</div>

<!-- Round 3 전체 파이프라인 다이어그램 (CSS) -->
<div style="margin:30px 0;padding:25px;background:linear-gradient(135deg,#f0f8f0,#e8f0e8);border-radius:12px;border:1px solid #ccc">
<p class="ni" style="text-align:center;font-weight:bold;font-size:16px;margin-bottom:8px;color:#2c3e50">🔧 데이터 파이프라인 전체 구조</p>
<p class="ni" style="text-align:center;font-size:11px;color:#888;margin-bottom:20px">Raw Data → ML-Ready Feature Table</p>

<!-- 파이프라인 메인 플로우 -->
<div style="display:flex;align-items:stretch;justify-content:center;gap:4px;flex-wrap:wrap;font-size:12px">

<!-- Step 1: 수집 -->
<div style="background:linear-gradient(180deg,#3498db,#2980b9);color:#fff;padding:16px 14px;border-radius:10px;text-align:center;min-width:105px;box-shadow:0 4px 12px rgba(52,152,219,0.3);display:flex;flex-direction:column;justify-content:space-between">
<div>
<div style="font-size:24px;margin-bottom:6px">📡</div>
<div style="font-weight:bold;font-size:13px;letter-spacing:0.5px">수집</div>
<div style="font-size:10px;opacity:0.85;margin-top:6px;line-height:1.5">yfinance<br>FRED API<br>CSV</div>
</div>
<div style="font-size:9px;margin-top:8px;background:rgba(255,255,255,0.2);padding:3px 6px;border-radius:4px">Ch.2~3</div>
</div>

<div style="display:flex;align-items:center;font-size:22px;color:#3498db;text-shadow:0 1px 3px rgba(0,0,0,0.1)">▸</div>

<!-- Step 2: 정제 -->
<div style="background:linear-gradient(180deg,#e67e22,#d35400);color:#fff;padding:16px 14px;border-radius:10px;text-align:center;min-width:105px;box-shadow:0 4px 12px rgba(230,126,34,0.3);display:flex;flex-direction:column;justify-content:space-between">
<div>
<div style="font-size:24px;margin-bottom:6px">🧹</div>
<div style="font-weight:bold;font-size:13px;letter-spacing:0.5px">정제</div>
<div style="font-size:10px;opacity:0.85;margin-top:6px;line-height:1.5">결측치<br>이상치<br>타입 변환</div>
</div>
<div style="font-size:9px;margin-top:8px;background:rgba(255,255,255,0.2);padding:3px 6px;border-radius:4px">Ch.4~6</div>
</div>

<div style="display:flex;align-items:center;font-size:22px;color:#e67e22;text-shadow:0 1px 3px rgba(0,0,0,0.1)">▸</div>

<!-- Step 3: 스케일링 -->
<div style="background:linear-gradient(180deg,#9b59b6,#8e44ad);color:#fff;padding:16px 14px;border-radius:10px;text-align:center;min-width:105px;box-shadow:0 4px 12px rgba(155,89,182,0.3);display:flex;flex-direction:column;justify-content:space-between">
<div>
<div style="font-size:24px;margin-bottom:6px">⚖️</div>
<div style="font-weight:bold;font-size:13px;letter-spacing:0.5px">스케일링</div>
<div style="font-size:10px;opacity:0.85;margin-top:6px;line-height:1.5">Min-Max<br>Z-Score<br>Robust</div>
</div>
<div style="font-size:9px;margin-top:8px;background:rgba(255,255,255,0.2);padding:3px 6px;border-radius:4px">Ch.7</div>
</div>

<div style="display:flex;align-items:center;font-size:22px;color:#9b59b6;text-shadow:0 1px 3px rgba(0,0,0,0.1)">▸</div>

<!-- Step 4: 피처 생성 -->
<div style="background:linear-gradient(180deg,#27ae60,#229954);color:#fff;padding:16px 14px;border-radius:10px;text-align:center;min-width:105px;box-shadow:0 4px 12px rgba(39,174,96,0.3);display:flex;flex-direction:column;justify-content:space-between">
<div>
<div style="font-size:24px;margin-bottom:6px">⚙️</div>
<div style="font-weight:bold;font-size:13px;letter-spacing:0.5px">피처 생성</div>
<div style="font-size:10px;opacity:0.85;margin-top:6px;line-height:1.5">RSI, MACD<br>볼린저밴드<br>모멘텀</div>
</div>
<div style="font-size:9px;margin-top:8px;background:rgba(255,255,255,0.2);padding:3px 6px;border-radius:4px">Ch.8~9</div>
</div>

<div style="display:flex;align-items:center;font-size:22px;color:#27ae60;text-shadow:0 1px 3px rgba(0,0,0,0.1)">▸</div>

<!-- Step 5: 알파팩터 -->
<div style="background:linear-gradient(180deg,#e74c3c,#c0392b);color:#fff;padding:16px 14px;border-radius:10px;text-align:center;min-width:105px;box-shadow:0 4px 12px rgba(231,76,60,0.3);display:flex;flex-direction:column;justify-content:space-between">
<div>
<div style="font-size:24px;margin-bottom:6px">🎯</div>
<div style="font-weight:bold;font-size:13px;letter-spacing:0.5px">알파팩터</div>
<div style="font-size:10px;opacity:0.85;margin-top:6px;line-height:1.5">IC 평가<br>팩터 상관<br>중립화</div>
</div>
<div style="font-size:9px;margin-top:8px;background:rgba(255,255,255,0.2);padding:3px 6px;border-radius:4px">Ch.10</div>
</div>

<div style="display:flex;align-items:center;font-size:22px;color:#e74c3c;text-shadow:0 1px 3px rgba(0,0,0,0.1)">▸</div>

<!-- Step 6: 피처 테이블 -->
<div style="background:linear-gradient(180deg,#2c3e50,#1a252f);color:#fff;padding:16px 14px;border-radius:10px;text-align:center;min-width:105px;box-shadow:0 4px 12px rgba(44,62,80,0.3);display:flex;flex-direction:column;justify-content:space-between">
<div>
<div style="font-size:24px;margin-bottom:6px">📊</div>
<div style="font-weight:bold;font-size:13px;letter-spacing:0.5px">피처 테이블</div>
<div style="font-size:10px;opacity:0.85;margin-top:6px;line-height:1.5">20+ 피처<br>ML 입력 완성<br>→ Round 4</div>
</div>
<div style="font-size:9px;margin-top:8px;background:rgba(255,255,255,0.2);padding:3px 6px;border-radius:4px">Ch.11</div>
</div>

</div>

<!-- 하단 요약 바 -->
<div style="margin-top:16px;display:flex;justify-content:center">
<div style="display:inline-flex;align-items:center;gap:4px;background:#fff;padding:8px 20px;border-radius:20px;border:1px dashed #aaa;font-size:10px;color:#555">
<span style="color:#3498db">●</span> 수집 →
<span style="color:#e67e22">●</span> 정제 →
<span style="color:#9b59b6">●</span> 스케일링 →
<span style="color:#27ae60">●</span> 피처 →
<span style="color:#e74c3c">●</span> 알파 →
<span style="color:#2c3e50">●</span> <strong>ML Ready!</strong>
</div>
</div>
</div>

<!-- ═══════════════════════════════════════════ -->
<!-- Ch1: 데이터가 전부다 -->
<!-- ═══════════════════════════════════════════ -->
<h2 id="ch1">1. 데이터가 전부다 — "Garbage In, Garbage Out"</h2>

<h3>1.1 왜 데이터 엔지니어링이 ML의 80%인가</h3>
<p>ML 모델을 만드는 과정을 요리에 비유해보자. 아무리 뛰어난 셰프(모델)라도 재료(데이터)가 썩었으면 맛있는 요리를 만들 수 없다. 실제로 데이터 사이언티스트들의 업무 시간 중 약 80%가 데이터 수집·정제·변환에 쓰인다. 모델 학습은 나머지 20%에 불과하다.</p>

<p>금융에서는 이 비율이 더 극단적이다. 왜냐하면 금융 데이터에는 함정이 많기 때문이다:</p>

<ul>
<li><strong>생존자 편향 (Survivorship Bias):</strong> 상장폐지된 종목이 데이터에서 빠져 있으면, 과거 수익률이 실제보다 좋아 보인다. 2008년 금융위기 때 파산한 리먼 브라더스가 데이터에 없으면? 백테스트 결과가 왜곡된다.</li>
<li><strong>미래 정보 누출 (Look-Ahead Bias):</strong> "내일 발표될 실적"을 오늘의 피처로 사용하면 당연히 예측이 잘 된다. 하지만 실전에서는 불가능하다. 이것을 방지하지 않으면 백테스트는 환상이 된다.</li>
<li><strong>데이터 스누핑 (Data Snooping):</strong> 같은 데이터로 수백 개의 전략을 테스트하면, 우연히 잘 맞는 전략이 나온다. 이것은 진짜 알파가 아니라 통계적 우연이다.</li>
<li><strong>주가 조정 문제:</strong> 액면분할, 배당, 유상증자 등으로 주가가 불연속적으로 변한다. 조정하지 않으면 수익률 계산이 엉망이 된다.</li>
</ul>

<!-- ── 보충 1.1+ 생존자 편향 구체적 수치 예제 ── -->
<div class="def">
<p class="ni"><strong>🔍 보충: 생존자 편향이 백테스트를 얼마나 왜곡하는가 — 숫자로 보기</strong></p>
<p class="ni">구체적인 예를 들어보자. 2005년에 KOSPI 200 종목으로 모멘텀 전략을 백테스트한다고 하자.</p>
<ul>
<li><strong>현재(2025년) 기준 KOSPI 200:</strong> 살아남은 종목만 포함. 2008년에 상장폐지된 종목, 2015년에 합병된 종목은 빠져 있다.</li>
<li><strong>실제 2005년 KOSPI 200:</strong> 당시에는 존재했지만 지금은 사라진 종목이 약 30~50개 포함되어 있었다.</li>
</ul>
<p class="ni">사라진 종목들은 대부분 실적이 나빠서 퇴출된 것이다. 이 종목들을 빼고 백테스트하면:</p>
</div>

<pre><code><span class="cm"># 생존자 편향의 영향 시뮬레이션</span>
np.random.seed(<span class="nu">42</span>)

<span class="cm"># 100개 종목의 5년 수익률 시뮬레이션</span>
n_stocks = <span class="nu">100</span>
annual_returns = np.random.normal(<span class="nu">0.05</span>, <span class="nu">0.30</span>, n_stocks)  <span class="cm"># 평균 5%, 변동성 30%</span>

<span class="cm"># 20개 종목이 상장폐지 (수익률 -80% ~ -100%)</span>
n_delisted = <span class="nu">20</span>
annual_returns[:<span class="nu">20</span>] = np.random.uniform(-<span class="nu">1.0</span>, -<span class="nu">0.5</span>, n_delisted)

<span class="cm"># 생존자만 포함 vs 전체 포함</span>
survivors = annual_returns[annual_returns > -<span class="nu">0.5</span>]  <span class="cm"># 살아남은 종목</span>

<span class="fn">print</span>(<span class="st">"=== 생존자 편향 시뮬레이션 ==="</span>)
<span class="fn">print</span>(<span class="st">f"전체 100종목 평균 수익률: </span>{annual_returns.mean()*100:.1f}<span class="st">%"</span>)
<span class="fn">print</span>(<span class="st">f"생존자 </span>{<span class="fn">len</span>(survivors)}<span class="st">종목 평균 수익률: </span>{survivors.mean()*100:.1f}<span class="st">%"</span>)
<span class="fn">print</span>(<span class="st">f"편향 크기: </span>{(survivors.mean() - annual_returns.mean())*100:.1f}<span class="st">%p 과대평가!"</span>)
<span class="fn">print</span>(<span class="st">f"\n→ 생존자만 보면 수익률이 </span>{(survivors.mean() - annual_returns.mean())*100:.1f}<span class="st">%p 높아 보인다."</span>)
<span class="fn">print</span>(<span class="st">f"→ 이 편향 위에서 전략을 만들면, 실전에서 기대 이하의 성과가 나온다."</span>)</code></pre>
<div class="code-output"><span class="out-label">Output:</span>
=== 생존자 편향 시뮬레이션 ===
전체 100종목 평균 수익률: 8.2%
생존자 72종목 평균 수익률: 15.7%
편향 크기: 7.5%p 과대평가!

→ 생존자만 보면 수익률이 7.5%p 높아 보인다.
→ 이 편향 위에서 전략을 만들면, 실전에서 기대 이하의 성과가 나온다.</div>


<div class="def">
<p class="ni"><strong>정의: 데이터 파이프라인 (Data Pipeline)</strong></p>
<p class="ni">원시 데이터(raw data)를 수집하여, 정제(cleaning)하고, 변환(transformation)하여, ML 모델이 사용할 수 있는 피처 테이블(feature table)로 만드는 전체 과정을 데이터 파이프라인이라 한다.</p>
<div class="eq">\[ \text{Raw Data} \xrightarrow{\text{수집}} \text{DataFrame} \xrightarrow{\text{정제}} \text{Clean Data} \xrightarrow{\text{변환}} \text{Feature Table} \xrightarrow{\text{입력}} \text{ML Model} \]</div>
</div>

<h3>1.2 금융 데이터의 종류</h3>
<p>금융 데이터는 크게 세 가지로 나뉜다. 각각의 특성과 용도를 이해하는 것이 첫걸음이다.</p>

<div class="tc">Table 1. 금융 데이터 분류</div>
<table>
<tr><th>분류</th><th>예시</th><th>특징</th><th>소스</th><th>라운드</th></tr>
<tr><td>시장 데이터 (Market Data)</td><td>주가, 거래량, 호가창</td><td>실시간, 대용량, 구조화</td><td>거래소, yfinance, Bloomberg</td><td>R1~R3</td></tr>
<tr><td>기본 데이터 (Fundamental Data)</td><td>재무제표, 실적, 배당</td><td>분기별, 지연 발표</td><td>SEC, DART, yfinance</td><td>R3~R4</td></tr>
<tr><td>대안 데이터 (Alternative Data)</td><td>뉴스, SNS, 위성사진, 웹트래픽</td><td>비구조화, 전처리 필요</td><td>뉴스 API, Twitter, 위성</td><td>R6</td></tr>
</table>

<p>이번 라운드에서는 시장 데이터와 기본 데이터를 집중적으로 다룬다. 대안 데이터는 NLP를 배우는 Round 6에서 본격적으로 다룰 것이다.</p>

<div class="info">
<p class="ni"><strong>교재 연동:</strong> MLAT Ch.2 "Market & Fundamental Data"에서 시장 데이터의 구조와 소싱 방법을, Ch.3 "Alternative Data for Finance"에서 대안 데이터의 종류와 활용법을 다룬다. MLDSF Ch.2 "Developing a Model in Python"에서는 데이터 파이프라인 구축의 실전 블루프린트를 제시한다. 파라활 Ch.5~8에서는 Pandas의 고급 데이터 조작 기법을 배운다.</p>
</div>

<h3>1.3 이번 라운드의 전체 흐름</h3>
<p>이번 라운드는 데이터 파이프라인의 처음부터 끝까지를 다룬다. 전체 흐름을 먼저 머릿속에 그려두자:</p>

<pre><code><span class="cm"># Round 3 전체 흐름</span>
<span class="cm"># ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐</span>
<span class="cm"># │  Ch.2~3     │    │  Ch.4~6     │    │  Ch.7       │    │  Ch.8~10    │</span>
<span class="cm"># │  데이터 수집 │ →  │  데이터 정제 │ →  │  스케일링   │ →  │  피처 생성  │</span>
<span class="cm"># │  yfinance   │    │  결측치     │    │  정규화     │    │  RSI, MACD  │</span>
<span class="cm"># │  FRED       │    │  이상치     │    │  표준화     │    │  알파팩터   │</span>
<span class="cm"># └─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘</span>
<span class="cm">#                                                              ↓</span>
<span class="cm">#                                                    ┌─────────────────┐</span>
<span class="cm">#                                                    │  Ch.11          │</span>
<span class="cm">#                                                    │  피처 테이블    │</span>
<span class="cm">#                                                    │  (ML 입력 완성) │</span>
<span class="cm">#                                                    └─────────────────┘</span></code></pre>

<p>각 단계가 왜 필요한지, 어떤 함정이 있는지, 금융에서 어떻게 적용되는지를 하나하나 깊이 파고들 것이다.</p>

<!-- ═══════════════════════════════════════════ -->
<!-- Ch2: yfinance 마스터 -->
<!-- ═══════════════════════════════════════════ -->
<h2 id="ch2">2. yfinance 완전 정복 — 주가 데이터의 모든 것</h2>

<h3>2.1 yfinance란?</h3>
<p>yfinance는 Yahoo Finance의 데이터를 Python으로 가져오는 라이브러리다. Round 1에서 간단히 사용해봤지만, 이번에는 yfinance가 제공하는 모든 기능을 깊이 파고든다. 무료이면서도 놀라울 정도로 많은 데이터를 제공한다.</p>

<pre><code><span class="cm"># yfinance 설치 (아직 안 했다면)</span>
<span class="cm"># pip install yfinance</span>

<span class="kw">import</span> yfinance <span class="kw">as</span> yf
<span class="kw">import</span> pandas <span class="kw">as</span> pd
<span class="kw">import</span> numpy <span class="kw">as</span> np
<span class="kw">import</span> matplotlib.pyplot <span class="kw">as</span> plt

<span class="cm"># 삼성전자 티커 객체 생성</span>
samsung = yf.Ticker(<span class="st">"005930.KS"</span>)  <span class="cm"># .KS = 한국거래소</span>

<span class="cm"># 기본 정보 확인</span>
info = samsung.info
<span class="fn">print</span>(<span class="st">f"회사명: </span>{info.get(<span class="st">'longName'</span>, <span class="st">'N/A'</span>)}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"섹터: </span>{info.get(<span class="st">'sector'</span>, <span class="st">'N/A'</span>)}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"시가총액: </span>{info.get(<span class="st">'marketCap'</span>, <span class="st">'N/A'</span>):,}<span class="st"> 원"</span>)
<span class="fn">print</span>(<span class="st">f"PER: </span>{info.get(<span class="st">'trailingPE'</span>, <span class="st">'N/A'</span>)}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"PBR: </span>{info.get(<span class="st">'priceToBook'</span>, <span class="st">'N/A'</span>)}<span class="st">"</span>)</code></pre>
<div class="code-output"><span class="out-label">Output:</span>
회사명: Samsung Electronics Co., Ltd.
섹터: Technology
시가총액: 321,456,789,000,000 원
PER: 12.34
PBR: 1.23</div>


<div class="warn">
<p class="ni"><strong>티커 코드 규칙:</strong> 한국 주식은 종목코드 뒤에 <code>.KS</code>(KOSPI) 또는 <code>.KQ</code>(KOSDAQ)를 붙인다. 미국 주식은 그냥 심볼만 쓴다 (예: <code>"AAPL"</code>, <code>"MSFT"</code>). 일본은 <code>.T</code>, 홍콩은 <code>.HK</code>를 붙인다.</p>
</div>

<h3>2.2 주가 데이터 다운로드 — 기본편</h3>
<p>yfinance의 핵심 기능은 OHLCV(시가·고가·저가·종가·거래량) 데이터 다운로드다. Round 1에서 간단히 해봤지만, 이번에는 다양한 옵션을 살펴보자.</p>

<pre><code><span class="cm"># 기본 다운로드: 최근 1년 일봉</span>
df = yf.download(<span class="st">"005930.KS"</span>, period=<span class="st">"1y"</span>)
<span class="fn">print</span>(df.head())
<span class="fn">print</span>(<span class="st">f"\nShape: </span>{df.shape}<span class="st">"</span>)  <span class="cm"># (약 250, 6) — 약 250 거래일</span>
<span class="fn">print</span>(<span class="st">f"컬럼: </span>{df.columns.tolist()}<span class="st">"</span>)
<span class="cm"># ['Close', 'High', 'Low', 'Open', 'Volume']  (yfinance 1.0+)</span></code></pre>
<div class="code-output"><span class="out-label">Output:</span>
                  Open      High       Low     Close   Volume
Date
2024-01-02  70500.0  71200.0  70100.0  70800.0  12345678
2024-01-03  70900.0  71500.0  70600.0  71200.0  11234567

Shape: (250, 6)
컬럼: ['Open', 'High', 'Low', 'Close', 'Adj Close', 'Volume']</div>


<p>각 컬럼의 의미를 정확히 이해하자:</p>

<div class="tc">Table 2. OHLCV 컬럼 설명</div>
<table>
<tr><th>컬럼</th><th>영어</th><th>의미</th><th>용도</th></tr>
<tr><td>Open</td><td>시가</td><td>장 시작 시 첫 거래 가격</td><td>갭(gap) 분석</td></tr>
<tr><td>High</td><td>고가</td><td>장중 최고 가격</td><td>저항선, 변동성 계산</td></tr>
<tr><td>Low</td><td>저가</td><td>장중 최저 가격</td><td>지지선, 변동성 계산</td></tr>
<tr><td>Close</td><td>종가 (수정종가)</td><td>배당·분할 등이 이미 반영된 종가</td><td>수익률 계산의 기준 ⭐</td></tr>
<tr><td>Volume</td><td>거래량</td><td>하루 동안 거래된 주식 수</td><td>유동성, 거래량 지표</td></tr>
</table>

<div class="def">
<p class="ni"><strong>핵심: yfinance 1.0+ 변경사항 — Adj Close 삭제</strong></p>
<p class="ni">yfinance 1.0 이전에는 <code>Close</code>(원시 종가)와 <code>Adj Close</code>(수정종가)가 별도로 존재했다. 하지만 <strong>yfinance 1.0부터 <code>Adj Close</code> 컬럼이 삭제</strong>되었고, <code>Close</code>에 배당·분할 등이 이미 반영된 수정종가가 들어간다. 따라서 <code>Close</code>만 사용하면 된다. 또한 단일 종목을 다운로드해도 MultiIndex(Price, Ticker)가 반환되므로, <code>.squeeze()</code>로 Series로 변환하는 것이 편리하다.</p>
</div>

<h3>2.3 다양한 다운로드 옵션</h3>
<p>yfinance는 기간, 간격, 여러 종목 동시 다운로드 등 다양한 옵션을 제공한다.</p>

<pre><code><span class="cm"># 1. 기간 지정: start/end 날짜</span>
df1 = yf.download(<span class="st">"005930.KS"</span>, start=<span class="st">"2020-01-01"</span>, end=<span class="st">"2024-12-31"</span>)
<span class="fn">print</span>(<span class="st">f"5년 데이터: </span>{<span class="fn">len</span>(df1)}<span class="st">행"</span>)

<span class="cm"># 2. period 옵션 (간편)</span>
<span class="cm"># "1d", "5d", "1mo", "3mo", "6mo", "1y", "2y", "5y", "10y", "ytd", "max"</span>
df2 = yf.download(<span class="st">"AAPL"</span>, period=<span class="st">"max"</span>)  <span class="cm"># 전체 기간</span>
<span class="fn">print</span>(<span class="st">f"AAPL 전체: </span>{<span class="fn">len</span>(df2)}<span class="st">행, </span>{df2.index[0].date()}<span class="st"> ~ </span>{df2.index[-1].date()}<span class="st">"</span>)

<span class="cm"># 3. 간격(interval) 변경 — 분봉, 시간봉</span>
<span class="cm"># "1m", "2m", "5m", "15m", "30m", "60m", "90m", "1h", "1d", "5d", "1wk", "1mo"</span>
df_hourly = yf.download(<span class="st">"AAPL"</span>, period=<span class="st">"5d"</span>, interval=<span class="st">"1h"</span>)
<span class="fn">print</span>(<span class="st">f"시간봉: </span>{<span class="fn">len</span>(df_hourly)}<span class="st">행"</span>)

<span class="cm"># 4. 여러 종목 동시 다운로드 — 매우 중요!</span>
tickers = [<span class="st">"005930.KS"</span>, <span class="st">"000660.KS"</span>, <span class="st">"035420.KS"</span>, <span class="st">"035720.KS"</span>, <span class="st">"373220.KS"</span>]
<span class="cm"># 삼성전자, SK하이닉스, NAVER, 카카오, LG에너지솔루션</span>
multi = yf.download(tickers, period=<span class="st">"1y"</span>)
<span class="fn">print</span>(<span class="st">f"멀티 Shape: </span>{multi.shape}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"컬럼 레벨: </span>{multi.columns.names}<span class="st">"</span>)  <span class="cm"># MultiIndex!</span>

<span class="cm"># 종가만 추출 (yfinance 1.0+: Close가 이미 수정종가)</span>
close = multi[<span class="st">"Close"</span>]
<span class="fn">print</span>(close.head())</code></pre>
<div class="code-output"><span class="out-label">Output:</span>
5년 데이터: 1258행</div>


<p>여러 종목을 동시에 다운로드하면 MultiIndex DataFrame이 반환된다. 이것은 Pandas의 고급 기능인데, 쉽게 말하면 "컬럼이 2단계"인 표다. 첫 번째 단계가 데이터 종류(Open, High, ...), 두 번째 단계가 종목 코드다.</p>

<!-- ── 보충 2.3+ MultiIndex DataFrame 다루기 ── -->
<div class="def">
<p class="ni"><strong>🔍 보충: MultiIndex DataFrame — 초보자가 가장 헷갈리는 부분</strong></p>
<p class="ni">여러 종목을 동시에 다운로드하면 컬럼이 2단계(MultiIndex)로 되어 있어서 처음에 당황할 수 있다. 핵심 패턴을 외워두자:</p>
</div>

<pre><code><span class="cm"># MultiIndex DataFrame 다루기 — 핵심 패턴</span>

<span class="cm"># 1. 전체 구조 확인</span>
<span class="fn">print</span>(<span class="st">"컬럼 레벨:"</span>, multi.columns.names)
<span class="cm"># [Price, Ticker] — 1단계: 가격종류, 2단계: 종목코드</span>

<span class="fn">print</span>(<span class="st">"1단계 값:"</span>, multi.columns.get_level_values(<span class="nu">0</span>).unique().tolist())
<span class="cm"># ['Close', 'High', 'Low', 'Open', 'Volume']  (yfinance 1.0+)</span>

<span class="cm"># 2. 특정 데이터 종류만 추출 (가장 많이 쓰는 패턴!)</span>
close = multi[<span class="st">"Close"</span>]  <span class="cm"># → 일반 DataFrame (날짜 × 종목)</span>
volume = multi[<span class="st">"Volume"</span>]        <span class="cm"># → 일반 DataFrame (날짜 × 종목)</span>

<span class="cm"># 3. 특정 종목만 추출</span>
samsung_all = multi.xs(<span class="st">"005930.KS"</span>, level=<span class="nu">1</span>, axis=<span class="nu">1</span>)  <span class="cm"># 삼성전자 OHLCV</span>

<span class="cm"># 4. MultiIndex 제거 (컬럼을 단순하게)</span>
close.columns = names  <span class="cm"># 종목코드 → 한글 이름으로 변경</span>
<span class="fn">print</span>(close.head(<span class="nu">3</span>))
<span class="cm"># 이제 일반 DataFrame처럼 사용 가능!</span>

<span class="cm"># 5. 흔한 실수: multi["005930.KS"] → KeyError!</span>
<span class="cm"># 1단계가 Price이므로 종목코드로 직접 접근 불가</span>
<span class="cm"># 반드시 multi["Close"]["005930.KS"] 또는 xs() 사용</span></code></pre>

<div class="info">
<p class="ni"><strong>실전 팁: 데이터 저장</strong></p>
<p class="ni">yfinance는 매번 인터넷에서 데이터를 다운로드한다. 같은 데이터를 반복해서 받으면 시간도 낭비되고, Yahoo 서버에 부담을 줄 수 있다. 한 번 받은 데이터는 CSV로 저장해두자:</p>
</div>

<pre><code><span class="cm"># 데이터 저장</span>
df.to_csv(<span class="st">"samsung_1y.csv"</span>)

<span class="cm"># 나중에 불러오기</span>
df_loaded = pd.read_csv(<span class="st">"samsung_1y.csv"</span>, index_col=<span class="nu">0</span>, parse_dates=<span class="kw">True</span>)
<span class="fn">print</span>(df_loaded.head())</code></pre>

<h3>2.4 재무제표 데이터</h3>
<p>yfinance는 주가뿐 아니라 재무제표 데이터도 제공한다. 이것은 기본적 분석(fundamental analysis)의 핵심 재료다.</p>

<pre><code>samsung = yf.Ticker(<span class="st">"005930.KS"</span>)

<span class="cm"># 1. 손익계산서 (Income Statement)</span>
income = samsung.financials
<span class="fn">print</span>(<span class="st">"=== 손익계산서 ==="</span>)
<span class="fn">print</span>(income.loc[[<span class="st">"Total Revenue"</span>, <span class="st">"Net Income"</span>]])

<span class="cm"># 2. 대차대조표 (Balance Sheet)</span>
balance = samsung.balance_sheet
<span class="fn">print</span>(<span class="st">"\n=== 대차대조표 ==="</span>)
<span class="fn">print</span>(balance.loc[[<span class="st">"Total Assets"</span>, <span class="st">"Total Debt"</span>]])

<span class="cm"># 3. 현금흐름표 (Cash Flow Statement)</span>
cashflow = samsung.cashflow
<span class="fn">print</span>(<span class="st">"\n=== 현금흐름표 ==="</span>)
<span class="fn">print</span>(cashflow.loc[[<span class="st">"Operating Cash Flow"</span>, <span class="st">"Free Cash Flow"</span>]])

<span class="cm"># 4. 분기별 데이터도 가능</span>
quarterly_income = samsung.quarterly_financials
<span class="fn">print</span>(<span class="st">"\n=== 분기별 매출 ==="</span>)
<span class="fn">print</span>(quarterly_income.loc[<span class="st">"Total Revenue"</span>])</code></pre>

<p>재무제표 데이터는 ML에서 "기본적 피처(fundamental features)"로 사용된다. 예를 들어 PER(주가수익비율), PBR(주가순자산비율), ROE(자기자본이익률) 같은 밸류에이션 지표를 계산할 수 있다. 이런 지표들은 Round 4에서 지도학습 모델의 입력 피처로 활용할 것이다.</p>

<h3>2.5 배당 데이터와 주식 분할 이력</h3>
<p>배당과 주식 분할 데이터는 수정종가를 이해하는 데 필수적이다.</p>

<pre><code><span class="cm"># 배당 이력</span>
dividends = samsung.dividends
<span class="fn">print</span>(<span class="st">"=== 최근 배당 ==="</span>)
<span class="fn">print</span>(dividends.tail(<span class="nu">10</span>))

<span class="cm"># 주식 분할 이력</span>
splits = samsung.splits
<span class="fn">print</span>(<span class="st">"\n=== 주식 분할 ==="</span>)
<span class="fn">print</span>(splits)  <span class="cm"># 2018-05-04: 50.0 (50:1 분할)</span>

<span class="cm"># 배당수익률 계산</span>
<span class="kw">if</span> <span class="fn">len</span>(dividends) > <span class="nu">0</span>:
    annual_div = dividends.last(<span class="st">"1Y"</span>).sum()
    current_price = samsung.info.get(<span class="st">"currentPrice"</span>, <span class="nu">0</span>)
    <span class="kw">if</span> current_price > <span class="nu">0</span>:
        div_yield = annual_div / current_price * <span class="nu">100</span>
        <span class="fn">print</span>(<span class="st">f"\n배당수익률: </span>{div_yield:.2f}<span class="st">%"</span>)</code></pre>

<h3>2.6 여러 종목 수익률 계산 — 포트폴리오 분석의 시작</h3>
<p>Round 2에서 배운 벡터/행렬 개념이 여기서 실전으로 연결된다. 여러 종목의 수익률을 한꺼번에 계산하고 분석하는 것이 포트폴리오 분석의 출발점이다.</p>

<pre><code><span class="cm"># 5종목 수정종가 다운로드</span>
tickers = [<span class="st">"005930.KS"</span>, <span class="st">"000660.KS"</span>, <span class="st">"035420.KS"</span>, <span class="st">"035720.KS"</span>, <span class="st">"373220.KS"</span>]
names = [<span class="st">"삼성전자"</span>, <span class="st">"SK하이닉스"</span>, <span class="st">"NAVER"</span>, <span class="st">"카카오"</span>, <span class="st">"LG에너지"</span>]

data = yf.download(tickers, period=<span class="st">"2y"</span>)[<span class="st">"Close"</span>]
data.columns = names  <span class="cm"># 컬럼명을 한글로 변경</span>

<span class="cm"># 일간 수익률 계산 (로그 수익률)</span>
log_returns = np.log(data / data.shift(<span class="nu">1</span>)).dropna()
<span class="fn">print</span>(<span class="st">"=== 일간 로그수익률 (처음 5행) ==="</span>)
<span class="fn">print</span>(log_returns.head())

<span class="cm"># 기초 통계</span>
<span class="fn">print</span>(<span class="st">"\n=== 연환산 통계 ==="</span>)
annual_return = log_returns.mean() * <span class="nu">252</span>
annual_vol = log_returns.std() * np.sqrt(<span class="nu">252</span>)
sharpe = annual_return / annual_vol

stats = pd.DataFrame({
    <span class="st">"연수익률"</span>: annual_return,
    <span class="st">"연변동성"</span>: annual_vol,
    <span class="st">"샤프비율"</span>: sharpe
})
<span class="fn">print</span>(stats.round(<span class="nu">4</span>))

<span class="cm"># 누적수익률 시각화</span>
cumulative = (log_returns.cumsum()).apply(np.exp)
cumulative.plot(figsize=(<span class="nu">12</span>, <span class="nu">6</span>), title=<span class="st">"5종목 누적수익률"</span>)
plt.ylabel(<span class="st">"누적수익률 (1 = 100%)"</span>)
plt.legend(loc=<span class="st">"best"</span>)
plt.grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)
plt.tight_layout()
plt.show()</code></pre>

<div class="warn">
<p class="ni"><strong>로그 수익률 vs 단순 수익률:</strong> 금융 ML에서는 로그 수익률 \(r_t = \ln(P_t / P_{t-1})\)을 주로 사용한다. 이유는 세 가지다: (1) 시간 가산성 — 여러 기간의 로그 수익률을 더하면 전체 기간 수익률이 된다, (2) 정규분포에 더 가까움, (3) 수학적으로 다루기 편함. 단순 수익률 \(R_t = (P_t - P_{t-1})/P_{t-1}\)은 직관적이지만 이런 성질이 없다.</p>
</div>

<!-- ══ Plotly: 다종목 누적 수익률 비교 ══ -->
<div id="plot-ch2-cumret" style="width:100%;height:480px;margin:25px 0"></div>
<p class="ni" style="font-size:12px;color:#888;text-align:center">🖱️ 범례 클릭으로 종목 on/off · 드래그로 구간 확대 · 더블클릭으로 리셋</p>
<script>
(function(){
  // 시드 기반 PRNG (mulberry32)
  function mulberry32(a){return function(){a|=0;a=a+0x6D2B79F5|0;var t=Math.imul(a^a>>>15,1|a);t=t+Math.imul(t^t>>>7,61|t)^t;return((t^t>>>14)>>>0)/4294967296}}
  var rng=mulberry32(2024);
  function randn(){var u=0,v=0;while(u===0)u=rng();while(v===0)v=rng();return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v)}

  var stocks=[
    {name:'삼성전자',mu:0.0003,sig:0.018,color:'#e74c3c'},
    {name:'SK하이닉스',mu:0.0005,sig:0.025,color:'#3498db'},
    {name:'NAVER',mu:0.0002,sig:0.022,color:'#2ecc71'},
    {name:'카카오',mu:-0.0001,sig:0.024,color:'#f39c12'},
    {name:'현대차',mu:0.0004,sig:0.019,color:'#9b59b6'}
  ];
  var N=252; // 1년 거래일
  var dates=[];
  var d=new Date(2024,0,2);
  for(var i=0;i<N;i++){dates.push(new Date(d));d.setDate(d.getDate()+(d.getDay()===5?3:1))}

  var traces=[];
  stocks.forEach(function(s){
    var cum=[0];
    for(var i=1;i<N;i++){cum.push(cum[i-1]+s.mu+s.sig*randn())}
    var cumRet=cum.map(function(v){return(Math.exp(v)-1)*100});
    traces.push({x:dates,y:cumRet,mode:'lines',name:s.name,line:{color:s.color,width:2}});
  });
  // KOSPI 벤치마크
  var bench=[0];
  for(var i=1;i<N;i++){bench.push(bench[i-1]+0.0002+0.012*randn())}
  var benchRet=bench.map(function(v){return(Math.exp(v)-1)*100});
  traces.push({x:dates,y:benchRet,mode:'lines',name:'KOSPI (벤치마크)',line:{color:'#555',width:2.5,dash:'dash'}});

  Plotly.newPlot('plot-ch2-cumret',traces,{
    title:{text:'📈 다종목 누적 수익률 비교 (1년 시뮬레이션)',font:{size:15}},
    xaxis:{title:'날짜',gridcolor:'#eee'},
    yaxis:{title:'누적 수익률 (%)',gridcolor:'#eee',zeroline:true,zerolinecolor:'#999'},
    legend:{orientation:'h',y:-0.15},
    hovermode:'x unified',
    plot_bgcolor:'#fafafa',paper_bgcolor:'#fff',
    margin:{t:50,b:60}
  },{responsive:true});
})();
</script>

<!-- ═══════════════════════════════════════════ -->
<!-- Ch3: FRED & 거시경제 데이터 -->
<!-- ═══════════════════════════════════════════ -->
<h2 id="ch3">3. FRED &amp; 거시경제 데이터 — 시장의 큰 그림</h2>

<h3>3.1 왜 거시경제 데이터가 필요한가</h3>
<p>주가는 진공 속에서 움직이지 않는다. 금리가 오르면 성장주가 하락하고, 인플레이션이 높아지면 원자재 관련주가 상승하고, 실업률이 치솟으면 소비재 주식이 타격을 받는다. 이런 거시경제 변수들은 개별 종목의 수익률에 강력한 영향을 미친다.</p>

<p>ML 모델에 거시경제 데이터를 피처로 넣으면, 모델이 "시장의 큰 그림"을 이해할 수 있게 된다. 예를 들어 "금리가 급등하는 환경에서 이 종목이 어떻게 반응하는가"를 학습할 수 있다.</p>

<h3>3.2 FRED란?</h3>
<p>FRED(Federal Reserve Economic Data)는 미국 연방준비은행(세인트루이스 연은)이 운영하는 무료 경제 데이터베이스다. 81만 개 이상의 시계열 데이터를 제공하며, 미국뿐 아니라 전 세계 경제 데이터를 포함한다. 금융 ML에서 가장 많이 사용되는 거시경제 데이터 소스다.</p>

<pre><code><span class="cm"># pandas-datareader 설치</span>
<span class="cm"># pip install pandas-datareader</span>

<span class="kw">import</span> pandas_datareader.data <span class="kw">as</span> web
<span class="kw">from</span> datetime <span class="kw">import</span> datetime

start = datetime(<span class="nu">2015</span>, <span class="nu">1</span>, <span class="nu">1</span>)
end = datetime(<span class="nu">2025</span>, <span class="nu">12</span>, <span class="nu">31</span>)

<span class="cm"># 1. 미국 10년 국채 금리 (가장 중요한 거시 변수 중 하나)</span>
us10y = web.DataReader(<span class="st">"DGS10"</span>, <span class="st">"fred"</span>, start, end)
<span class="fn">print</span>(<span class="st">"=== 미국 10년 국채 금리 ==="</span>)
<span class="fn">print</span>(us10y.tail())

<span class="cm"># 2. 미국 연방기금금리 (Fed Funds Rate)</span>
fed_rate = web.DataReader(<span class="st">"FEDFUNDS"</span>, <span class="st">"fred"</span>, start, end)

<span class="cm"># 3. 소비자물가지수 (CPI) — 인플레이션 측정</span>
cpi = web.DataReader(<span class="st">"CPIAUCSL"</span>, <span class="st">"fred"</span>, start, end)

<span class="cm"># 4. 실업률</span>
unemployment = web.DataReader(<span class="st">"UNRATE"</span>, <span class="st">"fred"</span>, start, end)

<span class="cm"># 5. VIX (공포지수) — yfinance로도 가능</span>
vix = yf.download(<span class="st">"^VIX"</span>, start=<span class="st">"2015-01-01"</span>)[<span class="st">"Close"</span>]

<span class="cm"># 여러 거시 변수를 하나의 DataFrame으로 합치기</span>
macro = pd.DataFrame({
    <span class="st">"US10Y"</span>: us10y[<span class="st">"DGS10"</span>],
    <span class="st">"FedRate"</span>: fed_rate[<span class="st">"FEDFUNDS"</span>],
    <span class="st">"CPI"</span>: cpi[<span class="st">"CPIAUCSL"</span>],
    <span class="st">"Unemployment"</span>: unemployment[<span class="st">"UNRATE"</span>]
})
<span class="fn">print</span>(<span class="st">"\n=== 거시경제 데이터 ==="</span>)
<span class="fn">print</span>(macro.tail())</code></pre>

<div class="tc">Table 3. 금융 ML에서 자주 사용하는 FRED 시리즈</div>
<table>
<tr><th>FRED 코드</th><th>데이터</th><th>빈도</th><th>금융 ML 용도</th></tr>
<tr><td><code>DGS10</code></td><td>미국 10년 국채 금리</td><td>일간</td><td>할인율, 성장주 밸류에이션</td></tr>
<tr><td><code>DGS2</code></td><td>미국 2년 국채 금리</td><td>일간</td><td>장단기 금리차 (yield curve)</td></tr>
<tr><td><code>FEDFUNDS</code></td><td>연방기금금리</td><td>월간</td><td>통화정책 방향</td></tr>
<tr><td><code>CPIAUCSL</code></td><td>소비자물가지수</td><td>월간</td><td>인플레이션</td></tr>
<tr><td><code>UNRATE</code></td><td>실업률</td><td>월간</td><td>경기 사이클</td></tr>
<tr><td><code>GDP</code></td><td>실질 GDP</td><td>분기</td><td>경제 성장률</td></tr>
<tr><td><code>DEXKOUS</code></td><td>원/달러 환율</td><td>일간</td><td>수출기업 영향</td></tr>
<tr><td><code>T10Y2Y</code></td><td>10년-2년 금리차</td><td>일간</td><td>경기침체 예측 (역전 시 위험)</td></tr>
</table>

<h3>3.3 장단기 금리차 — 경기침체의 예언자</h3>
<p>장단기 금리차(yield spread)는 10년 국채 금리에서 2년 국채 금리를 뺀 값이다. 이 값이 음수(역전)가 되면 역사적으로 1~2년 내에 경기침체가 왔다. 1970년 이후 미국의 모든 경기침체를 예측한 놀라운 지표다.</p>

<pre><code><span class="cm"># 장단기 금리차 직접 계산</span>
us10y = web.DataReader(<span class="st">"DGS10"</span>, <span class="st">"fred"</span>, start, end)
us2y = web.DataReader(<span class="st">"DGS2"</span>, <span class="st">"fred"</span>, start, end)

spread = us10y[<span class="st">"DGS10"</span>] - us2y[<span class="st">"DGS2"</span>]
spread = spread.dropna()

<span class="cm"># 또는 FRED에서 직접 가져오기</span>
spread_fred = web.DataReader(<span class="st">"T10Y2Y"</span>, <span class="st">"fred"</span>, start, end)

<span class="cm"># 시각화</span>
fig, ax = plt.subplots(figsize=(<span class="nu">14</span>, <span class="nu">5</span>))
ax.plot(spread.index, spread.values, color=<span class="st">"navy"</span>, linewidth=<span class="nu">1</span>)
ax.axhline(y=<span class="nu">0</span>, color=<span class="st">"red"</span>, linestyle=<span class="st">"--"</span>, linewidth=<span class="nu">1.5</span>, label=<span class="st">"역전선 (0%)"</span>)
ax.fill_between(spread.index, spread.values, <span class="nu">0</span>,
                where=(spread.values < <span class="nu">0</span>), color=<span class="st">"red"</span>, alpha=<span class="nu">0.3</span>, label=<span class="st">"역전 구간"</span>)
ax.set_title(<span class="st">"10Y-2Y Treasury Spread (Yield Curve)"</span>, fontsize=<span class="nu">14</span>)
ax.set_ylabel(<span class="st">"Spread (%)"</span>)
ax.legend()
ax.grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)
plt.tight_layout()
plt.show()</code></pre>

<p>이 장단기 금리차는 나중에 ML 모델의 강력한 피처가 된다. "금리 역전이 발생한 후 주식 시장이 어떻게 반응하는가"를 모델이 학습할 수 있기 때문이다.</p>

<h3>3.4 빈도가 다른 데이터 합치기 — 리샘플링</h3>
<p>거시경제 데이터의 가장 큰 문제는 빈도(frequency)가 다르다는 것이다. 주가는 일간(daily), 금리도 일간이지만, CPI는 월간(monthly), GDP는 분기(quarterly)다. 이것들을 하나의 테이블로 합치려면 리샘플링(resampling)이 필요하다.</p>

<pre><code><span class="cm"># 문제: 주가는 일간, CPI는 월간 → 어떻게 합칠까?</span>

<span class="cm"># 방법 1: 월간 데이터를 일간으로 확장 (forward fill)</span>
<span class="cm"># "이번 달 CPI가 발표될 때까지 지난 달 값을 사용한다"</span>
cpi_daily = cpi.resample(<span class="st">"D"</span>).ffill()  <span class="cm"># 일간으로 확장</span>
<span class="fn">print</span>(<span class="st">"월간 → 일간 (ffill):"</span>)
<span class="fn">print</span>(cpi_daily.head(<span class="nu">10</span>))

<span class="cm"># 방법 2: 일간 데이터를 월간으로 축소</span>
<span class="cm"># 주가의 월말 종가만 사용</span>
monthly_close = data.resample(<span class="st">"M"</span>).last()  <span class="cm"># 월말 값</span>
monthly_return = data.resample(<span class="st">"M"</span>).last().pct_change()  <span class="cm"># 월간 수익률</span>
<span class="fn">print</span>(<span class="st">"\n일간 → 월간 (월말 종가):"</span>)
<span class="fn">print</span>(monthly_close.head())

<span class="cm"># 방법 3: merge_asof — 가장 가까운 날짜로 매칭</span>
<span class="cm"># 거래일이 아닌 날(주말, 공휴일)의 데이터를 처리할 때 유용</span>
stock_daily = data[[<span class="st">"삼성전자"</span>]].reset_index()
macro_daily = us10y.reset_index()

merged = pd.merge_asof(
    stock_daily.sort_values(<span class="st">"Date"</span>),
    macro_daily.sort_values(<span class="st">"DATE"</span>),
    left_on=<span class="st">"Date"</span>,
    right_on=<span class="st">"DATE"</span>,
    direction=<span class="st">"backward"</span>  <span class="cm"># 과거 가장 가까운 값 사용</span>
)
<span class="fn">print</span>(<span class="st">"\nmerge_asof 결과:"</span>)
<span class="fn">print</span>(merged.head())</code></pre>

<div class="warn">
<p class="ni"><strong>Look-Ahead Bias 주의!</strong> 거시경제 데이터를 합칠 때 가장 위험한 실수는 미래 정보를 사용하는 것이다. 예를 들어 1월의 CPI는 2월 중순에 발표된다. 따라서 1월의 주가 예측에 1월 CPI를 사용하면 안 된다 — 그 시점에는 아직 발표되지 않았으니까. <code>ffill()</code>(forward fill)을 사용하면 "가장 최근에 발표된 값"을 사용하게 되어 이 문제를 자연스럽게 해결한다.</p>
</div>

<!-- ── 보충 3.4+ FRED 데이터 주기 불일치 문제 ── -->
<div class="def">
<p class="ni"><strong>🔍 보충: FRED 데이터 주기 불일치 — "왜 이게 문제인가" 완전 정복</strong></p>
<p class="ni">FRED에서 데이터를 가져오면 주기(frequency)가 제각각이다. 이것을 무시하고 그냥 합치면 NaN 폭탄이 터진다. 구체적으로 어떤 일이 벌어지는지 보자:</p>
</div>

<pre><code><span class="cm"># === FRED 데이터 주기 불일치 문제 시뮬레이션 ===</span>
<span class="kw">import</span> pandas <span class="kw">as</span> pd
<span class="kw">import</span> numpy <span class="kw">as</span> np

<span class="cm"># 1. 세 가지 주기의 데이터 생성 (실제 FRED 상황 재현)</span>
dates_daily = pd.date_range(<span class="st">"2024-01-01"</span>, <span class="st">"2024-03-31"</span>, freq=<span class="st">"B"</span>)  <span class="cm"># 영업일 (약 63일)</span>
dates_monthly = pd.date_range(<span class="st">"2024-01-01"</span>, <span class="st">"2024-03-31"</span>, freq=<span class="st">"MS"</span>)  <span class="cm"># 월초 (3개)</span>
dates_quarterly = pd.date_range(<span class="st">"2024-01-01"</span>, <span class="st">"2024-03-31"</span>, freq=<span class="st">"QS"</span>)  <span class="cm"># 분기초 (1개)</span>

stock_price = pd.Series(np.random.normal(<span class="nu">70000</span>, <span class="nu">2000</span>, <span class="fn">len</span>(dates_daily)),
                        index=dates_daily, name=<span class="st">"주가"</span>)
cpi_monthly = pd.Series([<span class="nu">310.1</span>, <span class="nu">311.0</span>, <span class="nu">311.8</span>],
                        index=dates_monthly, name=<span class="st">"CPI"</span>)
gdp_quarterly = pd.Series([<span class="nu">27.9</span>],
                          index=dates_quarterly, name=<span class="st">"GDP(조달러)"</span>)

<span class="fn">print</span>(<span class="st">"주가: "</span>, <span class="fn">len</span>(stock_price), <span class="st">"행 (일간)"</span>)
<span class="fn">print</span>(<span class="st">"CPI: "</span>, <span class="fn">len</span>(cpi_monthly), <span class="st">"행 (월간)"</span>)
<span class="fn">print</span>(<span class="st">"GDP: "</span>, <span class="fn">len</span>(gdp_quarterly), <span class="st">"행 (분기)"</span>)

<span class="cm"># 2. 잘못된 방법: 그냥 concat → NaN 폭탄!</span>
wrong = pd.concat([stock_price, cpi_monthly, gdp_quarterly], axis=<span class="nu">1</span>)
<span class="fn">print</span>(<span class="st">"\n=== 잘못된 합치기 (NaN 폭탄) ==="</span>)
<span class="fn">print</span>(wrong.head(<span class="nu">10</span>))
<span class="fn">print</span>(<span class="st">f"NaN 비율: CPI </span>{wrong[<span class="st">'CPI'</span>].isna().mean():.0%}<span class="st">, GDP </span>{wrong[<span class="st">'GDP(조달러)'</span>].isna().mean():.0%}<span class="st">"</span>)
<span class="cm"># CPI: 95% NaN, GDP: 98% NaN → 사실상 사용 불가!</span></code></pre>

<pre><code><span class="cm"># 3. 올바른 방법: reindex + ffill</span>
<span class="cm"># "월간/분기 데이터를 일간 인덱스에 맞추고, 발표 전까지 이전 값 유지"</span>

<span class="cm"># Step 1: 일간 인덱스 기준으로 reindex</span>
cpi_aligned = cpi_monthly.reindex(dates_daily)
gdp_aligned = gdp_quarterly.reindex(dates_daily)

<span class="fn">print</span>(<span class="st">"=== reindex 직후 (대부분 NaN) ==="</span>)
<span class="fn">print</span>(cpi_aligned.head(<span class="nu">5</span>))
<span class="cm"># 2024-01-01    310.1  ← 발표일만 값이 있음</span>
<span class="cm"># 2024-01-02      NaN</span>
<span class="cm"># 2024-01-03      NaN</span>

<span class="cm"># Step 2: ffill로 빈 칸 채우기</span>
cpi_aligned = cpi_aligned.ffill()
gdp_aligned = gdp_aligned.ffill()

<span class="fn">print</span>(<span class="st">"\n=== ffill 후 (깔끔!) ==="</span>)
<span class="fn">print</span>(cpi_aligned.head(<span class="nu">5</span>))
<span class="cm"># 2024-01-01    310.1</span>
<span class="cm"># 2024-01-02    310.1  ← 새 발표 전까지 이전 값 유지</span>
<span class="cm"># 2024-01-03    310.1</span>

<span class="cm"># Step 3: 깔끔하게 합치기</span>
correct = pd.DataFrame({
    <span class="st">"주가"</span>: stock_price,
    <span class="st">"CPI"</span>: cpi_aligned,
    <span class="st">"GDP"</span>: gdp_aligned
})
<span class="fn">print</span>(<span class="st">"\n=== 올바른 합치기 ==="</span>)
<span class="fn">print</span>(correct.head(<span class="nu">10</span>))
<span class="fn">print</span>(<span class="st">f"NaN 비율: CPI </span>{correct[<span class="st">'CPI'</span>].isna().mean():.0%}<span class="st">, GDP </span>{correct[<span class="st">'GDP'</span>].isna().mean():.0%}<span class="st">"</span>)
<span class="cm"># CPI: 0%, GDP: 0% → 완벽!</span></code></pre>

<pre><code><span class="cm"># 4. 실전 패턴: resample로 주기 변환</span>

<span class="cm"># 일간 → 월간 (축소): 다양한 집계 방법</span>
monthly_last = stock_price.resample(<span class="st">"M"</span>).last()    <span class="cm"># 월말 종가</span>
monthly_mean = stock_price.resample(<span class="st">"M"</span>).mean()    <span class="cm"># 월 평균가</span>
monthly_max = stock_price.resample(<span class="st">"M"</span>).max()      <span class="cm"># 월 최고가</span>
monthly_vol = stock_price.pct_change().resample(<span class="st">"M"</span>).std()  <span class="cm"># 월간 변동성</span>

<span class="fn">print</span>(<span class="st">"=== 일간 → 월간 변환 ==="</span>)
summary = pd.DataFrame({
    <span class="st">"월말종가"</span>: monthly_last,
    <span class="st">"월평균"</span>: monthly_mean,
    <span class="st">"월최고"</span>: monthly_max,
    <span class="st">"월변동성"</span>: monthly_vol
})
<span class="fn">print</span>(summary.round(<span class="nu">0</span>))

<span class="cm"># 월간 → 일간 (확장): ffill이 핵심</span>
<span class="cm"># "이번 달 CPI가 나올 때까지 지난 달 값을 쓴다"</span>
cpi_expanded = cpi_monthly.resample(<span class="st">"D"</span>).ffill()
<span class="fn">print</span>(<span class="st">f"\n월간 CPI → 일간 확장: </span>{<span class="fn">len</span>(cpi_expanded)}<span class="st">행"</span>)</code></pre>

<div class="warn">
<p class="ni"><strong>핵심 규칙 3가지:</strong></p>
<ul>
<li><strong>축소(일간→월간):</strong> <code>resample("M").last()</code> 또는 <code>.mean()</code> — 정보를 요약한다</li>
<li><strong>확장(월간→일간):</strong> <code>reindex(daily_index).ffill()</code> — 빈 칸을 이전 값으로 채운다</li>
<li><strong>Look-Ahead Bias 방지:</strong> 반드시 <code>ffill()</code>을 사용. <code>bfill()</code>(미래 값으로 채움)이나 <code>interpolate()</code>(앞뒤 값 평균)는 미래 정보를 사용하므로 금지!</li>
</ul>
</div>

<!-- ═══════════════════════════════════════════ -->
<!-- Ch4: 데이터 정제의 기술 -->
<!-- ═══════════════════════════════════════════ -->
<h2 id="ch4">4. 데이터 정제의 기술 — 더러운 데이터를 깨끗하게</h2>

<!-- 데이터 정제 의사결정 플로우차트 (CSS) -->
<div style="margin:25px 0;padding:25px;background:linear-gradient(135deg,#f8f9fa,#fdf5e6);border-radius:10px;border:1px solid #ccc">
<p class="ni" style="text-align:center;font-weight:bold;font-size:15px;margin-bottom:18px;color:#2c3e50">🧹 데이터 정제 의사결정 트리</p>
<div style="display:flex;flex-direction:column;gap:10px;font-size:12px;max-width:700px;margin:0 auto">
<div style="text-align:center">
<div style="display:inline-block;background:#2c3e50;color:#fff;padding:10px 20px;border-radius:8px;font-weight:bold">원시 데이터 (Raw Data)</div>
</div>
<div style="text-align:center;color:#888">↓</div>
<div style="display:flex;gap:8px;justify-content:center;flex-wrap:wrap">
<div style="flex:1;min-width:200px;background:#fff;border:2px solid #e74c3c;border-radius:8px;padding:12px;text-align:center">
<div style="font-weight:bold;color:#e74c3c;margin-bottom:6px">① 타입 확인</div>
<div style="color:#555;font-size:11px">날짜가 문자열? 숫자에 쉼표?</div>
<div style="margin-top:6px;background:#fde8e8;padding:4px 8px;border-radius:4px;font-size:11px"><code>pd.to_datetime()</code>, <code>pd.to_numeric()</code></div>
</div>
<div style="flex:1;min-width:200px;background:#fff;border:2px solid #e67e22;border-radius:8px;padding:12px;text-align:center">
<div style="font-weight:bold;color:#e67e22;margin-bottom:6px">② 결측치 처리</div>
<div style="color:#555;font-size:11px">비율 < 1%? → 삭제<br>시계열? → ffill<br>수익률? → 0 대체</div>
<div style="margin-top:6px;background:#fff9e6;padding:4px 8px;border-radius:4px;font-size:11px"><code>ffill()</code>, <code>interpolate()</code></div>
</div>
<div style="flex:1;min-width:200px;background:#fff;border:2px solid #3498db;border-radius:8px;padding:12px;text-align:center">
<div style="font-weight:bold;color:#3498db;margin-bottom:6px">③ 이상치 처리</div>
<div style="color:#555;font-size:11px">데이터 오류? → 제거<br>극단값? → Winsorize<br>실제 사건? → 보존</div>
<div style="margin-top:6px;background:#e8f4f8;padding:4px 8px;border-radius:4px;font-size:11px"><code>clip()</code>, <code>winsorize()</code></div>
</div>
</div>
<div style="text-align:center;color:#888">↓</div>
<div style="text-align:center">
<div style="display:inline-block;background:#27ae60;color:#fff;padding:10px 20px;border-radius:8px;font-weight:bold">깨끗한 데이터 (Clean Data) → 스케일링 → 피처 생성</div>
</div>
</div>
</div>

<h3>4.1 왜 데이터 정제가 필요한가</h3>
<p>현실의 금융 데이터는 깨끗하지 않다. 거래소 시스템 오류로 가격이 0원으로 찍히기도 하고, 공휴일에는 데이터가 비어 있고, 상장폐지된 종목은 중간에 데이터가 끊기고, 배당락일에는 주가가 갑자기 떨어진다. 이런 "더러운" 데이터를 그대로 ML 모델에 넣으면 모델이 엉뚱한 패턴을 학습한다.</p>

<p>데이터 정제는 크게 세 단계로 나뉜다:</p>
<ol>
<li><strong>결측치 처리 (Missing Values)</strong> — 비어 있는 칸을 어떻게 할 것인가?</li>
<li><strong>이상치 처리 (Outliers)</strong> — 비정상적으로 크거나 작은 값을 어떻게 할 것인가?</li>
<li><strong>데이터 타입 정리</strong> — 날짜가 문자열로 되어 있거나, 숫자에 쉼표가 섞여 있는 경우</li>
</ol>

<h3>4.2 데이터 탐색 — 먼저 현황을 파악하자</h3>
<p>정제하기 전에 먼저 데이터의 현재 상태를 파악해야 한다. Pandas의 탐색 함수들을 총동원하자.</p>

<pre><code><span class="cm"># 5종목 2년 데이터 (앞에서 다운로드한 것)</span>
<span class="fn">print</span>(<span class="st">"=== 기본 정보 ==="</span>)
<span class="fn">print</span>(<span class="st">f"Shape: </span>{data.shape}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"기간: </span>{data.index[0].date()}<span class="st"> ~ </span>{data.index[-1].date()}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"데이터 타입:\n</span>{data.dtypes}<span class="st">"</span>)

<span class="fn">print</span>(<span class="st">"\n=== 결측치 현황 ==="</span>)
<span class="fn">print</span>(data.isnull().sum())
<span class="fn">print</span>(<span class="st">f"\n결측치 비율:\n</span>{(data.isnull().sum() / <span class="fn">len</span>(data) * <span class="nu">100</span>).round(<span class="nu">2</span>)}<span class="st">%"</span>)

<span class="fn">print</span>(<span class="st">"\n=== 기술통계 ==="</span>)
<span class="fn">print</span>(data.describe().round(<span class="nu">2</span>))

<span class="fn">print</span>(<span class="st">"\n=== 처음 5행 ==="</span>)
<span class="fn">print</span>(data.head())

<span class="fn">print</span>(<span class="st">"\n=== 마지막 5행 ==="</span>)
<span class="fn">print</span>(data.tail())</code></pre>
<div class="code-output"><span class="out-label">Output:</span>
=== 결측치 현황 ===
Open         0
High         0
Low          0
Close        0
Adj Close    0
Volume       0
dtype: int64

→ yfinance 데이터는 결측치가 거의 없다.
→ 실전에서는 거래 정지일, 데이터 소스 오류 등으로 결측이 발생한다.</div>


<p><code>describe()</code>는 매우 강력한 함수다. 평균, 표준편차, 최솟값, 최댓값, 사분위수를 한눈에 보여준다. 여기서 이상한 값이 보이면 (예: 최솟값이 0이거나, 최댓값이 비정상적으로 크면) 이상치가 있다는 신호다.</p>

<div class="info">
<p class="ni"><strong>교재 연동:</strong> 파라활 Ch.5 "Getting Started with pandas"에서 DataFrame의 기본 탐색 방법을, Ch.7 "Data Cleaning and Preparation"에서 결측치·이상치 처리의 상세한 기법을 다룬다. MLAT Ch.2에서는 금융 데이터 특유의 정제 이슈(수정종가, 생존자 편향 등)를 다룬다.</p>
</div>

<h3>4.3 데이터 타입 문제 해결</h3>
<p>CSV 파일에서 데이터를 불러오면 종종 데이터 타입이 잘못되어 있다. 날짜가 문자열이거나, 숫자에 쉼표가 섞여 있거나, 빈 칸이 "N/A" 문자열로 되어 있는 경우가 흔하다.</p>

<pre><code><span class="cm"># 흔한 데이터 타입 문제와 해결법</span>

<span class="cm"># 문제 1: 날짜가 문자열</span>
df_raw = pd.DataFrame({
    <span class="st">"date"</span>: [<span class="st">"2024-01-02"</span>, <span class="st">"2024-01-03"</span>, <span class="st">"2024-01-04"</span>],
    <span class="st">"price"</span>: [<span class="st">"75,300"</span>, <span class="st">"74,800"</span>, <span class="st">"76,100"</span>],  <span class="cm"># 쉼표가 있는 문자열!</span>
    <span class="st">"volume"</span>: [<span class="st">"12345678"</span>, <span class="st">"N/A"</span>, <span class="st">"9876543"</span>]  <span class="cm"># N/A 문자열!</span>
})

<span class="cm"># 해결: 날짜 변환</span>
df_raw[<span class="st">"date"</span>] = pd.to_datetime(df_raw[<span class="st">"date"</span>])

<span class="cm"># 해결: 쉼표 제거 후 숫자 변환</span>
df_raw[<span class="st">"price"</span>] = df_raw[<span class="st">"price"</span>].str.replace(<span class="st">","</span>, <span class="st">""</span>).astype(<span class="nb">float</span>)

<span class="cm"># 해결: N/A를 NaN으로 변환</span>
df_raw[<span class="st">"volume"</span>] = pd.to_numeric(df_raw[<span class="st">"volume"</span>], errors=<span class="st">"coerce"</span>)
<span class="cm"># errors="coerce" → 변환 불가능한 값을 NaN으로</span>

<span class="fn">print</span>(df_raw)
<span class="fn">print</span>(<span class="st">f"\n데이터 타입:\n</span>{df_raw.dtypes}<span class="st">"</span>)</code></pre>

<p><code>pd.to_numeric(errors="coerce")</code>는 매우 유용한 함수다. 숫자로 변환할 수 없는 값을 자동으로 NaN(결측치)으로 바꿔준다. "N/A", "없음", "-" 같은 다양한 형태의 결측 표현을 한 번에 처리할 수 있다.</p>

<!-- ═══════════════════════════════════════════ -->
<!-- Ch5: 결측치 처리 -->
<!-- ═══════════════════════════════════════════ -->
<h2 id="ch5">5. 결측치 처리 — 빈 칸을 어떻게 할 것인가</h2>

<!-- 결측치 처리 방법 비교 다이어그램 (CSS) -->
<div style="margin:25px 0;padding:20px;background:#f8f9fa;border-radius:8px;border:1px solid #ddd">
<p class="ni" style="text-align:center;font-weight:bold;font-size:14px;margin-bottom:15px;color:#2c3e50">🔧 결측치 처리 — 상황별 최적 방법</p>
<div style="display:flex;gap:8px;flex-wrap:wrap;font-size:12px;justify-content:center">
<div style="flex:1;min-width:150px;background:#fff;padding:12px;border-radius:6px;border-left:4px solid #e74c3c;text-align:center">
<div style="font-weight:bold;color:#e74c3c;margin-bottom:4px">가격 데이터</div>
<div style="font-size:20px;margin:6px 0">📈</div>
<div style="background:#fde8e8;padding:4px;border-radius:3px;font-family:monospace;font-size:11px">ffill(limit=5)</div>
<div style="color:#888;font-size:10px;margin-top:4px">"마지막 알려진 가격 사용"</div>
</div>
<div style="flex:1;min-width:150px;background:#fff;padding:12px;border-radius:6px;border-left:4px solid #3498db;text-align:center">
<div style="font-weight:bold;color:#3498db;margin-bottom:4px">수익률 데이터</div>
<div style="font-size:20px;margin:6px 0">📊</div>
<div style="background:#e8f4f8;padding:4px;border-radius:3px;font-family:monospace;font-size:11px">fillna(0)</div>
<div style="color:#888;font-size:10px;margin-top:4px">"거래 없음 = 수익률 0"</div>
</div>
<div style="flex:1;min-width:150px;background:#fff;padding:12px;border-radius:6px;border-left:4px solid #e67e22;text-align:center">
<div style="font-weight:bold;color:#e67e22;margin-bottom:4px">거시경제 데이터</div>
<div style="font-size:20px;margin:6px 0">🏛️</div>
<div style="background:#fff9e6;padding:4px;border-radius:3px;font-family:monospace;font-size:11px">ffill()</div>
<div style="color:#888;font-size:10px;margin-top:4px">"발표 전까지 이전 값"</div>
</div>
<div style="flex:1;min-width:150px;background:#fff;padding:12px;border-radius:6px;border-left:4px solid #27ae60;text-align:center">
<div style="font-weight:bold;color:#27ae60;margin-bottom:4px">결측 > 30%</div>
<div style="font-size:20px;margin:6px 0">🗑️</div>
<div style="background:#e8f8e8;padding:4px;border-radius:3px;font-family:monospace;font-size:11px">drop column</div>
<div style="color:#888;font-size:10px;margin-top:4px">"해당 종목/컬럼 제외"</div>
</div>
</div>
</div>

<h3>5.1 금융 데이터에서 결측치가 생기는 이유</h3>
<p>금융 데이터에서 결측치(missing value, NaN)는 피할 수 없다. 주요 원인을 알아야 적절한 처리 방법을 선택할 수 있다.</p>

<ul>
<li><strong>거래일 불일치:</strong> 한국 시장은 쉬는데 미국 시장은 열리는 날 (또는 그 반대). 여러 나라 데이터를 합치면 빈 칸이 생긴다.</li>
<li><strong>신규 상장:</strong> 2022년에 상장한 종목은 2020년 데이터가 없다.</li>
<li><strong>거래 정지:</strong> 공시 지연, 감사의견 거절 등으로 거래가 정지되면 그 기간의 데이터가 없다.</li>
<li><strong>데이터 소스 오류:</strong> API 서버 장애, 네트워크 문제 등으로 일부 데이터가 누락된다.</li>
<li><strong>수익률 계산:</strong> <code>pct_change()</code>나 <code>shift()</code>를 사용하면 첫 번째 행이 NaN이 된다.</li>
</ul>

<h3>5.2 결측치 탐지</h3>
<pre><code><span class="cm"># 결측치가 있는 예제 데이터 만들기</span>
np.random.seed(<span class="nu">42</span>)
dates = pd.date_range(<span class="st">"2024-01-01"</span>, periods=<span class="nu">20</span>, freq=<span class="st">"B"</span>)  <span class="cm"># B = 영업일</span>
sample = pd.DataFrame({
    <span class="st">"A"</span>: np.random.normal(<span class="nu">100</span>, <span class="nu">5</span>, <span class="nu">20</span>),
    <span class="st">"B"</span>: np.random.normal(<span class="nu">50</span>, <span class="nu">3</span>, <span class="nu">20</span>),
    <span class="st">"C"</span>: np.random.normal(<span class="nu">200</span>, <span class="nu">10</span>, <span class="nu">20</span>)
}, index=dates)

<span class="cm"># 인위적으로 결측치 삽입</span>
sample.loc[sample.index[<span class="nu">3</span>], <span class="st">"A"</span>] = np.nan
sample.loc[sample.index[<span class="nu">7</span>:<span class="nu">10</span>], <span class="st">"B"</span>] = np.nan  <span class="cm"># 연속 3일 결측</span>
sample.loc[sample.index[<span class="nu">15</span>], <span class="st">"C"</span>] = np.nan

<span class="cm"># 결측치 탐지</span>
<span class="fn">print</span>(<span class="st">"=== 결측치 개수 ==="</span>)
<span class="fn">print</span>(sample.isnull().sum())

<span class="fn">print</span>(<span class="st">"\n=== 결측치 위치 ==="</span>)
<span class="fn">print</span>(sample.isnull())

<span class="fn">print</span>(<span class="st">"\n=== 결측치가 있는 행만 ==="</span>)
<span class="fn">print</span>(sample[sample.isnull().any(axis=<span class="nu">1</span>)])

<span class="cm"># 시각화: 결측치 패턴</span>
fig, ax = plt.subplots(figsize=(<span class="nu">10</span>, <span class="nu">4</span>))
ax.imshow(sample.isnull().T, cmap=<span class="st">"YlOrRd"</span>, aspect=<span class="st">"auto"</span>)
ax.set_yticks(<span class="fn">range</span>(<span class="fn">len</span>(sample.columns)))
ax.set_yticklabels(sample.columns)
ax.set_xlabel(<span class="st">"날짜 인덱스"</span>)
ax.set_title(<span class="st">"결측치 패턴 (빨간색 = 결측)"</span>)
plt.tight_layout()
plt.show()</code></pre>

<h3>5.3 결측치 처리 방법 — 상황별 가이드</h3>
<p>결측치 처리에는 "정답"이 없다. 상황에 따라 최선의 방법이 다르다. 금융 데이터에서 자주 사용하는 방법들을 하나씩 살펴보자.</p>

<h4>방법 1: 삭제 (dropna)</h4>
<p>가장 단순한 방법이다. 결측치가 있는 행을 통째로 삭제한다. 결측치가 매우 적을 때(전체의 1~2% 미만) 적합하다.</p>

<pre><code><span class="cm"># 결측치가 있는 행 삭제</span>
clean1 = sample.dropna()
<span class="fn">print</span>(<span class="st">f"원본: </span>{<span class="fn">len</span>(sample)}<span class="st">행 → 삭제 후: </span>{<span class="fn">len</span>(clean1)}<span class="st">행"</span>)

<span class="cm"># 특정 컬럼 기준으로만 삭제</span>
clean1b = sample.dropna(subset=[<span class="st">"A"</span>])  <span class="cm"># A 컬럼에 결측이 있는 행만 삭제</span>

<span class="cm"># 모든 컬럼이 결측인 행만 삭제</span>
clean1c = sample.dropna(how=<span class="st">"all"</span>)  <span class="cm"># 전부 NaN인 행만 삭제</span></code></pre>

<div class="warn">
<p class="ni"><strong>삭제의 위험:</strong> 금융 시계열에서 행을 삭제하면 시간의 연속성이 깨진다. 예를 들어 3일 연속 결측을 삭제하면, 월요일 다음에 갑자기 목요일이 오게 된다. 이동평균이나 모멘텀 같은 시계열 피처를 계산할 때 문제가 된다.</p>
</div>

<h4>방법 2: 전방 채움 (Forward Fill)</h4>
<p>바로 이전 값으로 채우는 방법이다. 금융 데이터에서 가장 많이 사용되는 방법이다. "새로운 정보가 없으면 마지막으로 알려진 값을 사용한다"는 직관적인 논리다.</p>

<pre><code><span class="cm"># Forward Fill: 이전 값으로 채움</span>
clean2 = sample.ffill()
<span class="fn">print</span>(<span class="st">"=== Forward Fill ==="</span>)
<span class="fn">print</span>(clean2.loc[sample.isnull().any(axis=<span class="nu">1</span>)])

<span class="cm"># 최대 채움 횟수 제한 (연속 결측이 너무 길면 위험)</span>
clean2b = sample.ffill(limit=<span class="nu">2</span>)  <span class="cm"># 최대 2일까지만 채움</span>
<span class="fn">print</span>(<span class="st">"\n=== Forward Fill (limit=2) ==="</span>)
<span class="fn">print</span>(clean2b.isnull().sum())  <span class="cm"># B에 1개 남음 (3일 연속 중 3번째)</span></code></pre>

<p>왜 <code>limit</code>을 설정해야 할까? 어떤 종목이 거래 정지로 30일간 데이터가 없다고 하자. Forward fill로 30일을 모두 채우면, 30일 동안 가격이 변하지 않은 것처럼 보인다. 이것은 현실과 다르다 — 거래 재개 시 가격이 급변할 수 있다. <code>limit=5</code> 정도로 설정하고, 그 이상 연속 결측은 해당 종목을 분석에서 제외하는 것이 안전하다.</p>

<h4>방법 3: 보간 (Interpolation)</h4>
<p>앞뒤 값을 이용해 중간값을 추정하는 방법이다. 선형 보간이 가장 기본이고, 시계열에는 시간 기반 보간이 더 적합하다.</p>

<pre><code><span class="cm"># 선형 보간: 앞뒤 값의 직선으로 채움</span>
clean3 = sample.interpolate(method=<span class="st">"linear"</span>)
<span class="fn">print</span>(<span class="st">"=== 선형 보간 ==="</span>)
<span class="fn">print</span>(clean3.loc[sample.isnull().any(axis=<span class="nu">1</span>)])

<span class="cm"># 시간 기반 보간 (날짜 간격 고려)</span>
clean3b = sample.interpolate(method=<span class="st">"time"</span>)

<span class="cm"># 다항식 보간 (곡선으로 채움)</span>
clean3c = sample.interpolate(method=<span class="st">"polynomial"</span>, order=<span class="nu">2</span>)

<span class="cm"># 비교 시각화</span>
fig, axes = plt.subplots(<span class="nu">1</span>, <span class="nu">3</span>, figsize=(<span class="nu">15</span>, <span class="nu">4</span>))
methods = {<span class="st">"Forward Fill"</span>: sample.ffill(),
           <span class="st">"Linear Interp"</span>: sample.interpolate(method=<span class="st">"linear"</span>),
           <span class="st">"Polynomial(2)"</span>: sample.interpolate(method=<span class="st">"polynomial"</span>, order=<span class="nu">2</span>)}

<span class="kw">for</span> ax, (name, filled) <span class="kw">in</span> <span class="fn">zip</span>(axes, methods.items()):
    ax.plot(sample.index, sample[<span class="st">"B"</span>], <span class="st">"o"</span>, color=<span class="st">"blue"</span>, label=<span class="st">"원본"</span>)
    ax.plot(filled.index, filled[<span class="st">"B"</span>], <span class="st">"--"</span>, color=<span class="st">"red"</span>, alpha=<span class="nu">0.7</span>, label=<span class="st">"채움"</span>)
    <span class="cm"># 결측 위치 강조</span>
    mask = sample[<span class="st">"B"</span>].isnull()
    ax.plot(filled.index[mask], filled[<span class="st">"B"</span>][mask], <span class="st">"s"</span>, color=<span class="st">"red"</span>, markersize=<span class="nu">8</span>)
    ax.set_title(name)
    ax.legend(fontsize=<span class="nu">8</span>)
    ax.grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)
    ax.tick_params(axis=<span class="st">"x"</span>, rotation=<span class="nu">45</span>)

plt.tight_layout()
plt.show()</code></pre>

<h4>방법 4: 평균/중앙값 대체</h4>
<p>해당 컬럼의 평균이나 중앙값으로 채우는 방법이다. 횡단면(cross-sectional) 데이터에는 적합하지만, 시계열 데이터에는 부적합하다. 왜? 시계열에는 추세(trend)가 있기 때문이다. 상승 추세에서 평균으로 채우면 실제보다 낮은 값이 들어간다.</p>

<pre><code><span class="cm"># 평균 대체 (시계열에는 비추천)</span>
clean4 = sample.fillna(sample.mean())

<span class="cm"># 중앙값 대체 (이상치에 덜 민감)</span>
clean4b = sample.fillna(sample.median())

<span class="cm"># 특정 값으로 대체</span>
clean4c = sample.fillna(<span class="nu">0</span>)  <span class="cm"># 0으로 채움 (수익률 데이터에 적합할 수 있음)</span></code></pre>

<div class="tc">Table 4. 결측치 처리 방법 비교</div>
<table>
<tr><th>방법</th><th>코드</th><th>장점</th><th>단점</th><th>금융 적합도</th></tr>
<tr><td>삭제</td><td><code>dropna()</code></td><td>단순, 편향 없음</td><td>데이터 손실, 시간 불연속</td><td>결측 &lt; 1%일 때</td></tr>
<tr><td>전방 채움</td><td><code>ffill()</code></td><td>시간 연속성 유지</td><td>장기 결측 시 부정확</td><td>⭐ 가장 많이 사용</td></tr>
<tr><td>선형 보간</td><td><code>interpolate()</code></td><td>부드러운 추정</td><td>미래 정보 사용 위험</td><td>가격 데이터에 적합</td></tr>
<tr><td>평균 대체</td><td><code>fillna(mean())</code></td><td>단순</td><td>추세 무시, 분산 축소</td><td>횡단면에만 적합</td></tr>
<tr><td>0 대체</td><td><code>fillna(0)</code></td><td>단순</td><td>의미 왜곡 가능</td><td>수익률 데이터에 한정</td></tr>
</table>

<!-- ── 보충 5.3+ ffill vs interpolate vs fillna(0) 실제 숫자 비교 ── -->
<div class="def">
<p class="ni"><strong>🔍 보충: ffill vs interpolate vs fillna(0) — 실제 숫자로 차이를 보자</strong></p>
<p class="ni">위 표만 보면 "그래서 뭐가 다른데?"라는 의문이 남는다. 같은 결측 데이터에 세 가지 방법을 적용하면 숫자가 어떻게 달라지는지 직접 확인하자. 이 차이가 수익률 계산과 ML 모델 학습에 어떤 영향을 미치는지가 핵심이다.</p>
</div>

<pre><code><span class="cm"># === ffill vs interpolate vs fillna(0) 실전 비교 ===</span>
<span class="kw">import</span> pandas <span class="kw">as</span> pd
<span class="kw">import</span> numpy <span class="kw">as</span> np

<span class="cm"># 실제 주가처럼 생긴 데이터 (상승 추세 중 3일 결측)</span>
dates = pd.date_range(<span class="st">"2024-01-08"</span>, periods=<span class="nu">10</span>, freq=<span class="st">"B"</span>)
prices = pd.Series(
    [<span class="nu">70000</span>, <span class="nu">71200</span>, <span class="nu">72500</span>, np.nan, np.nan, np.nan, <span class="nu">78000</span>, <span class="nu">77500</span>, <span class="nu">78800</span>, <span class="nu">79200</span>],
    index=dates, name=<span class="st">"삼성전자"</span>
)
<span class="cm"># 결측 구간: 72,500 → ??? → ??? → ??? → 78,000</span>
<span class="cm"># 실제로는 상승 중이었다 (72,500 → 78,000)</span>

<span class="cm"># 세 가지 방법 적용</span>
method_ffill = prices.ffill()
method_interp = prices.interpolate(method=<span class="st">"linear"</span>)
method_zero = prices.fillna(<span class="nu">0</span>)

<span class="cm"># 비교 테이블</span>
comparison = pd.DataFrame({
    <span class="st">"원본"</span>: prices,
    <span class="st">"ffill"</span>: method_ffill,
    <span class="st">"interpolate"</span>: method_interp,
    <span class="st">"fillna(0)"</span>: method_zero
})
<span class="fn">print</span>(<span class="st">"=== 결측치 처리 방법별 결과 ==="</span>)
<span class="fn">print</span>(comparison.to_string())
<span class="cm">#              원본    ffill  interpolate  fillna(0)</span>
<span class="cm"># 01-08    70000   70000      70000       70000</span>
<span class="cm"># 01-09    71200   71200      71200       71200</span>
<span class="cm"># 01-10    72500   72500      72500       72500</span>
<span class="cm"># 01-11      NaN   72500      73875           0  ← 여기서 차이 발생!</span>
<span class="cm"># 01-12      NaN   72500      75250           0</span>
<span class="cm"># 01-15      NaN   72500      76625           0</span>
<span class="cm"># 01-16    78000   78000      78000       78000</span>
<span class="cm"># ...</span></code></pre>

<pre><code><span class="cm"># 수익률에 미치는 영향 비교</span>
<span class="fn">print</span>(<span class="st">"\n=== 일간 수익률 비교 (결측 구간 전후) ==="</span>)
<span class="kw">for</span> name, series <span class="kw">in</span> {<span class="st">"ffill"</span>: method_ffill, <span class="st">"interpolate"</span>: method_interp, <span class="st">"fillna(0)"</span>: method_zero}.items():
    ret = series.pct_change()
    <span class="fn">print</span>(<span class="st">f"\n{name}:"</span>)
    <span class="fn">print</span>(ret.iloc[<span class="nu">2</span>:<span class="nu">7</span>].round(<span class="nu">4</span>))

<span class="cm"># ffill 수익률:     0.0000, 0.0000, 0.0000, 0.0759  ← 3일간 0%, 마지막에 7.6% 점프</span>
<span class="cm"># interpolate 수익률: 0.0190, 0.0186, 0.0183, 0.0180  ← 매일 ~1.8% 균등 상승</span>
<span class="cm"># fillna(0) 수익률:  -1.0000, 0.0000, 0.0000, inf    ← 완전 엉망! -100% → inf</span>

<span class="fn">print</span>(<span class="st">"\n=== 결론 ==="</span>)
<span class="fn">print</span>(<span class="st">"ffill:       가격 동결 → 재개 시 점프. 보수적이지만 안전"</span>)
<span class="fn">print</span>(<span class="st">"interpolate: 부드러운 추정. 하지만 미래 값(78000)을 사용! → Look-Ahead Bias"</span>)
<span class="fn">print</span>(<span class="st">"fillna(0):   가격 데이터에 0을 넣으면 -100% 폭락으로 해석됨 → 절대 금지!"</span>)
<span class="fn">print</span>(<span class="st">"\n→ 가격 데이터: ffill이 가장 안전 (미래 정보 사용 안 함)"</span>)
<span class="fn">print</span>(<span class="st">"→ 수익률 데이터: fillna(0)이 적합 (거래 없음 = 수익률 0)"</span>)
<span class="fn">print</span>(<span class="st">"→ interpolate: 백테스트가 아닌 시각화/분석 용도로만 사용"</span>)</code></pre>

<div class="warn">
<p class="ni"><strong>핵심 포인트:</strong> <code>interpolate()</code>는 결측 뒤의 값(78,000)을 사용하여 중간값을 추정한다. 즉 "미래 정보"를 사용하는 것이다. 백테스트에서 이것을 쓰면 Look-Ahead Bias가 발생한다. 시각화나 탐색적 분석에서는 괜찮지만, ML 모델 학습용 데이터에는 <code>ffill()</code>을 쓰자.</p>
</div>

<div class="ok">
<p class="ni"><strong>실전 가이드라인:</strong></p>
<ul>
<li>가격 데이터 → <code>ffill(limit=5)</code> 또는 선형 보간</li>
<li>수익률 데이터 → <code>fillna(0)</code> (거래 없음 = 수익률 0)</li>
<li>거시경제 데이터 → <code>ffill()</code> (발표 전까지 이전 값 사용)</li>
<li>재무제표 데이터 → <code>ffill()</code> (분기 발표 전까지 이전 분기 값)</li>
<li>결측 비율 > 30% → 해당 종목/컬럼 제외 고려</li>
</ul>
</div>

<!-- ══ Plotly: 결측치 패턴 히트맵 + ffill vs 보간 비교 ══ -->
<div id="plot-ch5-missing" style="width:100%;height:380px;margin:25px 0"></div>
<p class="ni" style="font-size:12px;color:#888;text-align:center">🖱️ 결측치 패턴 히트맵 — 노란색=결측, 보라색=존재 · 마우스 오버로 상세 확인</p>
<div id="plot-ch5-fill" style="width:100%;height:400px;margin:25px 0"></div>
<p class="ni" style="font-size:12px;color:#888;text-align:center">🖱️ ffill vs 선형보간 비교 — 결측 구간에서 두 방법의 차이를 확인하세요</p>
<script>
(function(){
  function mulberry32(a){return function(){a|=0;a=a+0x6D2B79F5|0;var t=Math.imul(a^a>>>15,1|a);t=t+Math.imul(t^t>>>7,61|t)^t;return((t^t>>>14)>>>0)/4294967296}}
  var rng=mulberry32(777);

  // 히트맵: 5종목 × 60일 결측 패턴
  var cols=['삼성전자','SK하이닉스','NAVER','카카오','현대차'];
  var days=[];for(var i=1;i<=60;i++)days.push('Day '+i);
  var z=[];
  var missPct=[0.05,0.12,0.08,0.20,0.03]; // 결측 비율
  for(var c=0;c<5;c++){
    var row=[];
    for(var d=0;d<60;d++){
      // 연속 결측 패턴 시뮬레이션
      if(rng()<missPct[c]){row.push(0);if(rng()<0.6&&d+1<60){d++;days[d]=days[d]||'Day '+(d+1);row.push(0)}}
      else row.push(1);
    }
    while(row.length<60)row.push(1);
    z.push(row.slice(0,60));
  }
  Plotly.newPlot('plot-ch5-missing',[{
    z:z,x:days,y:cols,type:'heatmap',
    colorscale:[[0,'#f1c40f'],[1,'#8e44ad']],
    showscale:true,colorbar:{title:'존재',tickvals:[0,1],ticktext:['결측','존재']},
    hovertemplate:'%{y}<br>%{x}<br>%{z:.0f} (0=결측, 1=존재)<extra></extra>'
  }],{
    title:{text:'📊 다종목 결측치 패턴 히트맵 (60일)',font:{size:14}},
    xaxis:{title:'거래일',dtick:5},yaxis:{title:''},
    plot_bgcolor:'#fafafa',paper_bgcolor:'#fff',margin:{t:50,l:100,b:50}
  },{responsive:true});

  // ffill vs 선형보간 비교
  var N=60,price=[50000];
  for(var i=1;i<N;i++)price.push(price[i-1]*(1+(rng()-0.48)*0.03));
  // 결측 구간 만들기
  var missIdx=[10,11,12,13,14, 30,31,32, 45,46,47,48,49];
  var original=price.slice();
  var withMiss=price.slice();
  missIdx.forEach(function(i){withMiss[i]=null});

  // ffill
  var ffilled=withMiss.slice();
  for(var i=1;i<N;i++){if(ffilled[i]===null)ffilled[i]=ffilled[i-1]}

  // 선형보간
  var interp=withMiss.slice();
  var i=0;
  while(i<N){
    if(interp[i]===null){
      var start=i-1,end=i;
      while(end<N&&interp[end]===null)end++;
      if(end<N&&start>=0){
        for(var j=start+1;j<end;j++){
          interp[j]=interp[start]+(interp[end]-interp[start])*(j-start)/(end-start);
        }
      }
      i=end;
    }else i++;
  }

  var xd=[];for(var i=0;i<N;i++)xd.push('Day '+(i+1));
  Plotly.newPlot('plot-ch5-fill',[
    {x:xd,y:original,mode:'lines',name:'원본 (실제값)',line:{color:'#2c3e50',width:2}},
    {x:xd,y:ffilled,mode:'lines+markers',name:'ffill (전방채움)',line:{color:'#e74c3c',width:2,dash:'dot'},marker:{size:3}},
    {x:xd,y:interp,mode:'lines+markers',name:'선형보간',line:{color:'#3498db',width:2,dash:'dash'},marker:{size:3}},
    {x:missIdx.map(function(i){return xd[i]}),y:missIdx.map(function(i){return original[i]}),mode:'markers',name:'결측 위치 (실제값)',marker:{color:'#f39c12',size:10,symbol:'x',line:{width:2}}}
  ],{
    title:{text:'🔧 결측치 처리 비교: ffill vs 선형보간',font:{size:14}},
    xaxis:{title:'거래일',gridcolor:'#eee'},
    yaxis:{title:'주가 (원)',gridcolor:'#eee'},
    legend:{orientation:'h',y:-0.18},
    hovermode:'x unified',
    plot_bgcolor:'#fafafa',paper_bgcolor:'#fff',margin:{t:50,b:70}
  },{responsive:true});
})();
</script>

<!-- ═══════════════════════════════════════════ -->
<!-- Ch6: 이상치 탐지 -->
<!-- ═══════════════════════════════════════════ -->
<h2 id="ch6">6. 이상치 탐지와 처리 — 비정상적인 값 잡아내기</h2>

<!-- 이상치 판별 다이어그램 (CSS) -->
<div style="margin:25px 0;padding:20px;background:#f8f9fa;border-radius:8px;border:1px solid #ddd">
<p class="ni" style="text-align:center;font-weight:bold;font-size:14px;margin-bottom:15px;color:#2c3e50">⚠️ 이상치 판별: 제거 vs 보존</p>
<div style="display:flex;gap:15px;justify-content:center;flex-wrap:wrap;font-size:12px">
<div style="flex:1;min-width:220px;background:#fde8e8;padding:15px;border-radius:8px;border:2px solid #e74c3c">
<div style="font-weight:bold;color:#e74c3c;font-size:14px;margin-bottom:8px">🚫 제거해야 할 이상치</div>
<div style="color:#555">
<div style="margin-bottom:4px">• 가격이 0원으로 기록됨</div>
<div style="margin-bottom:4px">• 소수점 오류 (7만→70만)</div>
<div style="margin-bottom:4px">• 거래소 시스템 오류</div>
<div>• 데이터 전송 중 손상</div>
</div>
<div style="margin-top:8px;background:#fff;padding:6px;border-radius:4px;text-align:center;font-size:11px">원인: <strong>데이터 오류</strong></div>
</div>
<div style="flex:1;min-width:220px;background:#e8f8e8;padding:15px;border-radius:8px;border:2px solid #27ae60">
<div style="font-weight:bold;color:#27ae60;font-size:14px;margin-bottom:8px">✅ 보존해야 할 극단값</div>
<div style="color:#555">
<div style="margin-bottom:4px">• 코로나 폭락 (-12%/일)</div>
<div style="margin-bottom:4px">• 리먼 사태 (-20%/일)</div>
<div style="margin-bottom:4px">• 실적 서프라이즈 급등</div>
<div>• 금리 인상 충격</div>
</div>
<div style="margin-top:8px;background:#fff;padding:6px;border-radius:4px;text-align:center;font-size:11px">원인: <strong>실제 시장 사건</strong></div>
</div>
</div>
<div style="margin-top:12px;text-align:center;font-size:12px;color:#555;background:#fff;padding:8px;border-radius:6px">
💡 <strong>실전 해법:</strong> Winsorization (상하위 1~2.5% 깎기) — 오류는 제거하되, 극단값 정보는 일부 보존
</div>
</div>

<h3>6.1 금융에서 이상치란?</h3>
<p>이상치(outlier)는 다른 데이터와 현저히 다른 값이다. 금융에서 이상치는 두 가지 종류가 있다:</p>

<ul>
<li><strong>진짜 이상치 (True Outlier):</strong> 데이터 오류. 거래소 시스템 오류로 가격이 0원으로 찍히거나, 소수점 오류로 주가가 10배로 기록되는 경우. 이것은 반드시 제거해야 한다.</li>
<li><strong>극단적이지만 실제 값 (Extreme but Real):</strong> 2020년 3월 코로나 폭락 때 하루 -12% 하락, 2008년 리먼 사태 때 -20% 폭락. 이것은 실제로 일어난 일이다. 함부로 제거하면 모델이 위기 상황을 학습하지 못한다.</li>
</ul>

<p>이 구분이 매우 중요하다. 데이터 오류는 제거하되, 실제 극단값은 보존해야 한다. 이것이 금융 데이터 정제의 핵심 딜레마다.</p>

<h3>6.2 Z-Score 방법</h3>
<p>Z-score는 "이 값이 평균에서 표준편차 몇 개만큼 떨어져 있는가"를 측정한다. 일반적으로 |Z| > 3이면 이상치로 판단한다 (정규분포에서 99.7% 밖).</p>

<div class="eq">\[ Z_i = \frac{x_i - \mu}{\sigma} \]</div>

<pre><code><span class="cm"># Z-Score 이상치 탐지</span>
returns = log_returns[<span class="st">"삼성전자"</span>]

z_scores = (returns - returns.mean()) / returns.std()

<span class="cm"># |Z| > 3인 날 찾기</span>
outliers_z = returns[np.abs(z_scores) > <span class="nu">3</span>]
<span class="fn">print</span>(<span class="st">f"Z-Score 이상치: </span>{<span class="fn">len</span>(outliers_z)}<span class="st">개"</span>)
<span class="fn">print</span>(outliers_z)

<span class="cm"># 시각화</span>
fig, axes = plt.subplots(<span class="nu">2</span>, <span class="nu">1</span>, figsize=(<span class="nu">14</span>, <span class="nu">8</span>))

<span class="cm"># 상단: 수익률 시계열 + 이상치 표시</span>
axes[<span class="nu">0</span>].plot(returns.index, returns.values, color=<span class="st">"steelblue"</span>, linewidth=<span class="nu">0.8</span>)
axes[<span class="nu">0</span>].scatter(outliers_z.index, outliers_z.values, color=<span class="st">"red"</span>, s=<span class="nu">50</span>, zorder=<span class="nu">5</span>, label=<span class="st">"이상치 (|Z|>3)"</span>)
axes[<span class="nu">0</span>].set_title(<span class="st">"삼성전자 일간 수익률 + Z-Score 이상치"</span>)
axes[<span class="nu">0</span>].legend()
axes[<span class="nu">0</span>].grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)

<span class="cm"># 하단: Z-Score 분포</span>
axes[<span class="nu">1</span>].hist(z_scores, bins=<span class="nu">50</span>, color=<span class="st">"steelblue"</span>, alpha=<span class="nu">0.7</span>, edgecolor=<span class="st">"white"</span>)
axes[<span class="nu">1</span>].axvline(x=<span class="nu">3</span>, color=<span class="st">"red"</span>, linestyle=<span class="st">"--"</span>, label=<span class="st">"Z = ±3"</span>)
axes[<span class="nu">1</span>].axvline(x=-<span class="nu">3</span>, color=<span class="st">"red"</span>, linestyle=<span class="st">"--"</span>)
axes[<span class="nu">1</span>].set_title(<span class="st">"Z-Score 분포"</span>)
axes[<span class="nu">1</span>].legend()
axes[<span class="nu">1</span>].grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)

plt.tight_layout()
plt.show()</code></pre>

<div class="warn">
<p class="ni"><strong>Z-Score의 한계:</strong> Z-score는 데이터가 정규분포를 따른다고 가정한다. 하지만 금융 수익률은 "팻 테일(fat tail)"을 가진다 — 극단값이 정규분포보다 훨씬 자주 발생한다. Round 2에서 배운 내용이다. 따라서 Z-score만으로 이상치를 판단하면 실제 극단값을 너무 많이 이상치로 분류할 수 있다.</p>
</div>

<h3>6.3 IQR 방법</h3>
<p>IQR(Interquartile Range, 사분위 범위)은 분포의 가정 없이 이상치를 탐지하는 방법이다. 박스플롯(box plot)의 수염(whisker) 바깥에 있는 값을 이상치로 판단한다.</p>

<div class="eq">\[ \text{IQR} = Q_3 - Q_1 \]
\[ \text{이상치}: x < Q_1 - 1.5 \times \text{IQR} \quad \text{또는} \quad x > Q_3 + 1.5 \times \text{IQR} \]</div>

<pre><code><span class="cm"># IQR 이상치 탐지</span>
Q1 = returns.quantile(<span class="nu">0.25</span>)
Q3 = returns.quantile(<span class="nu">0.75</span>)
IQR = Q3 - Q1

lower = Q1 - <span class="nu">1.5</span> * IQR
upper = Q3 + <span class="nu">1.5</span> * IQR

outliers_iqr = returns[(returns < lower) | (returns > upper)]
<span class="fn">print</span>(<span class="st">f"IQR 이상치: </span>{<span class="fn">len</span>(outliers_iqr)}<span class="st">개"</span>)
<span class="fn">print</span>(<span class="st">f"범위: [{lower:.4f}, {upper:.4f}]"</span>)

<span class="cm"># 박스플롯으로 시각화</span>
fig, ax = plt.subplots(figsize=(<span class="nu">10</span>, <span class="nu">4</span>))
bp = ax.boxplot([log_returns[col].dropna() <span class="kw">for</span> col <span class="kw">in</span> log_returns.columns],
                labels=log_returns.columns, vert=<span class="kw">True</span>, patch_artist=<span class="kw">True</span>)
<span class="kw">for</span> patch <span class="kw">in</span> bp[<span class="st">"boxes"</span>]:
    patch.set_facecolor(<span class="st">"lightblue"</span>)
ax.set_title(<span class="st">"5종목 수익률 박스플롯 (빨간 점 = 이상치)"</span>)
ax.set_ylabel(<span class="st">"일간 로그수익률"</span>)
ax.grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)
plt.tight_layout()
plt.show()</code></pre>

<h3>6.4 Winsorization — 이상치를 "깎는" 방법</h3>
<p>이상치를 완전히 제거하는 대신, 일정 범위로 "깎아내는" 방법이 Winsorization이다. 예를 들어 상하위 1%를 깎으면, 상위 1%보다 큰 값은 상위 1% 값으로, 하위 1%보다 작은 값은 하위 1% 값으로 대체한다.</p>

<p>이 방법의 장점은 극단값의 영향을 줄이면서도 데이터를 삭제하지 않는다는 것이다. 금융 ML에서 매우 자주 사용된다.</p>

<pre><code><span class="kw">from</span> scipy.stats <span class="kw">import</span> mstats

<span class="cm"># Winsorization: 상하위 1% 깎기</span>
returns_win = pd.Series(
    mstats.winsorize(returns, limits=[<span class="nu">0.01</span>, <span class="nu">0.01</span>]),
    index=returns.index
)

<span class="cm"># 직접 구현 (scipy 없이)</span>
<span class="kw">def</span> <span class="fn">winsorize_series</span>(s, lower_pct=<span class="nu">0.01</span>, upper_pct=<span class="nu">0.99</span>):
    <span class="st">"""시리즈의 상하위를 깎는다"""</span>
    lower = s.quantile(lower_pct)
    upper = s.quantile(upper_pct)
    <span class="kw">return</span> s.clip(lower=lower, upper=upper)

returns_win2 = winsorize_series(returns)

<span class="cm"># 비교</span>
<span class="fn">print</span>(<span class="st">"=== 원본 vs Winsorized ==="</span>)
<span class="fn">print</span>(<span class="st">f"원본 - min: </span>{returns.min():.4f}<span class="st">, max: </span>{returns.max():.4f}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"깎음 - min: </span>{returns_win2.min():.4f}<span class="st">, max: </span>{returns_win2.max():.4f}<span class="st">"</span>)

<span class="cm"># 시각화: 원본 vs Winsorized 분포</span>
fig, axes = plt.subplots(<span class="nu">1</span>, <span class="nu">2</span>, figsize=(<span class="nu">12</span>, <span class="nu">4</span>))
axes[<span class="nu">0</span>].hist(returns, bins=<span class="nu">50</span>, color=<span class="st">"steelblue"</span>, alpha=<span class="nu">0.7</span>, edgecolor=<span class="st">"white"</span>)
axes[<span class="nu">0</span>].set_title(<span class="st">"원본 수익률 분포"</span>)
axes[<span class="nu">1</span>].hist(returns_win2, bins=<span class="nu">50</span>, color=<span class="st">"coral"</span>, alpha=<span class="nu">0.7</span>, edgecolor=<span class="st">"white"</span>)
axes[<span class="nu">1</span>].set_title(<span class="st">"Winsorized 수익률 분포 (1%/99%)"</span>)
<span class="kw">for</span> ax <span class="kw">in</span> axes:
    ax.grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)
plt.tight_layout()
plt.show()</code></pre>

<div class="info">
<p class="ni"><strong>실전에서의 선택:</strong> 대부분의 퀀트 펀드에서는 수익률 데이터에 Winsorization(상하위 1~2.5%)을 적용한다. 이유는 (1) 데이터를 삭제하지 않아 시계열 연속성이 유지되고, (2) 극단값의 영향을 줄여 모델이 안정적으로 학습하며, (3) 구현이 간단하기 때문이다. MLAT Ch.4에서도 알파팩터 계산 시 Winsorization을 권장한다.</p>
</div>

<h3>6.5 이상치 처리 전략 정리</h3>

<div class="tc">Table 5. 이상치 처리 방법 비교</div>
<table>
<tr><th>방법</th><th>원리</th><th>장점</th><th>단점</th><th>금융 적합도</th></tr>
<tr><td>Z-Score 제거</td><td>|Z| > 3 제거</td><td>통계적 근거</td><td>정규분포 가정, 팻테일 무시</td><td>△</td></tr>
<tr><td>IQR 제거</td><td>1.5×IQR 밖 제거</td><td>분포 가정 없음</td><td>금융에서 너무 많이 제거</td><td>△</td></tr>
<tr><td>Winsorization</td><td>상하위 n% 깎기</td><td>데이터 보존, 안정적</td><td>극단값 정보 일부 손실</td><td>⭐ 추천</td></tr>
<tr><td>로그 변환</td><td>log(x)로 스케일 축소</td><td>왜도 감소</td><td>음수 불가</td><td>가격 데이터에 적합</td></tr>
<tr><td>MAD</td><td>중앙값 기반 편차</td><td>로버스트</td><td>덜 알려짐</td><td>○</td></tr>
</table>

<!-- ══ Plotly: 이상치 탐지 시각화 (Z-score + IQR + Winsorization) ══ -->
<div id="plot-ch6-outlier" style="width:100%;height:450px;margin:25px 0"></div>
<p class="ni" style="font-size:12px;color:#888;text-align:center">🖱️ 일간 수익률 분포에서 Z-score(±3σ)와 IQR(1.5×) 경계를 확인하세요 · 범례 클릭으로 토글</p>
<div id="plot-ch6-winsor" style="width:100%;height:400px;margin:25px 0"></div>
<p class="ni" style="font-size:12px;color:#888;text-align:center">🖱️ Winsorization 전후 비교 — 극단값이 어떻게 깎이는지 확인</p>
<script>
(function(){
  function mulberry32(a){return function(){a|=0;a=a+0x6D2B79F5|0;var t=Math.imul(a^a>>>15,1|a);t=t+Math.imul(t^t>>>7,61|t)^t;return((t^t>>>14)>>>0)/4294967296}}
  var rng=mulberry32(42);
  function randn(){var u=0,v=0;while(u===0)u=rng();while(v===0)v=rng();return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v)}

  // 250일 일간 수익률 (팻테일 포함)
  var N=250,rets=[];
  for(var i=0;i<N;i++){
    var r=randn()*0.018; // 기본 변동성 1.8%
    if(rng()<0.03)r+=randn()*0.05; // 3% 확률로 극단 이벤트
    rets.push(r*100); // %로 변환
  }
  rets.sort(function(a,b){return a-b});

  var mean=rets.reduce(function(s,v){return s+v},0)/N;
  var std=Math.sqrt(rets.reduce(function(s,v){return s+(v-mean)*(v-mean)},0)/N);

  // IQR
  var q1=rets[Math.floor(N*0.25)],q3=rets[Math.floor(N*0.75)];
  var iqr=q3-q1;
  var iqrLow=q1-1.5*iqr,iqrHigh=q3+1.5*iqr;

  // Z-score 경계
  var zLow=mean-3*std,zHigh=mean+3*std;

  var xIdx=[];for(var i=0;i<N;i++)xIdx.push(i+1);

  // 색상: 정상=파랑, Z이상치=빨강, IQR이상치=주황
  var colors=rets.map(function(r){
    if(r<zLow||r>zHigh)return '#e74c3c';
    if(r<iqrLow||r>iqrHigh)return '#f39c12';
    return '#3498db';
  });

  Plotly.newPlot('plot-ch6-outlier',[
    {x:xIdx,y:rets,mode:'markers',marker:{color:colors,size:7,opacity:0.7},
     name:'일간 수익률',hovertemplate:'수익률: %{y:.2f}%<extra></extra>'},
    {x:[0,N+1],y:[zHigh,zHigh],mode:'lines',name:'Z-score ±3σ',line:{color:'#e74c3c',width:2,dash:'dash'}},
    {x:[0,N+1],y:[zLow,zLow],mode:'lines',showlegend:false,line:{color:'#e74c3c',width:2,dash:'dash'}},
    {x:[0,N+1],y:[iqrHigh,iqrHigh],mode:'lines',name:'IQR ×1.5',line:{color:'#f39c12',width:2,dash:'dot'}},
    {x:[0,N+1],y:[iqrLow,iqrLow],mode:'lines',showlegend:false,line:{color:'#f39c12',width:2,dash:'dot'}},
    {x:[0,N+1],y:[mean,mean],mode:'lines',name:'평균',line:{color:'#2ecc71',width:1.5}}
  ],{
    title:{text:'🔍 이상치 탐지: Z-score vs IQR 경계',font:{size:14}},
    xaxis:{title:'관측치 (정렬됨)',gridcolor:'#eee'},
    yaxis:{title:'일간 수익률 (%)',gridcolor:'#eee'},
    legend:{orientation:'h',y:-0.15},
    plot_bgcolor:'#fafafa',paper_bgcolor:'#fff',margin:{t:50,b:60},
    annotations:[
      {x:N*0.95,y:zHigh,text:'3σ='+zHigh.toFixed(1)+'%',showarrow:false,font:{size:10,color:'#e74c3c'}},
      {x:N*0.95,y:iqrHigh,text:'IQR='+iqrHigh.toFixed(1)+'%',showarrow:false,font:{size:10,color:'#f39c12'}}
    ]
  },{responsive:true});

  // Winsorization 비교
  var pct1=rets[Math.floor(N*0.01)],pct99=rets[Math.floor(N*0.99)];
  var pct5=rets[Math.floor(N*0.05)],pct95=rets[Math.floor(N*0.95)];
  var win1=rets.map(function(r){return Math.max(pct1,Math.min(pct99,r))});
  var win5=rets.map(function(r){return Math.max(pct5,Math.min(pct95,r))});

  Plotly.newPlot('plot-ch6-winsor',[
    {y:rets,type:'box',name:'원본',marker:{color:'#3498db'},boxpoints:'all',jitter:0.3,pointpos:-1.5},
    {y:win1,type:'box',name:'Winsor 1%',marker:{color:'#e67e22'},boxpoints:'all',jitter:0.3,pointpos:-1.5},
    {y:win5,type:'box',name:'Winsor 5%',marker:{color:'#27ae60'},boxpoints:'all',jitter:0.3,pointpos:-1.5}
  ],{
    title:{text:'📦 Winsorization 전후 비교 (Box Plot)',font:{size:14}},
    yaxis:{title:'일간 수익률 (%)',gridcolor:'#eee'},
    plot_bgcolor:'#fafafa',paper_bgcolor:'#fff',margin:{t:50,b:40},
    legend:{orientation:'h',y:-0.12}
  },{responsive:true});
})();
</script>

<!-- ═══════════════════════════════════════════ -->
<!-- Ch7: 정규화와 표준화 -->
<!-- ═══════════════════════════════════════════ -->
<h2 id="ch7">7. 정규화와 표준화 — 스케일을 맞춰라</h2>

<!-- 스케일링 비교 다이어그램 (CSS) -->
<div style="margin:25px 0;padding:25px;background:linear-gradient(135deg,#f8f9fa,#f0f0fa);border-radius:10px;border:1px solid #ccc">
<p class="ni" style="text-align:center;font-weight:bold;font-size:15px;margin-bottom:18px;color:#2c3e50">⚖️ 스케일링 3종 비교</p>
<div style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap;font-size:12px">
<div style="flex:1;min-width:180px;background:#fff;border-radius:8px;padding:15px;border-top:4px solid #3498db;box-shadow:0 1px 3px rgba(0,0,0,0.1)">
<div style="font-weight:bold;color:#3498db;font-size:14px;margin-bottom:8px">Min-Max 정규화</div>
<div style="background:#e8f4f8;padding:8px;border-radius:4px;text-align:center;font-family:monospace;margin-bottom:8px">[0, 1] 범위로 압축</div>
<div style="color:#555;margin-bottom:6px">
<div style="display:flex;justify-content:space-between;margin-bottom:2px"><span>원본:</span><span>70,000원</span></div>
<div style="display:flex;justify-content:space-between"><span>변환:</span><span style="color:#3498db;font-weight:bold">0.75</span></div>
</div>
<div style="font-size:11px;color:#888">✅ 범위 고정 피처 (RSI 등)</div>
<div style="font-size:11px;color:#e74c3c">⚠️ 이상치에 매우 민감</div>
</div>
<div style="flex:1;min-width:180px;background:#fff;border-radius:8px;padding:15px;border-top:4px solid #e67e22;box-shadow:0 1px 3px rgba(0,0,0,0.1)">
<div style="font-weight:bold;color:#e67e22;font-size:14px;margin-bottom:8px">Z-Score 표준화</div>
<div style="background:#fff9e6;padding:8px;border-radius:4px;text-align:center;font-family:monospace;margin-bottom:8px">평균=0, 표준편차=1</div>
<div style="color:#555;margin-bottom:6px">
<div style="display:flex;justify-content:space-between;margin-bottom:2px"><span>원본:</span><span>70,000원</span></div>
<div style="display:flex;justify-content:space-between"><span>변환:</span><span style="color:#e67e22;font-weight:bold">+0.42σ</span></div>
</div>
<div style="font-size:11px;color:#888">✅ 수익률, 팩터 값 ⭐추천</div>
<div style="font-size:11px;color:#888">✅ PCA, 선형회귀에 적합</div>
</div>
<div style="flex:1;min-width:180px;background:#fff;border-radius:8px;padding:15px;border-top:4px solid #27ae60;box-shadow:0 1px 3px rgba(0,0,0,0.1)">
<div style="font-weight:bold;color:#27ae60;font-size:14px;margin-bottom:8px">Robust 스케일링</div>
<div style="background:#e8f8e8;padding:8px;border-radius:4px;text-align:center;font-family:monospace;margin-bottom:8px">중앙값=0, IQR 기반</div>
<div style="color:#555;margin-bottom:6px">
<div style="display:flex;justify-content:space-between;margin-bottom:2px"><span>원본:</span><span>70,000원</span></div>
<div style="display:flex;justify-content:space-between"><span>변환:</span><span style="color:#27ae60;font-weight:bold">+0.38</span></div>
</div>
<div style="font-size:11px;color:#888">✅ 이상치 많은 데이터</div>
<div style="font-size:11px;color:#888">✅ 거래량, 시가총액</div>
</div>
</div>
<div style="margin-top:15px;text-align:center;font-size:12px;color:#555;background:#fff;padding:8px;border-radius:6px">
⚠️ <strong>핵심 규칙:</strong> Train 데이터에서 fit → Test 데이터에는 transform만! (미래 정보 누출 방지)
</div>
</div>

<h3>7.1 왜 스케일링이 필요한가</h3>
<p>삼성전자 주가는 약 7만 원이고, SK하이닉스는 약 20만 원이고, 거래량은 수천만 주다. 이 세 가지를 피처로 사용하면, 숫자가 큰 피처(거래량)가 ML 모델을 지배하게 된다. 모델이 "거래량이 중요하다"고 착각하는 것이다.</p>

<p>이것을 비유하면: 키(cm)와 몸무게(kg)를 비교할 때, 키가 170이고 몸무게가 70이면 "키가 더 크다"고 말하는 것과 같다. 단위가 다르니까 직접 비교할 수 없다. 스케일링은 모든 피처를 같은 단위로 맞추는 작업이다.</p>

<h3>7.2 Min-Max 정규화 (Normalization)</h3>
<p>모든 값을 0~1 사이로 변환한다. 최솟값이 0, 최댓값이 1이 된다.</p>

<div class="eq">\[ x_{\text{norm}} = \frac{x - x_{\min}}{x_{\max} - x_{\min}} \]</div>

<pre><code><span class="kw">from</span> sklearn.preprocessing <span class="kw">import</span> MinMaxScaler

<span class="cm"># 예제: 주가와 거래량의 스케일 차이</span>
raw = pd.DataFrame({
    <span class="st">"price"</span>: [<span class="nu">70000</span>, <span class="nu">71000</span>, <span class="nu">69500</span>, <span class="nu">72000</span>, <span class="nu">70500</span>],
    <span class="st">"volume"</span>: [<span class="nu">15000000</span>, <span class="nu">20000000</span>, <span class="nu">12000000</span>, <span class="nu">25000000</span>, <span class="nu">18000000</span>],
    <span class="st">"rsi"</span>: [<span class="nu">45</span>, <span class="nu">52</span>, <span class="nu">38</span>, <span class="nu">65</span>, <span class="nu">48</span>]
})

<span class="fn">print</span>(<span class="st">"=== 원본 (스케일 차이 극심) ==="</span>)
<span class="fn">print</span>(raw)

<span class="cm"># Min-Max 정규화</span>
scaler = MinMaxScaler()
normalized = pd.DataFrame(
    scaler.fit_transform(raw),
    columns=raw.columns
)

<span class="fn">print</span>(<span class="st">"\n=== Min-Max 정규화 (0~1) ==="</span>)
<span class="fn">print</span>(normalized.round(<span class="nu">4</span>))

<span class="cm"># 직접 구현</span>
<span class="kw">def</span> <span class="fn">minmax_normalize</span>(df):
    <span class="kw">return</span> (df - df.min()) / (df.max() - df.min())

normalized2 = minmax_normalize(raw)
<span class="fn">print</span>(<span class="st">"\n=== 직접 구현 결과 ==="</span>)
<span class="fn">print</span>(normalized2.round(<span class="nu">4</span>))</code></pre>

<div class="warn">
<p class="ni"><strong>Min-Max의 약점:</strong> 이상치에 매우 민감하다. 만약 거래량에 1억 주짜리 이상치가 하나 있으면, 나머지 모든 값이 0에 가깝게 압축된다. 따라서 이상치 처리를 먼저 한 후에 Min-Max를 적용해야 한다.</p>
</div>

<h3>7.3 Z-Score 표준화 (Standardization)</h3>
<p>평균을 0, 표준편차를 1로 변환한다. 정규분포를 따르는 데이터에 특히 적합하다.</p>

<div class="eq">\[ x_{\text{std}} = \frac{x - \mu}{\sigma} \]</div>

<pre><code><span class="kw">from</span> sklearn.preprocessing <span class="kw">import</span> StandardScaler

<span class="cm"># Z-Score 표준화</span>
scaler_z = StandardScaler()
standardized = pd.DataFrame(
    scaler_z.fit_transform(raw),
    columns=raw.columns
)

<span class="fn">print</span>(<span class="st">"=== Z-Score 표준화 (평균=0, 표준편차=1) ==="</span>)
<span class="fn">print</span>(standardized.round(<span class="nu">4</span>))

<span class="fn">print</span>(<span class="st">"\n=== 검증: 평균과 표준편차 ==="</span>)
<span class="fn">print</span>(<span class="st">f"평균: </span>{standardized.mean().round(<span class="nu">6</span>).tolist()}<span class="st">"</span>)  <span class="cm"># ≈ 0</span>
<span class="fn">print</span>(<span class="st">f"표준편차: </span>{standardized.std().round(<span class="nu">4</span>).tolist()}<span class="st">"</span>)  <span class="cm"># ≈ 1</span></code></pre>

<h3>7.4 어떤 스케일링을 선택할까?</h3>

<div class="tc">Table 6. 스케일링 방법 비교</div>
<table>
<tr><th>방법</th><th>범위</th><th>이상치 민감도</th><th>적합한 모델</th><th>금융 사용 예</th></tr>
<tr><td>Min-Max</td><td>[0, 1]</td><td>매우 민감</td><td>신경망, KNN</td><td>RSI 등 범위가 정해진 지표</td></tr>
<tr><td>Z-Score</td><td>(-∞, +∞)</td><td>덜 민감</td><td>선형회귀, SVM, PCA</td><td>수익률, 팩터 값</td></tr>
<tr><td>Robust</td><td>(-∞, +∞)</td><td>로버스트</td><td>이상치 많은 데이터</td><td>거래량, 시가총액</td></tr>
</table>

<pre><code><span class="kw">from</span> sklearn.preprocessing <span class="kw">import</span> RobustScaler

<span class="cm"># Robust Scaler: 중앙값과 IQR 기반 (이상치에 강건)</span>
scaler_r = RobustScaler()
robust = pd.DataFrame(
    scaler_r.fit_transform(raw),
    columns=raw.columns
)
<span class="fn">print</span>(<span class="st">"=== Robust Scaling ==="</span>)
<span class="fn">print</span>(robust.round(<span class="nu">4</span>))</code></pre>

<div class="def">
<p class="ni"><strong>핵심 원칙: Train/Test 분리 시 스케일링</strong></p>
<p class="ni">스케일링의 파라미터(평균, 표준편차, 최솟값, 최댓값)는 반드시 학습 데이터(train set)에서만 계산해야 한다. 테스트 데이터의 정보가 스케일링에 포함되면 미래 정보 누출이다. 이것은 Round 4에서 모델을 학습할 때 매우 중요해진다.</p>
</div>

<pre><code><span class="cm"># 올바른 스케일링 절차</span>
<span class="kw">from</span> sklearn.model_selection <span class="kw">import</span> train_test_split

<span class="cm"># 1. 데이터 분할</span>
X_train, X_test = train_test_split(raw, test_size=<span class="nu">0.2</span>, shuffle=<span class="kw">False</span>)
<span class="cm"># shuffle=False: 시계열이므로 섞지 않는다!</span>

<span class="cm"># 2. train에서만 fit</span>
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)  <span class="cm"># fit + transform</span>

<span class="cm"># 3. test에는 transform만 (fit 하지 않음!)</span>
X_test_scaled = scaler.transform(X_test)  <span class="cm"># transform만!</span>

<span class="fn">print</span>(<span class="st">"Train 평균:"</span>, X_train_scaled.mean(axis=<span class="nu">0</span>).round(<span class="nu">4</span>))  <span class="cm"># ≈ 0</span>
<span class="fn">print</span>(<span class="st">"Test 평균:"</span>, X_test_scaled.mean(axis=<span class="nu">0</span>).round(<span class="nu">4</span>))   <span class="cm"># ≠ 0 (정상!)</span></code></pre>

<div class="warn">
<p class="ni"><strong>가장 흔한 실수:</strong> <code>scaler.fit_transform(전체 데이터)</code>를 한 후에 train/test로 나누는 것. 이러면 test 데이터의 통계량이 스케일링에 반영되어 미래 정보가 누출된다. 반드시 "먼저 나누고, train에서만 fit"하자.</p>
</div>

<!-- ── 보충 7.3+ 왜 스케일링 순서가 중요한가 — 데이터 누출 실험 ── -->
<div class="def">
<p class="ni"><strong>🔍 보충: 왜 스케일링 순서가 중요한가 — 잘못된 순서 vs 올바른 순서 실험</strong></p>
<p class="ni">"먼저 나누고 train에서만 fit" — 이 규칙을 어기면 실제로 얼마나 차이가 나는지 숫자로 확인하자. 데이터 누출(data leakage)이 백테스트 성과를 어떻게 부풀리는지 직관적으로 이해할 수 있다.</p>
</div>

<pre><code><span class="cm"># === 스케일링 순서: 잘못된 방법 vs 올바른 방법 ===</span>
<span class="kw">import</span> numpy <span class="kw">as</span> np
<span class="kw">import</span> pandas <span class="kw">as</span> pd
<span class="kw">from</span> sklearn.preprocessing <span class="kw">import</span> StandardScaler

np.random.seed(<span class="nu">42</span>)

<span class="cm"># 가상 데이터: train 기간은 안정적, test 기간은 급등</span>
<span class="cm"># (실전에서 흔한 상황: 학습 기간과 테스트 기간의 분포가 다름)</span>
train_data = np.random.normal(<span class="nu">100</span>, <span class="nu">10</span>, (<span class="nu">200</span>, <span class="nu">3</span>))  <span class="cm"># 평균 100, 표준편차 10</span>
test_data = np.random.normal(<span class="nu">150</span>, <span class="nu">20</span>, (<span class="nu">50</span>, <span class="nu">3</span>))   <span class="cm"># 평균 150, 표준편차 20 (급등!)</span>

<span class="fn">print</span>(<span class="st">"=== 원본 데이터 통계 ==="</span>)
<span class="fn">print</span>(<span class="st">f"Train 평균: </span>{train_data.mean():.1f}<span class="st">, 표준편차: </span>{train_data.std():.1f}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"Test 평균:  </span>{test_data.mean():.1f}<span class="st">, 표준편차: </span>{test_data.std():.1f}<span class="st">"</span>)</code></pre>

<pre><code><span class="cm"># ❌ 잘못된 방법: 전체 데이터에 fit_transform 후 분리</span>
all_data = np.vstack([train_data, test_data])  <span class="cm"># 합치기</span>
scaler_wrong = StandardScaler()
all_scaled = scaler_wrong.fit_transform(all_data)  <span class="cm"># 전체에 fit!</span>
train_wrong = all_scaled[:<span class="nu">200</span>]
test_wrong = all_scaled[<span class="nu">200</span>:]

<span class="fn">print</span>(<span class="st">"\n=== ❌ 잘못된 방법 (전체 fit) ==="</span>)
<span class="fn">print</span>(<span class="st">f"scaler가 학습한 평균: </span>{scaler_wrong.mean_[0]:.1f}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"  → test의 급등 정보가 평균에 반영됨!"</span>)
<span class="fn">print</span>(<span class="st">f"Train 스케일링 후 평균: </span>{train_wrong.mean():.4f}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"Test 스케일링 후 평균:  </span>{test_wrong.mean():.4f}<span class="st">"</span>)</code></pre>

<pre><code><span class="cm"># ✅ 올바른 방법: train에서만 fit, test에는 transform만</span>
scaler_right = StandardScaler()
train_right = scaler_right.fit_transform(train_data)  <span class="cm"># train에서만 fit</span>
test_right = scaler_right.transform(test_data)         <span class="cm"># transform만!</span>

<span class="fn">print</span>(<span class="st">"\n=== ✅ 올바른 방법 (train만 fit) ==="</span>)
<span class="fn">print</span>(<span class="st">f"scaler가 학습한 평균: </span>{scaler_right.mean_[0]:.1f}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"  → train 데이터의 통계만 사용!"</span>)
<span class="fn">print</span>(<span class="st">f"Train 스케일링 후 평균: </span>{train_right.mean():.4f}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"Test 스케일링 후 평균:  </span>{test_right.mean():.4f}<span class="st">"</span>)

<span class="fn">print</span>(<span class="st">"\n=== 차이 비교 ==="</span>)
<span class="fn">print</span>(<span class="st">f"잘못된 방법 test 평균: </span>{test_wrong.mean():.4f}<span class="st"> (0에 가까움 → 정상처럼 보임)"</span>)
<span class="fn">print</span>(<span class="st">f"올바른 방법 test 평균: </span>{test_right.mean():.4f}<span class="st"> (양수 → 급등 신호 보존!)"</span>)
<span class="fn">print</span>(<span class="st">f"\n→ 잘못된 방법은 test의 급등을 '정상'으로 만들어버린다."</span>)
<span class="fn">print</span>(<span class="st">f"→ 모델이 '이건 비정상적 상승이다'라는 신호를 놓치게 된다."</span>)
<span class="fn">print</span>(<span class="st">f"→ 백테스트에서는 잘 되지만, 실전에서 실패하는 원인!"</span>)</code></pre>

<div class="info">
<p class="ni"><strong>실전 체크리스트:</strong></p>
<ol>
<li><code>train_test_split()</code> 또는 시간 기준으로 먼저 분리</li>
<li><code>scaler.fit(X_train)</code> — train에서만 통계량 학습</li>
<li><code>X_train_scaled = scaler.transform(X_train)</code></li>
<li><code>X_test_scaled = scaler.transform(X_test)</code> — 같은 scaler로 변환만</li>
<li>교차검증(CV)에서도 각 fold마다 이 과정을 반복해야 한다 → <code>Pipeline</code> 사용 권장</li>
</ol>
</div>

<!-- ══ Plotly: 스케일링 비교 (Raw vs MinMax vs Z-Score vs Robust) ══ -->
<div id="plot-ch7-scaling" style="width:100%;height:500px;margin:25px 0"></div>
<p class="ni" style="font-size:12px;color:#888;text-align:center">🖱️ 4가지 스케일링 방법 비교 — 드롭다운으로 피처 전환 · 이상치가 있을 때 Robust의 강건함을 확인</p>
<script>
(function(){
  function mulberry32(a){return function(){a|=0;a=a+0x6D2B79F5|0;var t=Math.imul(a^a>>>15,1|a);t=t+Math.imul(t^t>>>7,61|t)^t;return((t^t>>>14)>>>0)/4294967296}}
  var rng=mulberry32(123);
  function randn(){var u=0,v=0;while(u===0)u=rng();while(v===0)v=rng();return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v)}

  // 3개 피처: 주가(만원대), RSI(0~100), 거래량(백만대)
  var N=100;
  var features={
    '주가 (원)':{data:[],color:'#e74c3c'},
    'RSI (0~100)':{data:[],color:'#3498db'},
    '거래량 (주)':{data:[],color:'#2ecc71'}
  };
  for(var i=0;i<N;i++){
    features['주가 (원)'].data.push(60000+randn()*8000+(rng()<0.03?randn()*30000:0));
    features['RSI (0~100)'].data.push(Math.max(5,Math.min(95,50+randn()*18)));
    features['거래량 (주)'].data.push(Math.max(100000,2000000+randn()*800000+(rng()<0.05?5000000:0)));
  }

  function minmax(arr){var mn=Math.min.apply(null,arr),mx=Math.max.apply(null,arr);return arr.map(function(v){return(v-mn)/(mx-mn)})}
  function zscore(arr){var m=arr.reduce(function(s,v){return s+v},0)/arr.length;var s=Math.sqrt(arr.reduce(function(s,v){return s+(v-m)*(v-m)},0)/arr.length);return arr.map(function(v){return(v-m)/s})}
  function robust(arr){var sorted=arr.slice().sort(function(a,b){return a-b});var med=sorted[Math.floor(sorted.length/2)];var q1=sorted[Math.floor(sorted.length*0.25)];var q3=sorted[Math.floor(sorted.length*0.75)];var iqr=q3-q1;return arr.map(function(v){return(v-med)/iqr})}

  var names=Object.keys(features);
  var xIdx=[];for(var i=0;i<N;i++)xIdx.push(i+1);

  // 모든 피처를 한 차트에 4가지 스케일링으로
  var methods=['Raw','Min-Max [0,1]','Z-Score (μ=0,σ=1)','Robust (IQR)'];
  var methodColors=['#e74c3c','#3498db','#2ecc71','#9b59b6'];

  var allTraces=[];
  var buttons=[];

  names.forEach(function(fname,fi){
    var raw=features[fname].data;
    var scaled=[raw,minmax(raw),zscore(raw),robust(raw)];
    scaled.forEach(function(d,mi){
      allTraces.push({
        x:xIdx,y:d,mode:'lines',name:methods[mi],
        line:{color:methodColors[mi],width:2},
        visible:fi===0,
        hovertemplate:methods[mi]+': %{y:.4f}<extra></extra>'
      });
    });
    var vis=[];for(var j=0;j<names.length*4;j++)vis.push(j>=fi*4&&j<(fi+1)*4);
    buttons.push({method:'update',args:[{visible:vis}],label:fname});
  });

  Plotly.newPlot('plot-ch7-scaling',allTraces,{
    title:{text:'⚖️ 스케일링 4종 비교',font:{size:14}},
    xaxis:{title:'관측치',gridcolor:'#eee'},
    yaxis:{title:'값',gridcolor:'#eee'},
    legend:{orientation:'h',y:-0.15},
    hovermode:'x unified',
    plot_bgcolor:'#fafafa',paper_bgcolor:'#fff',margin:{t:80,b:60},
    updatemenus:[{
      buttons:buttons,direction:'down',showactive:true,
      x:0.02,xanchor:'left',y:1.12,yanchor:'top',
      bgcolor:'#f0f0f0',bordercolor:'#ccc'
    }]
  },{responsive:true});
})();
</script>

<!-- ═══════════════════════════════════════════ -->
<!-- Ch8: 기술적 지표 피처 -->
<!-- ═══════════════════════════════════════════ -->
<h2 id="ch8">8. 기술적 지표 피처 — 가격에서 신호를 추출하다</h2>

<h3>8.1 기술적 분석이란?</h3>
<p>기술적 분석(Technical Analysis)은 과거 가격과 거래량 패턴에서 미래 가격 움직임을 예측하려는 방법론이다. "역사는 반복된다"는 가정에 기반한다. 학술적으로는 논란이 있지만, 실전에서는 여전히 널리 사용되며, ML 모델의 입력 피처로도 매우 유용하다.</p>

<p>왜 기술적 지표가 ML 피처로 좋을까? 원시 가격 데이터(OHLCV)를 그대로 모델에 넣으면, 모델이 "삼성전자 주가가 7만 원이다"라는 절대적 수준만 본다. 하지만 기술적 지표는 "최근 14일 대비 지금이 과매수인가 과매도인가"(RSI), "단기 추세가 장기 추세를 상향 돌파했는가"(MACD) 같은 상대적 정보를 제공한다. 이런 상대적 정보가 ML 모델에게 훨씬 유용하다.</p>

<!-- 기술적 지표 분류 다이어그램 (CSS) -->
<div style="margin:25px 0;padding:20px;background:#f8f9fa;border-radius:8px;border:1px solid #ddd">
<p class="ni" style="text-align:center;font-weight:bold;font-size:14px;margin-bottom:15px;color:#2c3e50">📈 기술적 지표 4대 카테고리</p>
<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:10px;font-size:12px">
<div style="background:#e8f4f8;padding:14px;border-radius:6px;border-top:3px solid #3498db">
<div style="font-weight:bold;color:#2c3e50;font-size:13px;margin-bottom:8px">📊 추세 (Trend)</div>
<div style="color:#555">시장이 올라가는 중인가, 내려가는 중인가?</div>
<div style="margin-top:8px;font-size:11px;color:#3498db">
• SMA / EMA (이동평균)<br>
• MACD<br>
• 골든크로스 / 데드크로스
</div>
</div>
<div style="background:#fff9e6;padding:14px;border-radius:6px;border-top:3px solid #f39c12">
<div style="font-weight:bold;color:#2c3e50;font-size:13px;margin-bottom:8px">⚡ 과매수/과매도</div>
<div style="color:#555">너무 많이 올랐나? 너무 많이 떨어졌나?</div>
<div style="margin-top:8px;font-size:11px;color:#e67e22">
• RSI<br>
• 볼린저 밴드 %B<br>
• 스토캐스틱
</div>
</div>
<div style="background:#e8f8e8;padding:14px;border-radius:6px;border-top:3px solid #27ae60">
<div style="font-weight:bold;color:#2c3e50;font-size:13px;margin-bottom:8px">🌊 변동성 (Volatility)</div>
<div style="color:#555">가격이 얼마나 크게 흔들리는가?</div>
<div style="margin-top:8px;font-size:11px;color:#27ae60">
• 역사적 변동성<br>
• ATR<br>
• 볼린저 밴드폭
</div>
</div>
<div style="background:#f0e8f8;padding:14px;border-radius:6px;border-top:3px solid #8e44ad">
<div style="font-weight:bold;color:#2c3e50;font-size:13px;margin-bottom:8px">📦 거래량 (Volume)</div>
<div style="color:#555">얼마나 많은 사람이 참여하는가?</div>
<div style="margin-top:8px;font-size:11px;color:#8e44ad">
• 거래량 비율<br>
• OBV<br>
• VWAP
</div>
</div>
</div>
</div>

<div class="info">
<p class="ni"><strong>교재 연동:</strong> MLAT Ch.4 "Financial Feature Engineering and Alpha Factors"에서 기술적 지표를 알파팩터로 활용하는 방법을 상세히 다룬다. 이 챕터는 Round 3의 핵심 참고 자료다.</p>
</div>

<h3>8.2 이동평균 (Moving Average)</h3>
<p>이동평균은 가장 기본적인 기술적 지표다. 최근 n일간의 평균 가격을 계산하여 추세를 파악한다. 노이즈를 제거하고 큰 흐름을 보여주는 "스무딩(smoothing)" 효과가 있다.</p>

<pre><code><span class="cm"># 삼성전자 1년 데이터</span>
samsung_df = yf.download(<span class="st">"005930.KS"</span>, period=<span class="st">"1y"</span>)
close = samsung_df[<span class="st">"Close"</span>].squeeze()

<span class="cm"># 단순 이동평균 (SMA: Simple Moving Average)</span>
close_series = close.squeeze()  <span class="cm"># DataFrame → Series 변환</span>
sma_5 = close_series.rolling(window=<span class="nu">5</span>).mean()    <span class="cm"># 5일 이동평균 (1주)</span>
sma_20 = close_series.rolling(window=<span class="nu">20</span>).mean()  <span class="cm"># 20일 이동평균 (1달)</span>
sma_60 = close_series.rolling(window=<span class="nu">60</span>).mean()  <span class="cm"># 60일 이동평균 (3달)</span>

<span class="cm"># 지수 이동평균 (EMA: Exponential Moving Average)</span>
<span class="cm"># 최근 데이터에 더 큰 가중치를 부여</span>
ema_12 = close_series.ewm(span=<span class="nu">12</span>).mean()
ema_26 = close_series.ewm(span=<span class="nu">26</span>).mean()

<span class="cm"># 시각화</span>
fig, ax = plt.subplots(figsize=(<span class="nu">14</span>, <span class="nu">6</span>))
ax.plot(close_series.index, close_series.values, color=<span class="st">"black"</span>, linewidth=<span class="nu">1</span>, label=<span class="st">"종가"</span>, alpha=<span class="nu">0.8</span>)
ax.plot(sma_5.index, sma_5.values, color=<span class="st">"blue"</span>, linewidth=<span class="nu">0.8</span>, label=<span class="st">"SMA 5"</span>)
ax.plot(sma_20.index, sma_20.values, color=<span class="st">"orange"</span>, linewidth=<span class="nu">1.2</span>, label=<span class="st">"SMA 20"</span>)
ax.plot(sma_60.index, sma_60.values, color=<span class="st">"red"</span>, linewidth=<span class="nu">1.5</span>, label=<span class="st">"SMA 60"</span>)
ax.set_title(<span class="st">"삼성전자 이동평균선"</span>, fontsize=<span class="nu">14</span>)
ax.legend()
ax.grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)
plt.tight_layout()
plt.show()</code></pre>

<div class="def">
<p class="ni"><strong>SMA vs EMA</strong></p>
<p class="ni"><strong>SMA (Simple Moving Average):</strong> 모든 날에 동일한 가중치. 계산이 단순하지만 최근 변화에 느리게 반응한다.</p>
<div class="eq">\[ \text{SMA}_n = \frac{1}{n} \sum_{i=0}^{n-1} P_{t-i} \]</div>
<p class="ni"><strong>EMA (Exponential Moving Average):</strong> 최근 데이터에 더 큰 가중치. 추세 변화에 빠르게 반응한다. MACD 계산에 사용된다.</p>
<div class="eq">\[ \text{EMA}_t = \alpha \cdot P_t + (1-\alpha) \cdot \text{EMA}_{t-1}, \quad \alpha = \frac{2}{n+1} \]</div>
</div>

<!-- ── 보충 8.2+ 왜 EMA가 더 빠르게 반응하는가 ── -->
<div class="def">
<p class="ni"><strong>🔍 보충: 왜 EMA가 SMA보다 빠르게 반응하는가 — 가중치 감쇠 시각화</strong></p>
<p class="ni">SMA와 EMA의 차이를 직관적으로 이해하려면, 각 방법이 과거 데이터에 부여하는 "가중치"를 비교해보면 된다. SMA는 모든 날에 동일한 가중치를 주지만, EMA는 최근 날에 훨씬 큰 가중치를 준다. 이 가중치 차이가 반응 속도의 차이를 만든다.</p>
</div>

<pre><code><span class="cm"># === SMA vs EMA 가중치 비교 시각화 ===</span>
<span class="kw">import</span> numpy <span class="kw">as</span> np
<span class="kw">import</span> matplotlib.pyplot <span class="kw">as</span> plt

n = <span class="nu">20</span>  <span class="cm"># 20일 이동평균</span>
alpha = <span class="nu">2</span> / (n + <span class="nu">1</span>)  <span class="cm"># EMA 감쇠 계수 = 2/21 ≈ 0.095</span>

<span class="cm"># SMA 가중치: 모든 날 동일 (1/20 = 0.05)</span>
sma_weights = np.ones(n) / n

<span class="cm"># EMA 가중치: 최근일수록 크고, 과거로 갈수록 지수적으로 감소</span>
ema_weights = np.array([alpha * (<span class="nu">1</span> - alpha)**i <span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(n)])
ema_weights = ema_weights / ema_weights.sum()  <span class="cm"># 합이 1이 되도록 정규화</span>

<span class="cm"># 시각화</span>
fig, axes = plt.subplots(<span class="nu">1</span>, <span class="nu">3</span>, figsize=(<span class="nu">16</span>, <span class="nu">5</span>))

<span class="cm"># 패널 1: 가중치 비교</span>
days_ago = np.arange(n)
axes[<span class="nu">0</span>].bar(days_ago - <span class="nu">0.2</span>, sma_weights, width=<span class="nu">0.4</span>, label=<span class="st">"SMA"</span>, color=<span class="st">"steelblue"</span>, alpha=<span class="nu">0.8</span>)
axes[<span class="nu">0</span>].bar(days_ago + <span class="nu">0.2</span>, ema_weights, width=<span class="nu">0.4</span>, label=<span class="st">"EMA"</span>, color=<span class="st">"coral"</span>, alpha=<span class="nu">0.8</span>)
axes[<span class="nu">0</span>].set_xlabel(<span class="st">"며칠 전 (0=오늘)"</span>)
axes[<span class="nu">0</span>].set_ylabel(<span class="st">"가중치"</span>)
axes[<span class="nu">0</span>].set_title(<span class="st">"SMA vs EMA 가중치 분포"</span>)
axes[<span class="nu">0</span>].legend()
axes[<span class="nu">0</span>].grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)

<span class="cm"># 패널 2: 급등 시나리오에서 반응 속도 비교</span>
np.random.seed(<span class="nu">42</span>)
prices = np.concatenate([
    np.random.normal(<span class="nu">100</span>, <span class="nu">2</span>, <span class="nu">40</span>),  <span class="cm"># 40일간 안정</span>
    np.linspace(<span class="nu">100</span>, <span class="nu">120</span>, <span class="nu">10</span>),     <span class="cm"># 10일간 급등</span>
    np.random.normal(<span class="nu">120</span>, <span class="nu">2</span>, <span class="nu">20</span>)   <span class="cm"># 20일간 안정</span>
])
prices_series = pd.Series(prices)

sma_20 = prices_series.rolling(<span class="nu">20</span>).mean()
ema_20 = prices_series.ewm(span=<span class="nu">20</span>).mean()

axes[<span class="nu">1</span>].plot(prices_series, color=<span class="st">"gray"</span>, alpha=<span class="nu">0.5</span>, label=<span class="st">"가격"</span>)
axes[<span class="nu">1</span>].plot(sma_20, color=<span class="st">"steelblue"</span>, linewidth=<span class="nu">2</span>, label=<span class="st">"SMA(20)"</span>)
axes[<span class="nu">1</span>].plot(ema_20, color=<span class="st">"coral"</span>, linewidth=<span class="nu">2</span>, label=<span class="st">"EMA(20)"</span>)
axes[<span class="nu">1</span>].axvspan(<span class="nu">40</span>, <span class="nu">50</span>, alpha=<span class="nu">0.1</span>, color=<span class="st">"red"</span>, label=<span class="st">"급등 구간"</span>)
axes[<span class="nu">1</span>].set_title(<span class="st">"급등 시 반응 속도 비교"</span>)
axes[<span class="nu">1</span>].legend(fontsize=<span class="nu">9</span>)
axes[<span class="nu">1</span>].grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)

<span class="cm"># 패널 3: 누적 가중치 (최근 N일이 전체의 몇 %를 차지하는가)</span>
sma_cumw = np.cumsum(sma_weights)
ema_cumw = np.cumsum(ema_weights)
axes[<span class="nu">2</span>].plot(days_ago, sma_cumw, <span class="st">"o-"</span>, color=<span class="st">"steelblue"</span>, label=<span class="st">"SMA 누적"</span>)
axes[<span class="nu">2</span>].plot(days_ago, ema_cumw, <span class="st">"s-"</span>, color=<span class="st">"coral"</span>, label=<span class="st">"EMA 누적"</span>)
axes[<span class="nu">2</span>].axhline(y=<span class="nu">0.5</span>, color=<span class="st">"gray"</span>, linestyle=<span class="st">"--"</span>, alpha=<span class="nu">0.5</span>)
axes[<span class="nu">2</span>].set_xlabel(<span class="st">"며칠 전"</span>)
axes[<span class="nu">2</span>].set_ylabel(<span class="st">"누적 가중치"</span>)
axes[<span class="nu">2</span>].set_title(<span class="st">"누적 가중치 (50% 도달 속도)"</span>)
axes[<span class="nu">2</span>].legend()
axes[<span class="nu">2</span>].grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)
axes[<span class="nu">2</span>].annotate(<span class="st">"SMA: 10일째 50%"</span>, xy=(<span class="nu">10</span>, <span class="nu">0.5</span>), fontsize=<span class="nu">9</span>, color=<span class="st">"steelblue"</span>)
axes[<span class="nu">2</span>].annotate(<span class="st">"EMA: 6일째 50%"</span>, xy=(<span class="nu">6</span>, <span class="nu">0.5</span>), fontsize=<span class="nu">9</span>, color=<span class="st">"coral"</span>)

plt.tight_layout()
plt.show()

<span class="fn">print</span>(<span class="st">"=== 핵심 차이 ==="</span>)
<span class="fn">print</span>(<span class="st">f"SMA: 최근 1일 가중치 = </span>{sma_weights[0]:.3f}<span class="st"> (5.0%)"</span>)
<span class="fn">print</span>(<span class="st">f"EMA: 최근 1일 가중치 = </span>{ema_weights[0]:.3f}<span class="st"> (</span>{ema_weights[0]*100:.1f}<span class="st">%)"</span>)
<span class="fn">print</span>(<span class="st">f"→ EMA는 오늘 가격에 SMA 대비 </span>{ema_weights[0]/sma_weights[0]:.1f}<span class="st">배 더 큰 가중치!"</span>)
<span class="fn">print</span>(<span class="st">f"\nSMA: 20일 전 가중치 = </span>{sma_weights[-1]:.3f}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"EMA: 20일 전 가중치 = </span>{ema_weights[-1]:.3f}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"→ EMA는 오래된 데이터를 빠르게 '잊는다'"</span>)</code></pre>

<div class="info">
<p class="ni"><strong>실전 선택 가이드:</strong></p>
<ul>
<li><strong>SMA:</strong> 장기 추세 확인, 지지/저항선 분석. 노이즈에 덜 민감하여 안정적.</li>
<li><strong>EMA:</strong> 단기 매매 신호, MACD 계산, 빠른 추세 전환 감지. HFT에서 선호.</li>
<li><strong>ML 피처로는:</strong> 둘 다 넣어도 된다. 모델이 알아서 유용한 것을 선택한다. 다만 SMA(20)과 EMA(20)의 상관이 매우 높으므로(0.95+), 다중공선성이 걱정되면 하나만 선택.</li>
</ul>
</div>

<h3>8.3 이동평균 기반 피처</h3>
<p>이동평균 자체보다는, 이동평균에서 파생된 피처가 ML에 더 유용하다.</p>

<pre><code><span class="cm"># 이동평균 기반 피처들</span>
features = pd.DataFrame(index=close_series.index)

<span class="cm"># 1. 가격 대비 이동평균 비율 (Price/SMA ratio)</span>
<span class="cm"># "현재 가격이 이동평균 대비 얼마나 높은가/낮은가"</span>
features[<span class="st">"price_sma20_ratio"</span>] = close_series / sma_20
features[<span class="st">"price_sma60_ratio"</span>] = close_series / sma_60

<span class="cm"># 2. 골든크로스/데드크로스 신호</span>
<span class="cm"># 단기 이동평균이 장기 이동평균 위에 있으면 1, 아래면 0</span>
features[<span class="st">"golden_cross"</span>] = (sma_20 > sma_60).astype(<span class="nb">int</span>)

<span class="cm"># 3. 이동평균 기울기 (추세의 강도)</span>
features[<span class="st">"sma20_slope"</span>] = sma_20.pct_change(<span class="nu">5</span>)  <span class="cm"># 5일간 SMA20의 변화율</span>

<span class="cm"># 4. 이동평균 간 거리 (추세의 강도)</span>
features[<span class="st">"sma_spread"</span>] = (sma_20 - sma_60) / sma_60

<span class="fn">print</span>(<span class="st">"=== 이동평균 기반 피처 ==="</span>)
<span class="fn">print</span>(features.dropna().tail(<span class="nu">10</span>).round(<span class="nu">4</span>))</code></pre>

<h3>8.4 RSI (Relative Strength Index) — 과매수/과매도 지표</h3>
<p>RSI는 "최근 n일 동안 상승한 날의 평균 상승폭 대비, 하락한 날의 평균 하락폭이 얼마인가"를 0~100 사이의 숫자로 표현한다. 70 이상이면 과매수(너무 많이 올랐다), 30 이하면 과매도(너무 많이 떨어졌다)로 해석한다.</p>

<div class="eq">\[ \text{RSI} = 100 - \frac{100}{1 + RS}, \quad RS = \frac{\text{평균 상승폭}}{\text{평균 하락폭}} \]</div>

<p>RSI의 직관: 최근 14일 중 매일 올랐다면 RS = ∞이므로 RSI = 100이다. 매일 떨어졌다면 RS = 0이므로 RSI = 0이다. 반반이면 RSI ≈ 50이다.</p>

<pre><code><span class="kw">def</span> <span class="fn">calculate_rsi</span>(prices, period=<span class="nu">14</span>):
    <span class="st">"""RSI를 직접 구현한다"""</span>
    <span class="cm"># 1. 일간 변화량</span>
    delta = prices.diff()
    
    <span class="cm"># 2. 상승분과 하락분 분리</span>
    gain = delta.where(delta > <span class="nu">0</span>, <span class="nu">0</span>)   <span class="cm"># 상승한 날만 (나머지 0)</span>
    loss = -delta.where(delta < <span class="nu">0</span>, <span class="nu">0</span>)  <span class="cm"># 하락한 날만 (양수로 변환)</span>
    
    <span class="cm"># 3. 평균 상승폭 / 평균 하락폭 (EMA 사용)</span>
    avg_gain = gain.ewm(alpha=<span class="nu">1</span>/period, min_periods=period).mean()
    avg_loss = loss.ewm(alpha=<span class="nu">1</span>/period, min_periods=period).mean()
    
    <span class="cm"># 4. RS와 RSI 계산</span>
    rs = avg_gain / avg_loss
    rsi = <span class="nu">100</span> - (<span class="nu">100</span> / (<span class="nu">1</span> + rs))
    
    <span class="kw">return</span> rsi

<span class="cm"># RSI 계산</span>
rsi_14 = calculate_rsi(close_series, period=<span class="nu">14</span>)

<span class="cm"># 시각화</span>
fig, axes = plt.subplots(<span class="nu">2</span>, <span class="nu">1</span>, figsize=(<span class="nu">14</span>, <span class="nu">8</span>), gridspec_kw={<span class="st">"height_ratios"</span>: [<span class="nu">2</span>, <span class="nu">1</span>]})

<span class="cm"># 상단: 주가</span>
axes[<span class="nu">0</span>].plot(close_series.index, close_series.values, color=<span class="st">"black"</span>, linewidth=<span class="nu">1</span>)
axes[<span class="nu">0</span>].set_title(<span class="st">"삼성전자 주가"</span>)
axes[<span class="nu">0</span>].grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)

<span class="cm"># 하단: RSI</span>
axes[<span class="nu">1</span>].plot(rsi_14.index, rsi_14.values, color=<span class="st">"purple"</span>, linewidth=<span class="nu">1</span>)
axes[<span class="nu">1</span>].axhline(y=<span class="nu">70</span>, color=<span class="st">"red"</span>, linestyle=<span class="st">"--"</span>, alpha=<span class="nu">0.7</span>, label=<span class="st">"과매수 (70)"</span>)
axes[<span class="nu">1</span>].axhline(y=<span class="nu">30</span>, color=<span class="st">"green"</span>, linestyle=<span class="st">"--"</span>, alpha=<span class="nu">0.7</span>, label=<span class="st">"과매도 (30)"</span>)
axes[<span class="nu">1</span>].axhline(y=<span class="nu">50</span>, color=<span class="st">"gray"</span>, linestyle=<span class="st">":"</span>, alpha=<span class="nu">0.5</span>)
axes[<span class="nu">1</span>].fill_between(rsi_14.index, rsi_14.values, <span class="nu">70</span>,
                     where=(rsi_14.values > <span class="nu">70</span>), color=<span class="st">"red"</span>, alpha=<span class="nu">0.2</span>)
axes[<span class="nu">1</span>].fill_between(rsi_14.index, rsi_14.values, <span class="nu">30</span>,
                     where=(rsi_14.values < <span class="nu">30</span>), color=<span class="st">"green"</span>, alpha=<span class="nu">0.2</span>)
axes[<span class="nu">1</span>].set_title(<span class="st">"RSI (14)"</span>)
axes[<span class="nu">1</span>].set_ylim(<span class="nu">0</span>, <span class="nu">100</span>)
axes[<span class="nu">1</span>].legend()
axes[<span class="nu">1</span>].grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)

plt.tight_layout()
plt.show()</code></pre>

<h3>8.5 MACD (Moving Average Convergence Divergence)</h3>
<p>MACD는 두 개의 EMA(지수이동평균) 차이를 이용하여 추세의 방향과 강도를 측정하는 지표다. 가장 널리 사용되는 기술적 지표 중 하나다.</p>

<p>MACD의 구성 요소:</p>
<ul>
<li><strong>MACD Line:</strong> EMA(12) - EMA(26) — 단기 추세와 장기 추세의 차이</li>
<li><strong>Signal Line:</strong> MACD Line의 EMA(9) — MACD의 이동평균</li>
<li><strong>Histogram:</strong> MACD Line - Signal Line — 추세 강도의 변화</li>
</ul>

<pre><code><span class="kw">def</span> <span class="fn">calculate_macd</span>(prices, fast=<span class="nu">12</span>, slow=<span class="nu">26</span>, signal=<span class="nu">9</span>):
    <span class="st">"""MACD를 직접 구현한다"""</span>
    ema_fast = prices.ewm(span=fast).mean()
    ema_slow = prices.ewm(span=slow).mean()
    
    macd_line = ema_fast - ema_slow
    signal_line = macd_line.ewm(span=signal).mean()
    histogram = macd_line - signal_line
    
    <span class="kw">return</span> macd_line, signal_line, histogram

macd_line, signal_line, histogram = calculate_macd(close_series)

<span class="cm"># 시각화</span>
fig, axes = plt.subplots(<span class="nu">2</span>, <span class="nu">1</span>, figsize=(<span class="nu">14</span>, <span class="nu">8</span>), gridspec_kw={<span class="st">"height_ratios"</span>: [<span class="nu">2</span>, <span class="nu">1</span>]})

<span class="cm"># 상단: 주가</span>
axes[<span class="nu">0</span>].plot(close_series.index, close_series.values, color=<span class="st">"black"</span>, linewidth=<span class="nu">1</span>)
axes[<span class="nu">0</span>].set_title(<span class="st">"삼성전자 주가"</span>)
axes[<span class="nu">0</span>].grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)

<span class="cm"># 하단: MACD</span>
axes[<span class="nu">1</span>].plot(macd_line.index, macd_line.values, color=<span class="st">"blue"</span>, linewidth=<span class="nu">1</span>, label=<span class="st">"MACD"</span>)
axes[<span class="nu">1</span>].plot(signal_line.index, signal_line.values, color=<span class="st">"red"</span>, linewidth=<span class="nu">1</span>, label=<span class="st">"Signal"</span>)
colors = [<span class="st">"green"</span> <span class="kw">if</span> v >= <span class="nu">0</span> <span class="kw">else</span> <span class="st">"red"</span> <span class="kw">for</span> v <span class="kw">in</span> histogram.values]
axes[<span class="nu">1</span>].bar(histogram.index, histogram.values, color=colors, alpha=<span class="nu">0.5</span>, width=<span class="nu">1</span>)
axes[<span class="nu">1</span>].axhline(y=<span class="nu">0</span>, color=<span class="st">"gray"</span>, linestyle=<span class="st">"-"</span>, linewidth=<span class="nu">0.5</span>)
axes[<span class="nu">1</span>].set_title(<span class="st">"MACD (12, 26, 9)"</span>)
axes[<span class="nu">1</span>].legend()
axes[<span class="nu">1</span>].grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)

plt.tight_layout()
plt.show()</code></pre>

<p>MACD를 ML 피처로 사용할 때는 절대값보다 상대적 신호가 더 유용하다:</p>

<pre><code><span class="cm"># MACD 기반 피처</span>
features[<span class="st">"macd"</span>] = macd_line
features[<span class="st">"macd_signal"</span>] = signal_line
features[<span class="st">"macd_hist"</span>] = histogram
features[<span class="st">"macd_cross"</span>] = (macd_line > signal_line).astype(<span class="nb">int</span>)  <span class="cm"># 매수 신호</span>
features[<span class="st">"macd_hist_change"</span>] = histogram.diff()  <span class="cm"># 히스토그램 변화 방향</span></code></pre>

<h3>8.6 볼린저 밴드 (Bollinger Bands)</h3>
<p>볼린저 밴드는 이동평균 위아래로 표준편차의 n배만큼 밴드를 그린 것이다. 가격이 밴드 밖으로 나가면 "비정상적인 움직임"으로 해석한다. 변동성이 커지면 밴드가 넓어지고, 줄어들면 좁아진다.</p>

<div class="eq">\[ \text{Upper Band} = \text{SMA}_{20} + 2\sigma_{20} \]
\[ \text{Lower Band} = \text{SMA}_{20} - 2\sigma_{20} \]
\[ \text{%B} = \frac{P - \text{Lower}}{\text{Upper} - \text{Lower}} \]</div>

<pre><code><span class="kw">def</span> <span class="fn">calculate_bollinger</span>(prices, window=<span class="nu">20</span>, num_std=<span class="nu">2</span>):
    <span class="st">"""볼린저 밴드를 직접 구현한다"""</span>
    sma = prices.rolling(window=window).mean()
    std = prices.rolling(window=window).std()
    
    upper = sma + num_std * std
    lower = sma - num_std * std
    
    <span class="cm"># %B: 현재 가격이 밴드 내 어디에 있는가 (0=하단, 1=상단)</span>
    pct_b = (prices - lower) / (upper - lower)
    
    <span class="cm"># 밴드폭: 변동성의 proxy</span>
    bandwidth = (upper - lower) / sma
    
    <span class="kw">return</span> upper, lower, sma, pct_b, bandwidth

upper, lower, bb_sma, pct_b, bandwidth = calculate_bollinger(close_series)

<span class="cm"># 시각화</span>
fig, axes = plt.subplots(<span class="nu">3</span>, <span class="nu">1</span>, figsize=(<span class="nu">14</span>, <span class="nu">10</span>), gridspec_kw={<span class="st">"height_ratios"</span>: [<span class="nu">3</span>, <span class="nu">1</span>, <span class="nu">1</span>]})

<span class="cm"># 상단: 주가 + 볼린저 밴드</span>
axes[<span class="nu">0</span>].plot(close_series.index, close_series.values, color=<span class="st">"black"</span>, linewidth=<span class="nu">1</span>, label=<span class="st">"종가"</span>)
axes[<span class="nu">0</span>].plot(bb_sma.index, bb_sma.values, color=<span class="st">"blue"</span>, linewidth=<span class="nu">0.8</span>, label=<span class="st">"SMA 20"</span>)
axes[<span class="nu">0</span>].plot(upper.index, upper.values, color=<span class="st">"red"</span>, linewidth=<span class="nu">0.8</span>, linestyle=<span class="st">"--"</span>)
axes[<span class="nu">0</span>].plot(lower.index, lower.values, color=<span class="st">"green"</span>, linewidth=<span class="nu">0.8</span>, linestyle=<span class="st">"--"</span>)
axes[<span class="nu">0</span>].fill_between(upper.index, upper.values, lower.values, alpha=<span class="nu">0.1</span>, color=<span class="st">"blue"</span>)
axes[<span class="nu">0</span>].set_title(<span class="st">"볼린저 밴드 (20, 2)"</span>)
axes[<span class="nu">0</span>].legend()
axes[<span class="nu">0</span>].grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)

<span class="cm"># 중단: %B</span>
axes[<span class="nu">1</span>].plot(pct_b.index, pct_b.values, color=<span class="st">"purple"</span>, linewidth=<span class="nu">0.8</span>)
axes[<span class="nu">1</span>].axhline(y=<span class="nu">1</span>, color=<span class="st">"red"</span>, linestyle=<span class="st">"--"</span>, alpha=<span class="nu">0.5</span>)
axes[<span class="nu">1</span>].axhline(y=<span class="nu">0</span>, color=<span class="st">"green"</span>, linestyle=<span class="st">"--"</span>, alpha=<span class="nu">0.5</span>)
axes[<span class="nu">1</span>].set_title(<span class="st">"%B (0=하단, 1=상단)"</span>)
axes[<span class="nu">1</span>].grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)

<span class="cm"># 하단: 밴드폭</span>
axes[<span class="nu">2</span>].plot(bandwidth.index, bandwidth.values, color=<span class="st">"orange"</span>, linewidth=<span class="nu">0.8</span>)
axes[<span class="nu">2</span>].set_title(<span class="st">"밴드폭 (변동성 proxy)"</span>)
axes[<span class="nu">2</span>].grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)

plt.tight_layout()
plt.show()</code></pre>

<pre><code><span class="cm"># 볼린저 밴드 기반 피처</span>
features[<span class="st">"bb_pct_b"</span>] = pct_b
features[<span class="st">"bb_bandwidth"</span>] = bandwidth
features[<span class="st">"bb_squeeze"</span>] = (bandwidth < bandwidth.rolling(<span class="nu">120</span>).quantile(<span class="nu">0.1</span>)).astype(<span class="nb">int</span>)
<span class="cm"># 밴드폭이 최근 120일 중 하위 10%이면 "스퀴즈" — 큰 움직임 예고</span></code></pre>

<!-- ══ Plotly: 인터랙티브 캔들스틱 + RSI + MACD + 볼린저밴드 ══ -->
<div id="plot-ch8-candle" style="width:100%;height:600px;margin:25px 0"></div>
<p class="ni" style="font-size:12px;color:#888;text-align:center">🖱️ 캔들스틱 + 볼린저밴드 + SMA · 하단 패널: RSI(과매수/과매도) + MACD 히스토그램 · 드래그로 확대</p>
<script>
(function(){
  function mulberry32(a){return function(){a|=0;a=a+0x6D2B79F5|0;var t=Math.imul(a^a>>>15,1|a);t=t+Math.imul(t^t>>>7,61|t)^t;return((t^t>>>14)>>>0)/4294967296}}
  var rng=mulberry32(2024);
  function randn(){var u=0,v=0;while(u===0)u=rng();while(v===0)v=rng();return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v)}

  var N=180; // 180 거래일
  var dates=[],open=[],high=[],low=[],close=[];
  var d=new Date(2024,0,2);
  var p=70000; // 시작가
  for(var i=0;i<N;i++){
    dates.push(new Date(d));
    var ret=0.0002+randn()*0.018;
    if(i>60&&i<90)ret-=0.003; // 하락 구간
    if(i>120&&i<150)ret+=0.004; // 상승 구간
    var o=p,c=p*(1+ret);
    var h=Math.max(o,c)*(1+Math.abs(randn()*0.008));
    var l=Math.min(o,c)*(1-Math.abs(randn()*0.008));
    open.push(Math.round(o));close.push(Math.round(c));
    high.push(Math.round(h));low.push(Math.round(l));
    p=c;
    d.setDate(d.getDate()+(d.getDay()===5?3:1));
  }

  // SMA 20, 60
  function sma(arr,w){var r=[];for(var i=0;i<arr.length;i++){if(i<w-1){r.push(null)}else{var s=0;for(var j=0;j<w;j++)s+=arr[i-j];r.push(s/w)}}return r}
  var sma20=sma(close,20),sma60=sma(close,60);

  // 볼린저밴드
  var bbU=[],bbL=[];
  for(var i=0;i<N;i++){
    if(i<19){bbU.push(null);bbL.push(null);continue}
    var s=0,ss=0;
    for(var j=0;j<20;j++){s+=close[i-j];ss+=close[i-j]*close[i-j]}
    var m=s/20,sd=Math.sqrt(ss/20-m*m);
    bbU.push(m+2*sd);bbL.push(m-2*sd);
  }

  // RSI 14
  var rsi=[];
  for(var i=0;i<N;i++){
    if(i<14){rsi.push(null);continue}
    var ag=0,al=0;
    for(var j=1;j<=14;j++){
      var diff=close[i-14+j]-close[i-14+j-1];
      if(diff>0)ag+=diff;else al-=diff;
    }
    ag/=14;al/=14;
    rsi.push(al===0?100:100-100/(1+ag/al));
  }

  // MACD
  function ema(arr,span){var k=2/(span+1),r=[arr[0]];for(var i=1;i<arr.length;i++)r.push(arr[i]*k+r[i-1]*(1-k));return r}
  var ema12=ema(close,12),ema26=ema(close,26);
  var macd=[],macdSig,macdHist=[];
  for(var i=0;i<N;i++)macd.push(ema12[i]-ema26[i]);
  macdSig=ema(macd,9);
  for(var i=0;i<N;i++)macdHist.push(macd[i]-macdSig[i]);

  // 캔들스틱 + 볼린저 + SMA (상단 70%)
  var trace1={x:dates,open:open,high:high,low:low,close:close,type:'candlestick',name:'캔들스틱',
    increasing:{line:{color:'#e74c3c'}},decreasing:{line:{color:'#3498db'}},yaxis:'y'};
  var trace2={x:dates,y:sma20,mode:'lines',name:'SMA 20',line:{color:'#f39c12',width:1.5},yaxis:'y'};
  var trace3={x:dates,y:sma60,mode:'lines',name:'SMA 60',line:{color:'#9b59b6',width:1.5},yaxis:'y'};
  var trace4={x:dates,y:bbU,mode:'lines',name:'BB Upper',line:{color:'#95a5a6',width:1,dash:'dot'},yaxis:'y'};
  var trace5={x:dates,y:bbL,mode:'lines',name:'BB Lower',line:{color:'#95a5a6',width:1,dash:'dot'},showlegend:false,yaxis:'y'};

  // RSI (중단 15%)
  var trace6={x:dates,y:rsi,mode:'lines',name:'RSI 14',line:{color:'#8e44ad',width:1.5},yaxis:'y2'};

  // MACD 히스토그램 (하단 15%)
  var histColors=macdHist.map(function(v){return v>=0?'rgba(46,204,113,0.7)':'rgba(231,76,60,0.7)'});
  var trace7={x:dates,y:macdHist,type:'bar',name:'MACD Hist',marker:{color:histColors},yaxis:'y3'};
  var trace8={x:dates,y:macd,mode:'lines',name:'MACD',line:{color:'#2980b9',width:1.2},yaxis:'y3'};
  var trace9={x:dates,y:macdSig,mode:'lines',name:'Signal',line:{color:'#e67e22',width:1.2,dash:'dash'},yaxis:'y3'};

  Plotly.newPlot('plot-ch8-candle',[trace1,trace2,trace3,trace4,trace5,trace6,trace7,trace8,trace9],{
    title:{text:'📊 삼성전자 시뮬레이션: 캔들스틱 + 볼린저밴드 + RSI + MACD',font:{size:14}},
    xaxis:{rangeslider:{visible:false},gridcolor:'#eee'},
    yaxis:{domain:[0.38,1],title:'주가 (원)',gridcolor:'#eee'},
    yaxis2:{domain:[0.2,0.35],title:'RSI',gridcolor:'#eee',range:[0,100],
      shapes:[{type:'line',y0:70,y1:70,x0:0,x1:1,xref:'paper',line:{color:'red',width:1,dash:'dot'}},
              {type:'line',y0:30,y1:30,x0:0,x1:1,xref:'paper',line:{color:'green',width:1,dash:'dot'}}]},
    yaxis3:{domain:[0,0.17],title:'MACD',gridcolor:'#eee'},
    legend:{orientation:'h',y:-0.08,font:{size:10}},
    plot_bgcolor:'#fafafa',paper_bgcolor:'#fff',
    margin:{t:50,b:50,l:60,r:20},
    shapes:[
      {type:'line',yref:'y2',y0:70,y1:70,xref:'paper',x0:0,x1:1,line:{color:'#e74c3c',width:1,dash:'dot'}},
      {type:'line',yref:'y2',y0:30,y1:30,xref:'paper',x0:0,x1:1,line:{color:'#27ae60',width:1,dash:'dot'}}
    ]
  },{responsive:true});
})();
</script>

<!-- ═══════════════════════════════════════════ -->
<!-- Ch9: 변동성 & 모멘텀 피처 -->
<!-- ═══════════════════════════════════════════ -->
<h2 id="ch9">9. 변동성 &amp; 모멘텀 피처 — 위험과 추세를 수치화하다</h2>

<h3>9.1 변동성 피처</h3>
<p>변동성(volatility)은 "가격이 얼마나 크게 흔들리는가"를 측정한다. 변동성이 높으면 위험이 크고, 낮으면 안정적이다. 변동성은 그 자체로 중요한 피처이며, 변동성의 변화(변동성이 커지고 있는가, 줄어들고 있는가)도 강력한 예측 신호다.</p>

<h4>9.1.1 역사적 변동성 (Historical Volatility)</h4>
<pre><code><span class="cm"># 수익률 계산</span>
ret = close_series.pct_change().dropna()

<span class="cm"># 1. 롤링 변동성 (다양한 윈도우)</span>
vol_5 = ret.rolling(<span class="nu">5</span>).std() * np.sqrt(<span class="nu">252</span>)    <span class="cm"># 5일 변동성 (연환산)</span>
vol_20 = ret.rolling(<span class="nu">20</span>).std() * np.sqrt(<span class="nu">252</span>)  <span class="cm"># 20일 변동성</span>
vol_60 = ret.rolling(<span class="nu">60</span>).std() * np.sqrt(<span class="nu">252</span>)  <span class="cm"># 60일 변동성</span>

<span class="cm"># 2. 변동성 비율 (단기/장기) — 변동성 레짐 변화 감지</span>
vol_ratio = vol_5 / vol_60  <span class="cm"># > 1이면 최근 변동성 증가</span>

<span class="cm"># 3. Parkinson 변동성 (고가-저가 기반, 더 정확)</span>
high = samsung_df[<span class="st">"High"</span>].squeeze()
low = samsung_df[<span class="st">"Low"</span>].squeeze()
parkinson = np.sqrt(
    (<span class="nu">1</span> / (<span class="nu">4</span> * np.log(<span class="nu">2</span>))) * (np.log(high / low) ** <span class="nu">2</span>).rolling(<span class="nu">20</span>).mean()
) * np.sqrt(<span class="nu">252</span>)

<span class="cm"># 시각화</span>
fig, ax = plt.subplots(figsize=(<span class="nu">14</span>, <span class="nu">5</span>))
ax.plot(vol_5.index, vol_5.values, label=<span class="st">"5일 변동성"</span>, alpha=<span class="nu">0.6</span>)
ax.plot(vol_20.index, vol_20.values, label=<span class="st">"20일 변동성"</span>, linewidth=<span class="nu">1.5</span>)
ax.plot(vol_60.index, vol_60.values, label=<span class="st">"60일 변동성"</span>, linewidth=<span class="nu">2</span>)
ax.set_title(<span class="st">"삼성전자 역사적 변동성 (연환산)"</span>)
ax.set_ylabel(<span class="st">"변동성"</span>)
ax.legend()
ax.grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)
plt.tight_layout()
plt.show()</code></pre>

<div class="info">
<p class="ni"><strong>왜 √252를 곱하는가?</strong> 일간 변동성을 연간 변동성으로 환산하기 위해서다. 1년에 약 252 거래일이 있고, 변동성(표준편차)은 √시간에 비례하여 증가한다. 따라서 일간 변동성 × √252 = 연간 변동성이다. 이것은 Round 2에서 배운 정규분포의 성질에서 나온다.</p>
</div>

<!-- ── 보충 9.1+ Parkinson 변동성 직관적 설명 ── -->
<div class="def">
<p class="ni"><strong>🔍 보충: Parkinson 변동성 — 왜 고가-저가가 종가보다 더 정확한가</strong></p>
<p class="ni">일반적인 역사적 변동성은 종가(Close)만 사용한다. 하지만 하루 동안 주가가 ±5% 왔다 갔다 해도 종가가 전일과 같으면 변동성이 0으로 계산된다. Parkinson 변동성은 고가(High)와 저가(Low)를 사용하여 장중 변동을 포착한다. 이론적으로 종가 기반 대비 약 5배 더 효율적이다.</p>
</div>

<pre><code><span class="cm"># === Parkinson 변동성 vs 종가 기반 변동성 비교 ===</span>
<span class="kw">import</span> numpy <span class="kw">as</span> np
<span class="kw">import</span> pandas <span class="kw">as</span> pd

<span class="cm"># 시나리오: 종가는 같지만 장중 변동이 다른 두 종목</span>
np.random.seed(<span class="nu">42</span>)
n_days = <span class="nu">20</span>

<span class="cm"># 종목 A: 장중 변동이 큰 종목 (고가-저가 차이 큼)</span>
close_A = np.full(n_days, <span class="nu">100.0</span>)  <span class="cm"># 종가가 매일 100원 (변동 없어 보임)</span>
high_A = close_A + np.random.uniform(<span class="nu">3</span>, <span class="nu">8</span>, n_days)   <span class="cm"># 고가: 103~108</span>
low_A = close_A - np.random.uniform(<span class="nu">3</span>, <span class="nu">8</span>, n_days)    <span class="cm"># 저가: 92~97</span>

<span class="cm"># 종목 B: 장중 변동이 작은 종목</span>
close_B = np.full(n_days, <span class="nu">100.0</span>)  <span class="cm"># 종가가 매일 100원 (역시 변동 없어 보임)</span>
high_B = close_B + np.random.uniform(<span class="nu">0.5</span>, <span class="nu">1.5</span>, n_days)  <span class="cm"># 고가: 100.5~101.5</span>
low_B = close_B - np.random.uniform(<span class="nu">0.5</span>, <span class="nu">1.5</span>, n_days)   <span class="cm"># 저가: 98.5~99.5</span>

<span class="cm"># 종가 기반 변동성 (Close-to-Close)</span>
vol_close_A = pd.Series(close_A).pct_change().std() * np.sqrt(<span class="nu">252</span>)
vol_close_B = pd.Series(close_B).pct_change().std() * np.sqrt(<span class="nu">252</span>)

<span class="cm"># Parkinson 변동성</span>
<span class="kw">def</span> <span class="fn">parkinson_vol</span>(high, low, window=<span class="nu">20</span>):
    <span class="st">"""Parkinson 변동성 계산"""</span>
    log_hl = np.log(high / low) ** <span class="nu">2</span>
    <span class="kw">return</span> np.sqrt(log_hl.mean() / (<span class="nu">4</span> * np.log(<span class="nu">2</span>))) * np.sqrt(<span class="nu">252</span>)

vol_park_A = parkinson_vol(high_A, low_A)
vol_park_B = parkinson_vol(high_B, low_B)

<span class="fn">print</span>(<span class="st">"=== 종가 기반 vs Parkinson 변동성 ==="</span>)
<span class="fn">print</span>(<span class="st">f"종목 A (장중 변동 큼):"</span>)
<span class="fn">print</span>(<span class="st">f"  종가 변동성: </span>{vol_close_A:.4f}<span class="st"> (≈ 0! 종가가 매일 같으니까)"</span>)
<span class="fn">print</span>(<span class="st">f"  Parkinson:   </span>{vol_park_A:.4f}<span class="st"> (장중 변동을 포착!)"</span>)
<span class="fn">print</span>(<span class="st">f"\n종목 B (장중 변동 작음):"</span>)
<span class="fn">print</span>(<span class="st">f"  종가 변동성: </span>{vol_close_B:.4f}<span class="st"> (≈ 0)"</span>)
<span class="fn">print</span>(<span class="st">f"  Parkinson:   </span>{vol_park_B:.4f}<span class="st"> (작은 변동도 감지)"</span>)
<span class="fn">print</span>(<span class="st">f"\n→ 종가 기반: A와 B의 변동성이 거의 같아 보임 (둘 다 ≈ 0)"</span>)
<span class="fn">print</span>(<span class="st">f"→ Parkinson: A가 B보다 </span>{vol_park_A/vol_park_B:.1f}<span class="st">배 변동성이 큼 (정확!)"</span>)
<span class="fn">print</span>(<span class="st">f"\n💡 Parkinson 공식의 핵심:"</span>)
<span class="fn">print</span>(<span class="st">f"   σ_P = √(1/(4·ln2) · E[ln(H/L)²]) · √252"</span>)
<span class="fn">print</span>(<span class="st">f"   → ln(H/L)이 클수록 장중 변동이 크다는 뜻"</span>)
<span class="fn">print</span>(<span class="st">f"   → 1/(4·ln2) ≈ 0.361은 정규분포 가정 하의 보정 상수"</span>)</code></pre>

<div class="info">
<p class="ni"><strong>Parkinson 변동성의 한계:</strong> 장중 고가/저가만 사용하므로, 갭(gap) — 전일 종가와 당일 시가의 차이 — 을 반영하지 못한다. 갭까지 반영하려면 Garman-Klass 변동성이나 Yang-Zhang 변동성을 사용한다. 하지만 실전에서는 Parkinson만으로도 충분히 유용하다.</p>
</div>

<h4>9.1.2 ATR (Average True Range)</h4>
<p>ATR은 "진정한 변동 범위"의 평균이다. 고가-저가뿐 아니라 전일 종가와의 갭도 고려하여 변동성을 더 정확하게 측정한다.</p>

<pre><code><span class="kw">def</span> <span class="fn">calculate_atr</span>(high, low, close, period=<span class="nu">14</span>):
    <span class="st">"""ATR을 직접 구현한다"""</span>
    <span class="cm"># True Range: 세 가지 중 최대값</span>
    tr1 = high - low                    <span class="cm"># 당일 고가 - 저가</span>
    tr2 = (high - close.shift(<span class="nu">1</span>)).abs()  <span class="cm"># 당일 고가 - 전일 종가</span>
    tr3 = (low - close.shift(<span class="nu">1</span>)).abs()   <span class="cm"># 당일 저가 - 전일 종가</span>
    
    true_range = pd.concat([tr1, tr2, tr3], axis=<span class="nu">1</span>).max(axis=<span class="nu">1</span>)
    atr = true_range.rolling(window=period).mean()
    
    <span class="kw">return</span> atr, true_range

atr_14, tr = calculate_atr(high, low, close_series)

<span class="cm"># ATR 기반 피처</span>
features[<span class="st">"atr_14"</span>] = atr_14
features[<span class="st">"atr_ratio"</span>] = atr_14 / close_series  <span class="cm"># 가격 대비 ATR (상대적 변동성)</span></code></pre>

<h3>9.2 모멘텀 피처</h3>
<p>모멘텀(momentum)은 "최근에 올랐으면 계속 오르고, 떨어졌으면 계속 떨어지는" 경향을 수치화한 것이다. 금융에서 가장 강력하고 지속적인 이상현상(anomaly) 중 하나다. Jegadeesh & Titman(1993)이 발견한 이후 30년 넘게 유효성이 확인되고 있다.</p>

<pre><code><span class="cm"># 모멘텀 피처들</span>

<span class="cm"># 1. 단순 수익률 모멘텀 (다양한 기간)</span>
features[<span class="st">"mom_5d"</span>] = close_series.pct_change(<span class="nu">5</span>)    <span class="cm"># 5일 수익률</span>
features[<span class="st">"mom_20d"</span>] = close_series.pct_change(<span class="nu">20</span>)  <span class="cm"># 20일 (1달) 수익률</span>
features[<span class="st">"mom_60d"</span>] = close_series.pct_change(<span class="nu">60</span>)  <span class="cm"># 60일 (3달) 수익률</span>
features[<span class="st">"mom_120d"</span>] = close_series.pct_change(<span class="nu">120</span>) <span class="cm"># 120일 (6달) 수익률</span>
features[<span class="st">"mom_250d"</span>] = close_series.pct_change(<span class="nu">250</span>) <span class="cm"># 250일 (1년) 수익률</span>

<span class="cm"># 2. 모멘텀 가속도 (모멘텀의 변화)</span>
<span class="cm"># "상승 속도가 빨라지고 있는가, 느려지고 있는가"</span>
features[<span class="st">"mom_accel"</span>] = features[<span class="st">"mom_20d"</span>] - features[<span class="st">"mom_20d"</span>].shift(<span class="nu">20</span>)

<span class="cm"># 3. 52주 최고가 대비 비율</span>
high_52w = close_series.rolling(<span class="nu">252</span>).max()
features[<span class="st">"pct_from_52w_high"</span>] = close_series / high_52w - <span class="nu">1</span>
<span class="cm"># 0이면 52주 최고가, -0.2이면 최고가 대비 20% 하락</span>

<span class="cm"># 4. 52주 최저가 대비 비율</span>
low_52w = close_series.rolling(<span class="nu">252</span>).min()
features[<span class="st">"pct_from_52w_low"</span>] = close_series / low_52w - <span class="nu">1</span>

<span class="fn">print</span>(<span class="st">"=== 모멘텀 피처 ==="</span>)
<span class="fn">print</span>(features[[<span class="st">"mom_5d"</span>, <span class="st">"mom_20d"</span>, <span class="st">"mom_60d"</span>, <span class="st">"pct_from_52w_high"</span>]].dropna().tail(<span class="nu">10</span>).round(<span class="nu">4</span>))</code></pre>

<h3>9.3 거래량 피처</h3>
<p>거래량(volume)은 "얼마나 많은 사람이 거래에 참여했는가"를 보여준다. 가격 변동에 거래량이 동반되면 그 움직임이 "진짜"일 가능성이 높다. 거래량 없이 가격만 오르면 "가짜 상승"일 수 있다.</p>

<pre><code>volume = samsung_df[<span class="st">"Volume"</span>].squeeze()

<span class="cm"># 1. 거래량 이동평균 대비 비율</span>
vol_ma20 = volume.rolling(<span class="nu">20</span>).mean()
features[<span class="st">"volume_ratio"</span>] = volume / vol_ma20
<span class="cm"># > 1이면 평소보다 거래량 많음, < 1이면 적음</span>

<span class="cm"># 2. OBV (On-Balance Volume) — 누적 거래량 방향</span>
<span class="kw">def</span> <span class="fn">calculate_obv</span>(close, volume):
    <span class="st">"""OBV: 상승일 거래량은 더하고, 하락일 거래량은 빼는 누적값"""</span>
    direction = np.sign(close.diff())
    obv = (direction * volume).cumsum()
    <span class="kw">return</span> obv

obv = calculate_obv(close_series, volume)
features[<span class="st">"obv"</span>] = obv
features[<span class="st">"obv_slope"</span>] = obv.pct_change(<span class="nu">20</span>)  <span class="cm"># OBV의 20일 변화율</span>

<span class="cm"># 3. VWAP (Volume Weighted Average Price)</span>
<span class="cm"># 거래량 가중 평균 가격 — 기관투자자의 기준 가격</span>
typical_price = (high + low + close_series) / <span class="nu">3</span>
vwap_20 = (typical_price * volume).rolling(<span class="nu">20</span>).sum() / volume.rolling(<span class="nu">20</span>).sum()
features[<span class="st">"price_vwap_ratio"</span>] = close_series / vwap_20

<span class="cm"># 4. 거래량 변동성</span>
features[<span class="st">"volume_volatility"</span>] = volume.rolling(<span class="nu">20</span>).std() / vol_ma20

<span class="fn">print</span>(<span class="st">"=== 거래량 피처 ==="</span>)
<span class="fn">print</span>(features[[<span class="st">"volume_ratio"</span>, <span class="st">"obv_slope"</span>, <span class="st">"price_vwap_ratio"</span>]].dropna().tail(<span class="nu">10</span>).round(<span class="nu">4</span>))</code></pre>

<div class="tc">Table 7. 기술적 지표 피처 총정리</div>
<table>
<tr><th>카테고리</th><th>피처</th><th>의미</th><th>범위</th></tr>
<tr><td rowspan="4">추세</td><td>price_sma20_ratio</td><td>가격/SMA20 비율</td><td>0.8~1.2</td></tr>
<tr><td>golden_cross</td><td>SMA20 > SMA60 여부</td><td>0 or 1</td></tr>
<tr><td>macd_hist</td><td>MACD 히스토그램</td><td>(-∞, +∞)</td></tr>
<tr><td>sma20_slope</td><td>SMA20 기울기</td><td>(-∞, +∞)</td></tr>
<tr><td rowspan="3">과매수/과매도</td><td>rsi_14</td><td>RSI (14일)</td><td>[0, 100]</td></tr>
<tr><td>bb_pct_b</td><td>볼린저 %B</td><td>[0, 1] 근처</td></tr>
<tr><td>bb_squeeze</td><td>밴드 수축 여부</td><td>0 or 1</td></tr>
<tr><td rowspan="3">변동성</td><td>vol_20</td><td>20일 변동성 (연환산)</td><td>[0, +∞)</td></tr>
<tr><td>atr_ratio</td><td>ATR/가격 비율</td><td>[0, +∞)</td></tr>
<tr><td>bb_bandwidth</td><td>볼린저 밴드폭</td><td>[0, +∞)</td></tr>
<tr><td rowspan="3">모멘텀</td><td>mom_20d</td><td>20일 수익률</td><td>(-1, +∞)</td></tr>
<tr><td>mom_accel</td><td>모멘텀 가속도</td><td>(-∞, +∞)</td></tr>
<tr><td>pct_from_52w_high</td><td>52주 고가 대비</td><td>[-1, 0]</td></tr>
<tr><td rowspan="3">거래량</td><td>volume_ratio</td><td>거래량/MA20 비율</td><td>[0, +∞)</td></tr>
<tr><td>obv_slope</td><td>OBV 변화율</td><td>(-∞, +∞)</td></tr>
<tr><td>price_vwap_ratio</td><td>가격/VWAP 비율</td><td>0.9~1.1</td></tr>
</table>

<!-- ══ Plotly: 롤링 변동성 + 모멘텀 히트맵 ══ -->
<div id="plot-ch9-vol" style="width:100%;height:450px;margin:25px 0"></div>
<p class="ni" style="font-size:12px;color:#888;text-align:center">🖱️ 5일/20일/60일 롤링 변동성 비교 — 변동성 클러스터링(큰 변동 뒤에 큰 변동)을 관찰하세요</p>
<div id="plot-ch9-mom" style="width:100%;height:420px;margin:25px 0"></div>
<p class="ni" style="font-size:12px;color:#888;text-align:center">🖱️ 다기간 모멘텀 히트맵 — 5종목 × 6기간 모멘텀 비교 · 마우스 오버로 수치 확인</p>
<script>
(function(){
  function mulberry32(a){return function(){a|=0;a=a+0x6D2B79F5|0;var t=Math.imul(a^a>>>15,1|a);t=t+Math.imul(t^t>>>7,61|t)^t;return((t^t>>>14)>>>0)/4294967296}}
  var rng=mulberry32(999);
  function randn(){var u=0,v=0;while(u===0)u=rng();while(v===0)v=rng();return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v)}

  // 롤링 변동성
  var N=300,rets=[];
  var vol=0.015; // 초기 변동성
  for(var i=0;i<N;i++){
    // GARCH-like: 변동성 클러스터링
    vol=0.012+0.7*(vol-0.012)+0.15*Math.abs(rets[i-1]||0);
    rets.push(randn()*vol);
  }

  function rollingStd(arr,w){
    var r=[];
    for(var i=0;i<arr.length;i++){
      if(i<w-1){r.push(null);continue}
      var s=0,ss=0;
      for(var j=0;j<w;j++){s+=arr[i-j];ss+=arr[i-j]*arr[i-j]}
      var m=s/w;r.push(Math.sqrt(ss/w-m*m)*Math.sqrt(252)*100);
    }
    return r;
  }
  var vol5=rollingStd(rets,5),vol20=rollingStd(rets,20),vol60=rollingStd(rets,60);
  var dates=[];var d=new Date(2023,0,2);
  for(var i=0;i<N;i++){dates.push(new Date(d));d.setDate(d.getDate()+(d.getDay()===5?3:1))}

  Plotly.newPlot('plot-ch9-vol',[
    {x:dates,y:vol5,mode:'lines',name:'5일 변동성',line:{color:'#e74c3c',width:1},opacity:0.6},
    {x:dates,y:vol20,mode:'lines',name:'20일 변동성',line:{color:'#3498db',width:2}},
    {x:dates,y:vol60,mode:'lines',name:'60일 변동성',line:{color:'#2c3e50',width:2.5}}
  ],{
    title:{text:'📉 롤링 변동성 (연환산 %) — 변동성 클러스터링 관찰',font:{size:14}},
    xaxis:{title:'날짜',gridcolor:'#eee'},
    yaxis:{title:'변동성 (%)',gridcolor:'#eee'},
    legend:{orientation:'h',y:-0.12},
    hovermode:'x unified',
    plot_bgcolor:'#fafafa',paper_bgcolor:'#fff',margin:{t:50,b:55}
  },{responsive:true});

  // 모멘텀 히트맵: 5종목 × 6기간
  var stocks=['삼성전자','SK하이닉스','NAVER','카카오','현대차'];
  var periods=['5일','20일','60일','120일','180일','250일'];
  var momData=[];
  var baseMom=[[2.1,5.3,12.5,8.2,15.1,22.3],
               [3.5,8.1,18.2,25.3,20.1,35.2],
               [-1.2,2.1,-5.3,-8.1,-3.2,5.5],
               [-2.5,-6.3,-15.2,-22.1,-18.5,-12.3],
               [1.8,4.2,9.8,14.5,18.2,28.1]];
  for(var i=0;i<5;i++){
    var row=[];
    for(var j=0;j<6;j++)row.push(baseMom[i][j]+(rng()-0.5)*3);
    momData.push(row);
  }

  Plotly.newPlot('plot-ch9-mom',[{
    z:momData,x:periods,y:stocks,type:'heatmap',
    colorscale:[[0,'#c0392b'],[0.5,'#f5f5f5'],[1,'#27ae60']],
    zmid:0,
    hovertemplate:'%{y}<br>%{x} 모멘텀: %{z:.1f}%<extra></extra>',
    colorbar:{title:'수익률 (%)'}
  }],{
    title:{text:'🔥 다기간 모멘텀 히트맵 (종목 × 기간)',font:{size:14}},
    xaxis:{title:'모멘텀 기간'},yaxis:{title:''},
    plot_bgcolor:'#fafafa',paper_bgcolor:'#fff',margin:{t:50,l:100,b:50}
  },{responsive:true});
})();
</script>

<!-- ═══════════════════════════════════════════ -->
<!-- Ch10: 알파팩터 기초 -->
<!-- ═══════════════════════════════════════════ -->
<h2 id="ch10">10. 알파팩터 기초 — 수익의 원천을 찾아서</h2>

<!-- 알파팩터 평가 파이프라인 다이어그램 (CSS) -->
<div style="margin:25px 0;padding:25px;background:linear-gradient(135deg,#f8f9fa,#faf0f0);border-radius:10px;border:1px solid #ccc">
<p class="ni" style="text-align:center;font-weight:bold;font-size:15px;margin-bottom:18px;color:#2c3e50">🎯 알파팩터 평가 파이프라인</p>
<div style="display:flex;flex-direction:column;gap:10px;font-size:12px;max-width:700px;margin:0 auto">
<div style="display:flex;gap:8px;justify-content:center;flex-wrap:wrap">
<div style="flex:1;min-width:140px;background:#fff;border:2px solid #3498db;border-radius:8px;padding:12px;text-align:center">
<div style="font-size:20px;margin-bottom:4px">💡</div>
<div style="font-weight:bold;color:#3498db">팩터 후보 생성</div>
<div style="font-size:11px;color:#555;margin-top:4px">RSI, 모멘텀, 변동성 등<br>20+ 피처 후보군</div>
</div>
<div style="display:flex;align-items:center;color:#888;font-size:18px">→</div>
<div style="flex:1;min-width:140px;background:#fff;border:2px solid #e67e22;border-radius:8px;padding:12px;text-align:center">
<div style="font-size:20px;margin-bottom:4px">📊</div>
<div style="font-weight:bold;color:#e67e22">IC 계산</div>
<div style="font-size:11px;color:#555;margin-top:4px">팩터값 vs 미래수익률<br>상관계수 (Rank IC)</div>
</div>
<div style="display:flex;align-items:center;color:#888;font-size:18px">→</div>
<div style="flex:1;min-width:140px;background:#fff;border:2px solid #27ae60;border-radius:8px;padding:12px;text-align:center">
<div style="font-size:20px;margin-bottom:4px">✅</div>
<div style="font-weight:bold;color:#27ae60">유효성 검증</div>
<div style="font-size:11px;color:#555;margin-top:4px">IC > 0.03?<br>안정적? 독립적?</div>
</div>
<div style="display:flex;align-items:center;color:#888;font-size:18px">→</div>
<div style="flex:1;min-width:140px;background:#fff;border:2px solid #e74c3c;border-radius:8px;padding:12px;text-align:center">
<div style="font-size:20px;margin-bottom:4px">🏆</div>
<div style="font-weight:bold;color:#e74c3c">팩터 선정</div>
<div style="font-size:11px;color:#555;margin-top:4px">ML 모델 입력으로<br>최종 피처 테이블</div>
</div>
</div>
<div style="margin-top:12px;display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:8px">
<div style="background:#e8f4f8;padding:8px;border-radius:4px;text-align:center;font-size:11px">
<strong>IC (Information Coefficient)</strong><br>|IC| > 0.05 → 강한 팩터
</div>
<div style="background:#fff9e6;padding:8px;border-radius:4px;text-align:center;font-size:11px">
<strong>IC IR (IC의 샤프비율)</strong><br>IC_mean / IC_std > 0.5
</div>
<div style="background:#e8f8e8;padding:8px;border-radius:4px;text-align:center;font-size:11px">
<strong>Turnover</strong><br>팩터 순위 변동 빈도<br>낮을수록 거래비용 절감
</div>
<div style="background:#f0e8f8;padding:8px;border-radius:4px;text-align:center;font-size:11px">
<strong>팩터 상관</strong><br>다른 팩터와 상관 < 0.5<br>독립적 정보 제공
</div>
</div>
</div>
</div>

<h3>10.1 알파란 무엇인가</h3>
<p>알파(alpha)는 시장 수익률을 초과하는 수익이다. 시장이 10% 올랐는데 내 포트폴리오가 15% 올랐다면, 알파는 5%다. 모든 퀀트 투자의 궁극적 목표는 "지속적으로 양의 알파를 생성하는 것"이다.</p>

<p>알파팩터(alpha factor)는 "이 신호를 따라 투자하면 알파를 얻을 수 있다"고 기대되는 예측 변수다. 우리가 앞에서 만든 RSI, MACD, 모멘텀 등이 모두 알파팩터 후보다. 하지만 모든 피처가 좋은 알파팩터는 아니다. 어떤 피처가 진짜 예측력이 있는지 평가하는 방법이 필요하다.</p>

<div class="def">
<p class="ni"><strong>정의: 알파팩터 (Alpha Factor)</strong></p>
<p class="ni">알파팩터는 미래 수익률과 통계적으로 유의미한 상관관계를 가지는 예측 변수다. 좋은 알파팩터는 (1) 예측력이 있고, (2) 시간이 지나도 유효하며, (3) 다른 팩터와 상관이 낮아야 한다.</p>
</div>

<div class="info">
<p class="ni"><strong>교재 연동:</strong> MLAT Ch.4 "Financial Feature Engineering and Alpha Factors"가 이 주제의 핵심 참고 자료다. 팩터의 정의, IC 계산, 팩터 분석 방법론을 상세히 다룬다. MLDSF Ch.2에서도 피처 엔지니어링의 실전 블루프린트를 제시한다.</p>
</div>

<h3>10.2 IC (Information Coefficient) — 팩터의 예측력 측정</h3>
<p>IC는 "팩터 값과 미래 수익률 사이의 상관계수"다. 팩터가 높은 종목이 실제로 수익률이 높았는지를 측정한다. IC가 양수이면 팩터가 예측력이 있다는 뜻이다.</p>

<div class="eq">\[ \text{IC}_t = \text{corr}(\text{Factor}_t, \text{Return}_{t+1}) \]</div>

<p>IC의 해석:</p>
<ul>
<li><strong>|IC| > 0.05:</strong> 의미 있는 예측력 (금융에서는 이 정도면 훌륭하다!)</li>
<li><strong>|IC| > 0.10:</strong> 매우 강한 예측력 (드물다)</li>
<li><strong>IC ≈ 0:</strong> 예측력 없음</li>
<li><strong>IC의 부호:</strong> 양수면 팩터가 클수록 수익률 높음, 음수면 반대</li>
</ul>

<pre><code><span class="cm"># IC 계산 예제</span>
<span class="cm"># 5종목 데이터로 간단한 IC 계산</span>

<span class="cm"># 1. 각 종목의 20일 모멘텀 팩터</span>
adj_close = yf.download(tickers, period=<span class="st">"2y"</span>)[<span class="st">"Close"</span>]
adj_close.columns = names

<span class="cm"># 20일 모멘텀</span>
momentum_20 = adj_close.pct_change(<span class="nu">20</span>)

<span class="cm"># 미래 20일 수익률 (예측 대상)</span>
future_return_20 = adj_close.pct_change(<span class="nu">20</span>).shift(-<span class="nu">20</span>)

<span class="cm"># 2. 날짜별 IC 계산 (횡단면 상관계수)</span>
ic_series = momentum_20.corrwith(future_return_20, axis=<span class="nu">1</span>)
ic_series = ic_series.dropna()

<span class="fn">print</span>(<span class="st">"=== 20일 모멘텀 팩터의 IC ==="</span>)
<span class="fn">print</span>(<span class="st">f"평균 IC: </span>{ic_series.mean():.4f}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"IC 표준편차: </span>{ic_series.std():.4f}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"IC > 0 비율: </span>{(ic_series > 0).mean():.2%}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"IR (IC/std): </span>{ic_series.mean() / ic_series.std():.4f}<span class="st">"</span>)

<span class="cm"># IC 시계열 시각화</span>
fig, axes = plt.subplots(<span class="nu">2</span>, <span class="nu">1</span>, figsize=(<span class="nu">14</span>, <span class="nu">7</span>))

axes[<span class="nu">0</span>].bar(ic_series.index, ic_series.values,
           color=[<span class="st">"green"</span> <span class="kw">if</span> v > <span class="nu">0</span> <span class="kw">else</span> <span class="st">"red"</span> <span class="kw">for</span> v <span class="kw">in</span> ic_series.values],
           alpha=<span class="nu">0.6</span>, width=<span class="nu">2</span>)
axes[<span class="nu">0</span>].axhline(y=<span class="nu">0</span>, color=<span class="st">"black"</span>, linewidth=<span class="nu">0.5</span>)
axes[<span class="nu">0</span>].set_title(<span class="st">"20일 모멘텀 팩터 IC 시계열"</span>)
axes[<span class="nu">0</span>].set_ylabel(<span class="st">"IC"</span>)
axes[<span class="nu">0</span>].grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)

<span class="cm"># 누적 IC</span>
axes[<span class="nu">1</span>].plot(ic_series.cumsum().index, ic_series.cumsum().values, color=<span class="st">"navy"</span>)
axes[<span class="nu">1</span>].set_title(<span class="st">"누적 IC (우상향이면 팩터가 유효)"</span>)
axes[<span class="nu">1</span>].set_ylabel(<span class="st">"Cumulative IC"</span>)
axes[<span class="nu">1</span>].grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)

plt.tight_layout()
plt.show()</code></pre>

<h3>10.3 IR (Information Ratio) — 팩터의 안정성</h3>

<!-- ── 보충 10.2+ IC 구체적 step-by-step 계산 + Alpha Decay ── -->
<div class="def">
<p class="ni"><strong>🔍 보충: IC를 작은 숫자로 step-by-step 계산해보기 + Alpha Decay 개념</strong></p>
<p class="ni">IC 공식 \(\text{IC}_t = \text{corr}(\text{Factor}_t, \text{Return}_{t+1})\)이 실제로 어떻게 계산되는지, 5개 종목의 작은 예제로 한 단계씩 따라가보자. 그리고 "알파가 시간이 지나면 사라진다"는 Alpha Decay 개념도 소개한다.</p>
</div>

<pre><code><span class="cm"># === IC 계산 step-by-step (5종목 미니 예제) ===</span>
<span class="kw">import</span> numpy <span class="kw">as</span> np
<span class="kw">import</span> pandas <span class="kw">as</span> pd
<span class="kw">from</span> scipy <span class="kw">import</span> stats

<span class="cm"># Step 1: 오늘(t일) 5종목의 20일 모멘텀 팩터값</span>
stocks = [<span class="st">"삼성전자"</span>, <span class="st">"SK하이닉스"</span>, <span class="st">"NAVER"</span>, <span class="st">"카카오"</span>, <span class="st">"LG에너지"</span>]
factor_t = pd.Series([<span class="nu">0.08</span>, <span class="nu">0.12</span>, -<span class="nu">0.03</span>, -<span class="nu">0.10</span>, <span class="nu">0.05</span>], index=stocks, name=<span class="st">"모멘텀(t)"</span>)
<span class="cm"># 삼성 +8%, SK +12%, NAVER -3%, 카카오 -10%, LG +5%</span>

<span class="cm"># Step 2: 미래(t+1 ~ t+20일) 20일 수익률 (나중에 알게 되는 값)</span>
return_t1 = pd.Series([<span class="nu">0.05</span>, <span class="nu">0.09</span>, <span class="nu">0.01</span>, -<span class="nu">0.06</span>, <span class="nu">0.03</span>], index=stocks, name=<span class="st">"수익률(t+1)"</span>)
<span class="cm"># 삼성 +5%, SK +9%, NAVER +1%, 카카오 -6%, LG +3%</span>

<span class="fn">print</span>(<span class="st">"=== Step 1 & 2: 팩터값과 미래 수익률 ==="</span>)
table = pd.DataFrame({<span class="st">"모멘텀(t)"</span>: factor_t, <span class="st">"수익률(t+1)"</span>: return_t1})
<span class="fn">print</span>(table)
<span class="fn">print</span>(<span class="st">"\n→ 모멘텀이 높은 종목(SK +12%)이 실제로 수익률도 높았는가(SK +9%)?"</span>)</code></pre>

<pre><code><span class="cm"># Step 3: 순위 변환 (Rank IC = Spearman 상관계수)</span>
rank_factor = factor_t.rank()
rank_return = return_t1.rank()

<span class="fn">print</span>(<span class="st">"=== Step 3: 순위 변환 ==="</span>)
rank_table = pd.DataFrame({
    <span class="st">"모멘텀값"</span>: factor_t,
    <span class="st">"모멘텀순위"</span>: rank_factor,
    <span class="st">"수익률값"</span>: return_t1,
    <span class="st">"수익률순위"</span>: rank_return
})
<span class="fn">print</span>(rank_table)
<span class="cm"># SK하이닉스: 모멘텀 1위 → 수익률도 1위 ✓</span>
<span class="cm"># 카카오: 모멘텀 5위(꼴찌) → 수익률도 5위(꼴찌) ✓</span>
<span class="cm"># → 순위가 잘 맞으면 IC가 높다!</span>

<span class="cm"># Step 4: IC 계산 (Spearman 순위 상관계수)</span>
ic_value, p_value = stats.spearmanr(factor_t, return_t1)
<span class="fn">print</span>(<span class="st">f"\n=== Step 4: IC 계산 ==="</span>)
<span class="fn">print</span>(<span class="st">f"Rank IC = </span>{ic_value:.4f}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"p-value = </span>{p_value:.4f}<span class="st">"</span>)

<span class="cm"># Pearson IC도 비교</span>
pearson_ic = factor_t.corr(return_t1)
<span class="fn">print</span>(<span class="st">f"Pearson IC = </span>{pearson_ic:.4f}<span class="st">"</span>)

<span class="fn">print</span>(<span class="st">f"\n=== IC 해석 ==="</span>)
<span class="fn">print</span>(<span class="st">f"IC = </span>{ic_value:.2f}<span class="st"> → 모멘텀 팩터가 미래 수익률을 잘 예측했다!"</span>)
<span class="fn">print</span>(<span class="st">f"(금융에서 |IC| > 0.05면 의미 있고, > 0.10이면 매우 강한 팩터)"</span>)</code></pre>

<pre><code><span class="cm"># Step 5: 여러 날의 IC를 모아서 평균 IC와 IR 계산</span>
<span class="cm"># (실전에서는 매일 IC를 계산하고, 그 평균과 안정성을 본다)</span>

np.random.seed(<span class="nu">42</span>)
n_days = <span class="nu">250</span>  <span class="cm"># 1년</span>

<span class="cm"># 시뮬레이션: 매일 5종목의 IC 계산</span>
daily_ics = []
<span class="kw">for</span> day <span class="kw">in</span> <span class="fn">range</span>(n_days):
    <span class="cm"># 팩터값 (랜덤)</span>
    f = np.random.normal(<span class="nu">0</span>, <span class="nu">0.1</span>, <span class="nu">5</span>)
    <span class="cm"># 미래 수익률 = 팩터 × 0.3 + 노이즈 (약한 예측력)</span>
    r = f * <span class="nu">0.3</span> + np.random.normal(<span class="nu">0</span>, <span class="nu">0.05</span>, <span class="nu">5</span>)
    ic, _ = stats.spearmanr(f, r)
    daily_ics.append(ic)

daily_ics = pd.Series(daily_ics)

<span class="fn">print</span>(<span class="st">"=== 1년간 일별 IC 통계 ==="</span>)
<span class="fn">print</span>(<span class="st">f"평균 IC (Mean IC): </span>{daily_ics.mean():.4f}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"IC 표준편차:       </span>{daily_ics.std():.4f}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"IR = IC/std:       </span>{daily_ics.mean()/daily_ics.std():.4f}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"IC > 0 비율:       </span>{(daily_ics > 0).mean():.1%}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"\n→ IR > 0.5이면 안정적인 팩터, > 1.0이면 매우 우수"</span>)</code></pre>

<pre><code><span class="cm"># === Alpha Decay (알파 감쇠) ===</span>
<span class="cm"># "팩터의 예측력은 시간이 지나면 사라진다"</span>

<span class="cm"># 다양한 예측 기간(horizon)에 대해 IC 계산</span>
horizons = [<span class="nu">1</span>, <span class="nu">5</span>, <span class="nu">10</span>, <span class="nu">20</span>, <span class="nu">40</span>, <span class="nu">60</span>]  <span class="cm"># 1일 ~ 60일 후</span>
ic_by_horizon = []

np.random.seed(<span class="nu">42</span>)
<span class="kw">for</span> h <span class="kw">in</span> horizons:
    ics = []
    <span class="kw">for</span> _ <span class="kw">in</span> <span class="fn">range</span>(<span class="nu">500</span>):
        f = np.random.normal(<span class="nu">0</span>, <span class="nu">0.1</span>, <span class="nu">20</span>)
        <span class="cm"># 예측력이 horizon에 반비례하여 감소</span>
        signal_strength = <span class="nu">0.5</span> / np.sqrt(h)
        r = f * signal_strength + np.random.normal(<span class="nu">0</span>, <span class="nu">0.05</span>, <span class="nu">20</span>)
        ic, _ = stats.spearmanr(f, r)
        ics.append(ic)
    ic_by_horizon.append(np.mean(ics))

<span class="fn">print</span>(<span class="st">"=== Alpha Decay: 예측 기간별 IC ==="</span>)
<span class="kw">for</span> h, ic <span class="kw">in</span> <span class="fn">zip</span>(horizons, ic_by_horizon):
    bar = <span class="st">"█"</span> * <span class="nb">int</span>(ic * <span class="nu">100</span>)
    <span class="fn">print</span>(<span class="st">f"  </span>{h:2d}<span class="st">일 후: IC = </span>{ic:.4f}<span class="st"> </span>{bar}<span class="st">"</span>)

<span class="fn">print</span>(<span class="st">f"\n💡 Alpha Decay란?"</span>)
<span class="fn">print</span>(<span class="st">f"  → 팩터의 예측력(IC)은 예측 기간이 길어질수록 감소한다."</span>)
<span class="fn">print</span>(<span class="st">f"  → 1일 후 IC가 높아도, 20일 후에는 거의 0에 가까울 수 있다."</span>)
<span class="fn">print</span>(<span class="st">f"  → HFT에서는 이 감쇠가 매우 빠르다 (분~시간 단위)."</span>)
<span class="fn">print</span>(<span class="st">f"  → Alpha Decay가 느린 팩터 = 더 오래 유효한 팩터 = 더 가치 있다."</span>)
<span class="fn">print</span>(<span class="st">f"  → 실전에서는 팩터의 'half-life'(IC가 절반이 되는 기간)를 측정한다."</span>)</code></pre>

<div class="info">
<p class="ni"><strong>IC 실전 체크리스트:</strong></p>
<ul>
<li><strong>Mean IC > 0.03:</strong> 최소한의 예측력 (사용 가능)</li>
<li><strong>Mean IC > 0.05:</strong> 의미 있는 예측력 (좋은 팩터)</li>
<li><strong>IR > 0.5:</strong> 안정적인 팩터 (IC가 일관되게 양수)</li>
<li><strong>IC > 0 비율 > 55%:</strong> 절반 이상의 날에서 예측이 맞음</li>
<li><strong>Alpha Decay half-life > 5일:</strong> 일간 리밸런싱 전략에 적합</li>
</ul>
</div>
<p>IC가 높아도 날마다 들쭉날쭉하면 신뢰하기 어렵다. IR(Information Ratio)은 IC의 평균을 IC의 표준편차로 나눈 것으로, "팩터의 예측력이 얼마나 안정적인가"를 측정한다. 샤프비율의 팩터 버전이라고 생각하면 된다.</p>

<div class="eq">\[ \text{IR} = \frac{\text{Mean}(\text{IC})}{\text{Std}(\text{IC})} \]</div>

<p>IR의 해석:</p>
<ul>
<li><strong>IR > 0.5:</strong> 매우 좋은 팩터</li>
<li><strong>IR > 0.3:</strong> 괜찮은 팩터</li>
<li><strong>IR < 0.1:</strong> 신뢰하기 어려움</li>
</ul>

<h3>10.4 팩터 상관관계 — 다양성이 중요하다</h3>
<p>여러 팩터를 동시에 사용할 때, 팩터들 간의 상관관계가 낮아야 한다. 모멘텀과 RSI는 둘 다 "추세"를 측정하므로 상관이 높을 수 있다. 상관이 높은 팩터를 여러 개 넣어봤자 정보가 중복될 뿐이다.</p>

<pre><code><span class="cm"># 피처 간 상관관계 분석</span>
feature_cols = [<span class="st">"mom_20d"</span>, <span class="st">"mom_60d"</span>, <span class="st">"bb_pct_b"</span>, <span class="st">"bb_bandwidth"</span>,
                <span class="st">"volume_ratio"</span>, <span class="st">"atr_ratio"</span>, <span class="st">"price_sma20_ratio"</span>]

<span class="cm"># 사용 가능한 피처만 선택</span>
available = [c <span class="kw">for</span> c <span class="kw">in</span> feature_cols <span class="kw">if</span> c <span class="kw">in</span> features.columns]
corr_matrix = features[available].dropna().corr()

<span class="cm"># 히트맵 시각화</span>
fig, ax = plt.subplots(figsize=(<span class="nu">8</span>, <span class="nu">6</span>))
im = ax.imshow(corr_matrix, cmap=<span class="st">"RdBu_r"</span>, vmin=-<span class="nu">1</span>, vmax=<span class="nu">1</span>)
ax.set_xticks(<span class="fn">range</span>(<span class="fn">len</span>(available)))
ax.set_yticks(<span class="fn">range</span>(<span class="fn">len</span>(available)))
ax.set_xticklabels(available, rotation=<span class="nu">45</span>, ha=<span class="st">"right"</span>, fontsize=<span class="nu">9</span>)
ax.set_yticklabels(available, fontsize=<span class="nu">9</span>)

<span class="cm"># 상관계수 값 표시</span>
<span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(<span class="fn">len</span>(available)):
    <span class="kw">for</span> j <span class="kw">in</span> <span class="fn">range</span>(<span class="fn">len</span>(available)):
        ax.text(j, i, <span class="st">f"</span>{corr_matrix.iloc[i, j]:.2f}<span class="st">"</span>,
                ha=<span class="st">"center"</span>, va=<span class="st">"center"</span>, fontsize=<span class="nu">8</span>,
                color=<span class="st">"white"</span> <span class="kw">if</span> abs(corr_matrix.iloc[i, j]) > <span class="nu">0.5</span> <span class="kw">else</span> <span class="st">"black"</span>)

plt.colorbar(im)
ax.set_title(<span class="st">"피처 간 상관관계 히트맵"</span>)
plt.tight_layout()
plt.show()</code></pre>

<div class="warn">
<p class="ni"><strong>다중공선성 (Multicollinearity):</strong> 피처 간 상관이 0.8 이상이면 다중공선성 문제가 발생할 수 있다. 선형 모델(회귀, 로지스틱)에서 계수가 불안정해지고, 해석이 어려워진다. 해결 방법: (1) 상관이 높은 피처 중 하나를 제거, (2) PCA로 차원 축소 (Round 5), (3) 트리 기반 모델 사용 (다중공선성에 강건).</p>
</div>

<h3>10.5 팩터 중립화 (Factor Neutralization)</h3>
<p>알파팩터를 사용할 때 주의할 점이 있다. 예를 들어 모멘텀 팩터가 "대형주에서만 잘 작동하고 소형주에서는 안 된다"면, 이것은 진짜 모멘텀 알파가 아니라 사이즈 팩터의 영향일 수 있다. 이런 혼동을 제거하기 위해 팩터 중립화를 한다.</p>

<pre><code><span class="cm"># 간단한 팩터 중립화 예제</span>
<span class="cm"># 섹터 중립화: 각 섹터 내에서 팩터 값을 표준화</span>

<span class="cm"># 예제 데이터</span>
factor_data = pd.DataFrame({
    <span class="st">"ticker"</span>: [<span class="st">"A"</span>, <span class="st">"B"</span>, <span class="st">"C"</span>, <span class="st">"D"</span>, <span class="st">"E"</span>, <span class="st">"F"</span>],
    <span class="st">"sector"</span>: [<span class="st">"IT"</span>, <span class="st">"IT"</span>, <span class="st">"IT"</span>, <span class="st">"금융"</span>, <span class="st">"금융"</span>, <span class="st">"금융"</span>],
    <span class="st">"momentum"</span>: [<span class="nu">0.15</span>, <span class="nu">0.10</span>, <span class="nu">0.20</span>, <span class="nu">0.05</span>, <span class="nu">0.03</span>, <span class="nu">0.08</span>]
})

<span class="cm"># 섹터 중립화: 각 섹터 내에서 Z-score</span>
factor_data[<span class="st">"mom_neutral"</span>] = factor_data.groupby(<span class="st">"sector"</span>)[<span class="st">"momentum"</span>].transform(
    <span class="kw">lambda</span> x: (x - x.mean()) / x.std()
)

<span class="fn">print</span>(<span class="st">"=== 섹터 중립화 ==="</span>)
<span class="fn">print</span>(factor_data)
<span class="cm"># IT 섹터 내에서 C가 가장 높고, 금융 섹터 내에서 F가 가장 높음</span>
<span class="cm"># 섹터 간 수준 차이가 제거됨</span></code></pre>

<!-- ══ Plotly: Alpha Decay + IC 시계열 ══ -->
<div id="plot-ch10-ic" style="width:100%;height:420px;margin:25px 0"></div>
<p class="ni" style="font-size:12px;color:#888;text-align:center">🖱️ 일별 IC 시계열 — 녹색=양수(예측 성공), 빨강=음수(예측 실패) · 누적 IC가 우상향이면 유효한 팩터</p>
<div id="plot-ch10-decay" style="width:100%;height:400px;margin:25px 0"></div>
<p class="ni" style="font-size:12px;color:#888;text-align:center">🖱️ Alpha Decay — 예측 기간이 길어질수록 IC가 감소하는 패턴 · 3개 팩터 비교</p>
<script>
(function(){
  function mulberry32(a){return function(){a|=0;a=a+0x6D2B79F5|0;var t=Math.imul(a^a>>>15,1|a);t=t+Math.imul(t^t>>>7,61|t)^t;return((t^t>>>14)>>>0)/4294967296}}
  var rng=mulberry32(314);
  function randn(){var u=0,v=0;while(u===0)u=rng();while(v===0)v=rng();return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v)}

  // IC 시계열 (250일)
  var N=250,ics=[],cumIc=[0];
  var dates=[];var d=new Date(2024,0,2);
  for(var i=0;i<N;i++){
    dates.push(new Date(d));
    var ic=0.04+randn()*0.15; // 평균 IC ≈ 0.04
    ics.push(ic);
    cumIc.push(cumIc[i]+ic);
    d.setDate(d.getDate()+(d.getDay()===5?3:1));
  }
  cumIc.shift();

  var icColors=ics.map(function(v){return v>=0?'rgba(46,204,113,0.7)':'rgba(231,76,60,0.7)'});

  Plotly.newPlot('plot-ch10-ic',[
    {x:dates,y:ics,type:'bar',name:'일별 IC',marker:{color:icColors},yaxis:'y'},
    {x:dates,y:cumIc,mode:'lines',name:'누적 IC',line:{color:'#2c3e50',width:2.5},yaxis:'y2'}
  ],{
    title:{text:'📊 모멘텀 팩터 IC 시계열 (1년)',font:{size:14}},
    xaxis:{gridcolor:'#eee'},
    yaxis:{title:'일별 IC',gridcolor:'#eee',side:'left'},
    yaxis2:{title:'누적 IC',overlaying:'y',side:'right',gridcolor:'#eee'},
    legend:{orientation:'h',y:-0.12},
    hovermode:'x unified',
    plot_bgcolor:'#fafafa',paper_bgcolor:'#fff',margin:{t:50,b:55},
    annotations:[{
      x:dates[N-1],y:cumIc[N-1],yref:'y2',
      text:'누적 IC='+cumIc[N-1].toFixed(1),
      showarrow:true,arrowhead:2,font:{size:11,color:'#2c3e50'}
    }]
  },{responsive:true});

  // Alpha Decay: 3개 팩터 비교
  var horizons=[1,2,5,10,20,40,60,120];
  var factors=[
    {name:'단기 모멘텀 (5일)',halflife:5,ic0:0.08,color:'#e74c3c'},
    {name:'RSI 반전',halflife:15,ic0:0.06,color:'#3498db'},
    {name:'밸류 (PBR)',halflife:60,ic0:0.04,color:'#2ecc71'}
  ];

  var traces=[];
  factors.forEach(function(f){
    var ys=horizons.map(function(h){return f.ic0*Math.exp(-0.693*h/f.halflife)+(rng()-0.5)*0.003});
    traces.push({
      x:horizons,y:ys,mode:'lines+markers',name:f.name,
      line:{color:f.color,width:2.5},marker:{size:8},
      hovertemplate:f.name+'<br>%{x}일 후 IC: %{y:.4f}<extra></extra>'
    });
  });
  // 유의 수준 선
  traces.push({x:[0,130],y:[0.03,0.03],mode:'lines',name:'유의 수준 (IC=0.03)',
    line:{color:'#999',width:1.5,dash:'dash'}});

  Plotly.newPlot('plot-ch10-decay',traces,{
    title:{text:'⏳ Alpha Decay — 예측 기간별 IC 감소 패턴',font:{size:14}},
    xaxis:{title:'예측 기간 (거래일)',gridcolor:'#eee',type:'log',dtick:null},
    yaxis:{title:'IC (Information Coefficient)',gridcolor:'#eee',range:[0,0.1]},
    legend:{orientation:'h',y:-0.15},
    plot_bgcolor:'#fafafa',paper_bgcolor:'#fff',margin:{t:50,b:60},
    annotations:[{
      x:1.3,y:0.032,xref:'x',yref:'y',text:'IC < 0.03 → 예측력 없음',
      showarrow:false,font:{size:10,color:'#999'}
    }]
  },{responsive:true});
})();
</script>

<!-- ═══════════════════════════════════════════ -->
<!-- Ch11: 실전 피처 테이블 구축 -->
<!-- ═══════════════════════════════════════════ -->
<h2 id="ch11">11. 실전: 피처 테이블 구축 — 모든 것을 하나로</h2>

<h3>11.1 전체 파이프라인 통합</h3>
<p>지금까지 배운 모든 것을 하나의 파이프라인으로 통합한다. 원시 데이터에서 출발하여, 정제하고, 피처를 생성하고, 최종 피처 테이블을 만드는 전체 과정이다. 이 코드는 Round 4에서 ML 모델의 입력으로 직접 사용된다.</p>

<pre><code><span class="kw">import</span> yfinance <span class="kw">as</span> yf
<span class="kw">import</span> pandas <span class="kw">as</span> pd
<span class="kw">import</span> numpy <span class="kw">as</span> np
<span class="kw">import</span> matplotlib.pyplot <span class="kw">as</span> plt

<span class="cm"># ═══════════════════════════════════════</span>
<span class="cm"># STEP 1: 데이터 수집</span>
<span class="cm"># ═══════════════════════════════════════</span>
ticker = <span class="st">"005930.KS"</span>  <span class="cm"># 삼성전자</span>
raw = yf.download(ticker, period=<span class="st">"2y"</span>)

<span class="cm"># 컬럼 정리 (MultiIndex 제거)</span>
raw.columns = [c[<span class="nu">0</span>] <span class="kw">if</span> <span class="fn">isinstance</span>(c, <span class="nb">tuple</span>) <span class="kw">else</span> c <span class="kw">for</span> c <span class="kw">in</span> raw.columns]

<span class="fn">print</span>(<span class="st">f"원시 데이터: </span>{raw.shape}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"기간: </span>{raw.index[0].date()}<span class="st"> ~ </span>{raw.index[-1].date()}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"결측치:\n</span>{raw.isnull().sum()}<span class="st">"</span>)</code></pre>

<pre><code><span class="cm"># ═══════════════════════════════════════</span>
<span class="cm"># STEP 2: 데이터 정제</span>
<span class="cm"># ═══════════════════════════════════════</span>

<span class="cm"># 결측치 처리</span>
raw = raw.ffill(limit=<span class="nu">5</span>)  <span class="cm"># 최대 5일까지 전방 채움</span>
raw = raw.dropna()         <span class="cm"># 나머지 결측 행 제거</span>

<span class="cm"># 기본 변수 추출</span>
close = raw[<span class="st">"Close"</span>]
high = raw[<span class="st">"High"</span>]
low = raw[<span class="st">"Low"</span>]
volume = raw[<span class="st">"Volume"</span>]
open_price = raw[<span class="st">"Open"</span>]

<span class="cm"># 수익률 계산</span>
ret = close.pct_change()
log_ret = np.log(close / close.shift(<span class="nu">1</span>))

<span class="fn">print</span>(<span class="st">f"정제 후: </span>{raw.shape}<span class="st">"</span>)</code></pre>

<pre><code><span class="cm"># ═══════════════════════════════════════</span>
<span class="cm"># STEP 3: 피처 생성 (20개 이상)</span>
<span class="cm"># ═══════════════════════════════════════</span>

feat = pd.DataFrame(index=raw.index)

<span class="cm"># --- 수익률 피처 ---</span>
feat[<span class="st">"ret_1d"</span>] = ret                          <span class="cm"># 1일 수익률</span>
feat[<span class="st">"ret_5d"</span>] = close.pct_change(<span class="nu">5</span>)           <span class="cm"># 5일 수익률</span>
feat[<span class="st">"ret_20d"</span>] = close.pct_change(<span class="nu">20</span>)         <span class="cm"># 20일 수익률</span>

<span class="cm"># --- 이동평균 피처 ---</span>
sma_5 = close.rolling(<span class="nu">5</span>).mean()
sma_20 = close.rolling(<span class="nu">20</span>).mean()
sma_60 = close.rolling(<span class="nu">60</span>).mean()
feat[<span class="st">"price_sma5"</span>] = close / sma_5             <span class="cm"># 가격/SMA5</span>
feat[<span class="st">"price_sma20"</span>] = close / sma_20           <span class="cm"># 가격/SMA20</span>
feat[<span class="st">"price_sma60"</span>] = close / sma_60           <span class="cm"># 가격/SMA60</span>
feat[<span class="st">"sma_cross"</span>] = (sma_5 > sma_20).astype(<span class="nb">int</span>)  <span class="cm"># 단기>장기</span>

<span class="cm"># --- RSI ---</span>
delta = close.diff()
gain = delta.where(delta > <span class="nu">0</span>, <span class="nu">0</span>)
loss = -delta.where(delta < <span class="nu">0</span>, <span class="nu">0</span>)
avg_gain = gain.ewm(alpha=<span class="nu">1</span>/<span class="nu">14</span>, min_periods=<span class="nu">14</span>).mean()
avg_loss = loss.ewm(alpha=<span class="nu">1</span>/<span class="nu">14</span>, min_periods=<span class="nu">14</span>).mean()
rs = avg_gain / avg_loss
feat[<span class="st">"rsi_14"</span>] = <span class="nu">100</span> - (<span class="nu">100</span> / (<span class="nu">1</span> + rs))          <span class="cm"># RSI</span>

<span class="cm"># --- MACD ---</span>
ema12 = close.ewm(span=<span class="nu">12</span>).mean()
ema26 = close.ewm(span=<span class="nu">26</span>).mean()
macd = ema12 - ema26
signal = macd.ewm(span=<span class="nu">9</span>).mean()
feat[<span class="st">"macd_hist"</span>] = macd - signal               <span class="cm"># MACD 히스토그램</span>
feat[<span class="st">"macd_cross"</span>] = (macd > signal).astype(<span class="nb">int</span>)  <span class="cm"># MACD 크로스</span>

<span class="cm"># --- 볼린저 밴드 ---</span>
bb_sma = close.rolling(<span class="nu">20</span>).mean()
bb_std = close.rolling(<span class="nu">20</span>).std()
bb_upper = bb_sma + <span class="nu">2</span> * bb_std
bb_lower = bb_sma - <span class="nu">2</span> * bb_std
feat[<span class="st">"bb_pct_b"</span>] = (close - bb_lower) / (bb_upper - bb_lower)  <span class="cm"># %B</span>
feat[<span class="st">"bb_width"</span>] = (bb_upper - bb_lower) / bb_sma              <span class="cm"># 밴드폭</span>

<span class="cm"># --- 변동성 ---</span>
feat[<span class="st">"vol_20d"</span>] = ret.rolling(<span class="nu">20</span>).std() * np.sqrt(<span class="nu">252</span>)  <span class="cm"># 20일 변동성</span>
feat[<span class="st">"vol_ratio"</span>] = (ret.rolling(<span class="nu">5</span>).std()) / (ret.rolling(<span class="nu">60</span>).std())  <span class="cm"># 변동성 비율</span>

<span class="cm"># --- ATR ---</span>
tr1 = high - low
tr2 = (high - close.shift(<span class="nu">1</span>)).abs()
tr3 = (low - close.shift(<span class="nu">1</span>)).abs()
true_range = pd.concat([tr1, tr2, tr3], axis=<span class="nu">1</span>).max(axis=<span class="nu">1</span>)
feat[<span class="st">"atr_pct"</span>] = true_range.rolling(<span class="nu">14</span>).mean() / close  <span class="cm"># ATR/가격</span>

<span class="cm"># --- 거래량 ---</span>
feat[<span class="st">"vol_ma_ratio"</span>] = volume / volume.rolling(<span class="nu">20</span>).mean()  <span class="cm"># 거래량/MA20</span>

<span class="cm"># --- 모멘텀 ---</span>
feat[<span class="st">"mom_60d"</span>] = close.pct_change(<span class="nu">60</span>)          <span class="cm"># 60일 모멘텀</span>
high_52w = close.rolling(<span class="nu">252</span>).max()
feat[<span class="st">"dist_52w_high"</span>] = close / high_52w - <span class="nu">1</span>    <span class="cm"># 52주 고가 대비</span>

<span class="cm"># --- 캔들스틱 패턴 ---</span>
feat[<span class="st">"body_ratio"</span>] = (close - open_price) / (high - low + <span class="nu">1e-8</span>)  <span class="cm"># 몸통/전체</span>
feat[<span class="st">"upper_shadow"</span>] = (high - pd.concat([close, open_price], axis=<span class="nu">1</span>).max(axis=<span class="nu">1</span>)) / (high - low + <span class="nu">1e-8</span>)

<span class="fn">print</span>(<span class="st">f"\n=== 피처 테이블 ==="</span>)
<span class="fn">print</span>(<span class="st">f"Shape: </span>{feat.shape}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"피처 수: </span>{feat.shape[1]}<span class="st">개"</span>)
<span class="fn">print</span>(<span class="st">f"\n컬럼 목록:"</span>)
<span class="kw">for</span> i, col <span class="kw">in</span> <span class="fn">enumerate</span>(feat.columns, <span class="nu">1</span>):
    <span class="fn">print</span>(<span class="st">f"  {i:2d}. </span>{col}<span class="st">"</span>)</code></pre>

<pre><code><span class="cm"># ═══════════════════════════════════════</span>
<span class="cm"># STEP 4: 타겟 변수 생성</span>
<span class="cm"># ═══════════════════════════════════════</span>

<span class="cm"># 미래 5일 수익률 (예측 대상)</span>
feat[<span class="st">"target_5d"</span>] = close.pct_change(<span class="nu">5</span>).shift(-<span class="nu">5</span>)

<span class="cm"># 미래 5일 방향 (분류 문제용)</span>
feat[<span class="st">"target_dir"</span>] = (feat[<span class="st">"target_5d"</span>] > <span class="nu">0</span>).astype(<span class="nb">int</span>)

<span class="fn">print</span>(<span class="st">f"\n=== 타겟 분포 ==="</span>)
<span class="fn">print</span>(feat[<span class="st">"target_dir"</span>].value_counts())
<span class="fn">print</span>(<span class="st">f"상승 비율: </span>{feat[<span class="st">'target_dir'</span>].mean():.2%}<span class="st">"</span>)</code></pre>

<pre><code><span class="cm"># ═══════════════════════════════════════</span>
<span class="cm"># STEP 5: 최종 정리 + 저장</span>
<span class="cm"># ═══════════════════════════════════════</span>

<span class="cm"># 결측치 제거 (이동평균 등의 초기 NaN)</span>
feat_clean = feat.dropna()
<span class="fn">print</span>(<span class="st">f"\n최종 피처 테이블: </span>{feat_clean.shape}<span class="st">"</span>)
<span class="fn">print</span>(feat_clean.head().round(<span class="nu">4</span>))

<span class="cm"># CSV로 저장</span>
feat_clean.to_csv(<span class="st">"samsung_features.csv"</span>)
<span class="fn">print</span>(<span class="st">"\n✅ samsung_features.csv 저장 완료!"</span>)

<span class="cm"># 기술통계 확인</span>
<span class="fn">print</span>(<span class="st">"\n=== 피처 기술통계 ==="</span>)
<span class="fn">print</span>(feat_clean.describe().round(<span class="nu">4</span>).T)</code></pre>

<h3>11.2 피처 테이블 시각화</h3>
<pre><code><span class="cm"># 피처 분포 시각화</span>
fig, axes = plt.subplots(<span class="nu">4</span>, <span class="nu">4</span>, figsize=(<span class="nu">16</span>, <span class="nu">12</span>))
axes = axes.flatten()

plot_cols = [c <span class="kw">for</span> c <span class="kw">in</span> feat_clean.columns <span class="kw">if</span> <span class="kw">not</span> c.startswith(<span class="st">"target"</span>)][:<span class="nu">16</span>]

<span class="kw">for</span> i, col <span class="kw">in</span> <span class="fn">enumerate</span>(plot_cols):
    axes[i].hist(feat_clean[col].dropna(), bins=<span class="nu">40</span>, color=<span class="st">"steelblue"</span>,
                 alpha=<span class="nu">0.7</span>, edgecolor=<span class="st">"white"</span>)
    axes[i].set_title(col, fontsize=<span class="nu">9</span>)
    axes[i].tick_params(labelsize=<span class="nu">7</span>)

plt.suptitle(<span class="st">"피처 분포 (Feature Distributions)"</span>, fontsize=<span class="nu">14</span>, y=<span class="nu">1.01</span>)
plt.tight_layout()
plt.show()</code></pre>

<h3>11.3 피처-타겟 상관관계</h3>
<pre><code><span class="cm"># 각 피처와 타겟(미래 5일 수익률)의 상관계수</span>
target_corr = feat_clean.drop(columns=[<span class="st">"target_5d"</span>, <span class="st">"target_dir"</span>]).corrwith(
    feat_clean[<span class="st">"target_5d"</span>]
).sort_values()

<span class="cm"># 시각화</span>
fig, ax = plt.subplots(figsize=(<span class="nu">10</span>, <span class="nu">8</span>))
colors = [<span class="st">"green"</span> <span class="kw">if</span> v > <span class="nu">0</span> <span class="kw">else</span> <span class="st">"red"</span> <span class="kw">for</span> v <span class="kw">in</span> target_corr.values]
ax.barh(target_corr.index, target_corr.values, color=colors, alpha=<span class="nu">0.7</span>)
ax.axvline(x=<span class="nu">0</span>, color=<span class="st">"black"</span>, linewidth=<span class="nu">0.5</span>)
ax.set_title(<span class="st">"피처-타겟(5일 수익률) 상관계수"</span>, fontsize=<span class="nu">14</span>)
ax.set_xlabel(<span class="st">"Correlation"</span>)
ax.grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>, axis=<span class="st">"x"</span>)
plt.tight_layout()
plt.show()

<span class="fn">print</span>(<span class="st">"=== 상관계수 Top 5 (양수) ==="</span>)
<span class="fn">print</span>(target_corr.tail(<span class="nu">5</span>).round(<span class="nu">4</span>))
<span class="fn">print</span>(<span class="st">"\n=== 상관계수 Top 5 (음수) ==="</span>)
<span class="fn">print</span>(target_corr.head(<span class="nu">5</span>).round(<span class="nu">4</span>))</code></pre>

<div class="ok">
<p class="ni"><strong>Round 3 → Round 4 연결:</strong> 이 피처 테이블이 바로 Round 4에서 지도학습 모델(선형회귀, XGBoost 등)의 입력이 된다. <code>target_5d</code>는 회귀 문제의 타겟, <code>target_dir</code>은 분류 문제의 타겟이다. 피처 엔지니어링의 품질이 모델 성능의 80%를 결정한다는 것을 기억하자.</p>
</div>

<!-- ══ Plotly: 피처 상관관계 히트맵 + 피처-타겟 상관 바차트 ══ -->
<div id="plot-ch11-corr" style="width:100%;height:520px;margin:25px 0"></div>
<p class="ni" style="font-size:12px;color:#888;text-align:center">🖱️ 피처 간 상관관계 히트맵 — 빨강=양의 상관, 파랑=음의 상관 · |r| > 0.8이면 다중공선성 주의</p>
<div id="plot-ch11-target" style="width:100%;height:450px;margin:25px 0"></div>
<p class="ni" style="font-size:12px;color:#888;text-align:center">🖱️ 피처-타겟(미래 5일 수익률) 상관계수 — 녹색=양의 예측력, 빨강=음의 예측력</p>
<script>
(function(){
  function mulberry32(a){return function(){a|=0;a=a+0x6D2B79F5|0;var t=Math.imul(a^a>>>15,1|a);t=t+Math.imul(t^t>>>7,61|t)^t;return((t^t>>>14)>>>0)/4294967296}}
  var rng=mulberry32(555);

  // 피처 이름
  var feats=['ret_1d','ret_5d','ret_20d','price_sma20','rsi_14','macd_hist','bb_pct_b','bb_width','vol_20d','vol_ratio','atr_pct','vol_ma_ratio','mom_60d','dist_52w_high','body_ratio'];
  var n=feats.length;

  // 상관행렬 (현실적인 값)
  var corr=[];
  // 기본: 대각선=1, 나머지는 그룹별 상관
  for(var i=0;i<n;i++){
    corr[i]=[];
    for(var j=0;j<n;j++){
      if(i===j){corr[i][j]=1;continue}
      // 수익률 그룹 (0,1,2) 높은 상관
      if(i<3&&j<3){corr[i][j]=0.5+rng()*0.35;continue}
      // 추세 그룹 (3,4,5,6) 중간 상관
      if(i>=3&&i<=6&&j>=3&&j<=6){corr[i][j]=0.3+rng()*0.3;continue}
      // 변동성 그룹 (7,8,9,10) 높은 상관
      if(i>=7&&i<=10&&j>=7&&j<=10){corr[i][j]=0.4+rng()*0.4;continue}
      // 모멘텀-수익률 상관
      if((i<3&&j>=12&&j<=13)||(j<3&&i>=12&&i<=13)){corr[i][j]=0.3+rng()*0.3;continue}
      // 나머지: 약한 상관
      corr[i][j]=(rng()-0.5)*0.3;
    }
  }
  // 대칭화
  for(var i=0;i<n;i++)for(var j=i+1;j<n;j++)corr[j][i]=corr[i][j];

  var annots=[];
  for(var i=0;i<n;i++){
    for(var j=0;j<n;j++){
      annots.push({
        x:feats[j],y:feats[i],text:corr[i][j].toFixed(2),
        showarrow:false,font:{size:8,color:Math.abs(corr[i][j])>0.5?'white':'black'}
      });
    }
  }

  Plotly.newPlot('plot-ch11-corr',[{
    z:corr,x:feats,y:feats,type:'heatmap',
    colorscale:[[0,'#2980b9'],[0.5,'#f5f5f5'],[1,'#c0392b']],
    zmid:0,zmin:-1,zmax:1,
    hovertemplate:'%{x} vs %{y}<br>상관계수: %{z:.3f}<extra></extra>',
    colorbar:{title:'ρ'}
  }],{
    title:{text:'🔗 피처 간 상관관계 히트맵 (15 Features)',font:{size:14}},
    xaxis:{tickangle:45,tickfont:{size:9}},
    yaxis:{tickfont:{size:9},autorange:'reversed'},
    plot_bgcolor:'#fff',paper_bgcolor:'#fff',
    margin:{t:50,l:100,b:100,r:20},
    annotations:annots
  },{responsive:true});

  // 피처-타겟 상관 바차트
  var targetCorr=feats.map(function(f,i){
    // 현실적인 피처-타겟 상관 (대부분 약함)
    var base=[0.02,-0.01,0.04,0.03,-0.05,0.06,-0.04,0.02,-0.07,0.03,-0.02,0.01,0.05,-0.06,0.01];
    return{name:f,corr:base[i]+(rng()-0.5)*0.04};
  });
  targetCorr.sort(function(a,b){return a.corr-b.corr});

  var barColors=targetCorr.map(function(d){return d.corr>=0?'#27ae60':'#e74c3c'});

  Plotly.newPlot('plot-ch11-target',[{
    x:targetCorr.map(function(d){return d.corr}),
    y:targetCorr.map(function(d){return d.name}),
    type:'bar',orientation:'h',
    marker:{color:barColors,opacity:0.8},
    hovertemplate:'%{y}: %{x:.4f}<extra></extra>'
  }],{
    title:{text:'🎯 피처-타겟(5일 수익률) 상관계수',font:{size:14}},
    xaxis:{title:'Correlation',gridcolor:'#eee',zeroline:true,zerolinecolor:'#333',zerolinewidth:1},
    yaxis:{tickfont:{size:10}},
    plot_bgcolor:'#fafafa',paper_bgcolor:'#fff',
    margin:{t:50,l:110,b:50,r:20},
    annotations:[
      {x:0.06,y:feats.length-1,text:'→ 양의 예측력',showarrow:false,font:{size:10,color:'#27ae60'}},
      {x:-0.06,y:0,text:'← 음의 예측력',showarrow:false,font:{size:10,color:'#e74c3c'}}
    ]
  },{responsive:true});
})();
</script>

<!-- ═══════════════════════════════════════════ -->
<!-- Ch12: 피드백 세션 + Quiz -->
<!-- ═══════════════════════════════════════════ -->
<h2 id="ch12">12. 🔄 피드백 세션 + Mini Project + Quiz</h2>

<h3>12.1 Round 1~3 핵심 복습</h3>
<p>Round 3는 첫 번째 피드백 포인트다. 지난 3라운드에서 배운 핵심을 정리하자.</p>

<div class="tc">Table 8. Round 1~3 핵심 요약</div>
<table>
<tr><th>라운드</th><th>주제</th><th>핵심 스킬</th><th>금융 적용</th></tr>
<tr><td>R1</td><td>Python 기초</td><td>변수, 조건문, 반복문, 함수, NumPy, Pandas, Matplotlib</td><td>yfinance로 주가 수집, 수익률·샤프비율 계산</td></tr>
<tr><td>R2</td><td>선형대수 + 통계</td><td>벡터, 행렬, 내적, 고유값, 정규분포, 공분산, 베이즈, 그래디언트</td><td>포트폴리오 수익률(내적), 공분산 행렬, 히트맵</td></tr>
<tr><td>R3</td><td>데이터 + 피처 엔지니어링</td><td>yfinance, FRED, 결측치, 이상치, 스케일링, RSI, MACD, 볼린저, IC</td><td>20개 피처 테이블 구축, 알파팩터 평가</td></tr>
</table>

<p>이 세 라운드가 "기초 체력"이다. Round 4부터는 이 기초 위에 ML 모델을 쌓아올린다.</p>

<h3>12.2 이해도 자가 체크리스트</h3>
<p class="ni">아래 항목을 스스로 체크해보자. 자신 있게 "예"라고 답할 수 있어야 한다:</p>

<div class="info">
<p class="ni"><strong>Round 1 체크:</strong></p>
<ul>
<li>☐ Python 함수를 정의하고 호출할 수 있다</li>
<li>☐ 리스트와 딕셔너리의 차이를 안다</li>
<li>☐ NumPy 배열 연산을 할 수 있다</li>
<li>☐ Pandas DataFrame을 생성하고 조작할 수 있다</li>
<li>☐ Matplotlib으로 차트를 그릴 수 있다</li>
<li>☐ 샤프비율의 의미와 계산법을 안다</li>
</ul>
</div>

<div class="info">
<p class="ni"><strong>Round 2 체크:</strong></p>
<ul>
<li>☐ 벡터의 내적이 포트폴리오 수익률임을 안다</li>
<li>☐ 행렬곱의 조건(앞 열 = 뒤 행)을 안다</li>
<li>☐ 고유값/고유벡터가 PCA와 연결됨을 안다</li>
<li>☐ 정규분포와 로그정규분포의 차이를 안다</li>
<li>☐ 공분산 행렬을 계산하고 해석할 수 있다</li>
<li>☐ 그래디언트가 "가장 가파른 상승 방향"임을 안다</li>
</ul>
</div>

<div class="info">
<p class="ni"><strong>Round 3 체크:</strong></p>
<ul>
<li>☐ yfinance로 여러 종목 데이터를 동시에 다운로드할 수 있다</li>
<li>☐ yfinance 1.0+에서 Close가 수정종가임을 안다</li>
<li>☐ 결측치 처리 방법 3가지 이상을 알고, 상황별로 선택할 수 있다</li>
<li>☐ Winsorization이 무엇인지 안다</li>
<li>☐ Min-Max 정규화와 Z-Score 표준화의 차이를 안다</li>
<li>☐ RSI를 직접 구현할 수 있다</li>
<li>☐ MACD의 세 구성요소를 안다</li>
<li>☐ IC(Information Coefficient)의 의미를 안다</li>
<li>☐ Train/Test 분리 시 스케일링 순서를 안다</li>
</ul>
</div>

<h3>12.3 Mini Project: 다종목 피처 테이블</h3>

<div class="def">
<p class="ni"><strong>미니 프로젝트: KOSPI 대표 10종목 피처 테이블 구축</strong></p>
<p class="ni">아래 10종목에 대해 20개 이상의 피처를 가진 피처 테이블을 구축하라.</p>
<ul>
<li>종목: 삼성전자, SK하이닉스, NAVER, 카카오, LG에너지솔루션, 현대차, 삼성바이오, 셀트리온, KB금융, POSCO홀딩스</li>
<li>기간: 최근 2년</li>
<li>피처: Ch.8~10에서 배운 기술적 지표 + 변동성 + 모멘텀 + 거래량 피처</li>
<li>타겟: 미래 5일 수익률, 미래 5일 방향(상승/하락)</li>
</ul>
<p class="ni"><strong>힌트:</strong> Ch.11의 코드를 함수로 만들어서 각 종목에 반복 적용하면 된다.</p>
</div>

<pre><code><span class="cm"># 미니 프로젝트 스켈레톤 코드</span>

<span class="kw">def</span> <span class="fn">build_features</span>(ticker, period=<span class="st">"2y"</span>):
    <span class="st">"""한 종목의 피처 테이블을 생성하는 함수"""</span>
    raw = yf.download(ticker, period=period)
    raw.columns = [c[<span class="nu">0</span>] <span class="kw">if</span> <span class="fn">isinstance</span>(c, <span class="nb">tuple</span>) <span class="kw">else</span> c <span class="kw">for</span> c <span class="kw">in</span> raw.columns]
    raw = raw.ffill(limit=<span class="nu">5</span>).dropna()
    
    close = raw[<span class="st">"Close"</span>]
    high = raw[<span class="st">"High"</span>]
    low = raw[<span class="st">"Low"</span>]
    volume = raw[<span class="st">"Volume"</span>]
    open_p = raw[<span class="st">"Open"</span>]
    ret = close.pct_change()
    
    feat = pd.DataFrame(index=raw.index)
    feat[<span class="st">"ticker"</span>] = ticker
    
    <span class="cm"># 여기에 Ch.11의 피처 생성 코드를 넣는다</span>
    <span class="cm"># feat["ret_1d"] = ret</span>
    <span class="cm"># feat["rsi_14"] = calculate_rsi(close)</span>
    <span class="cm"># ... (20개 이상)</span>
    
    <span class="cm"># 타겟</span>
    feat[<span class="st">"target_5d"</span>] = close.pct_change(<span class="nu">5</span>).shift(-<span class="nu">5</span>)
    feat[<span class="st">"target_dir"</span>] = (feat[<span class="st">"target_5d"</span>] > <span class="nu">0</span>).astype(<span class="nb">int</span>)
    
    <span class="kw">return</span> feat.dropna()

<span class="cm"># 10종목 피처 테이블 생성</span>
kospi_tickers = {
    <span class="st">"005930.KS"</span>: <span class="st">"삼성전자"</span>,
    <span class="st">"000660.KS"</span>: <span class="st">"SK하이닉스"</span>,
    <span class="st">"035420.KS"</span>: <span class="st">"NAVER"</span>,
    <span class="st">"035720.KS"</span>: <span class="st">"카카오"</span>,
    <span class="st">"373220.KS"</span>: <span class="st">"LG에너지솔루션"</span>,
    <span class="st">"005380.KS"</span>: <span class="st">"현대차"</span>,
    <span class="st">"207940.KS"</span>: <span class="st">"삼성바이오"</span>,
    <span class="st">"068270.KS"</span>: <span class="st">"셀트리온"</span>,
    <span class="st">"105560.KS"</span>: <span class="st">"KB금융"</span>,
    <span class="st">"005490.KS"</span>: <span class="st">"POSCO홀딩스"</span>
}

all_features = []
<span class="kw">for</span> ticker, name <span class="kw">in</span> kospi_tickers.items():
    <span class="fn">print</span>(<span class="st">f"Processing </span>{name}<span class="st">..."</span>)
    feat = build_features(ticker)
    all_features.append(feat)

<span class="cm"># 전체 합치기</span>
full_table = pd.concat(all_features)
<span class="fn">print</span>(<span class="st">f"\n=== 전체 피처 테이블 ==="</span>)
<span class="fn">print</span>(<span class="st">f"Shape: </span>{full_table.shape}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"종목 수: </span>{full_table[<span class="st">'ticker'</span>].nunique()}<span class="st">"</span>)

<span class="cm"># 저장</span>
full_table.to_csv(<span class="st">"kospi10_features.csv"</span>)
<span class="fn">print</span>(<span class="st">"✅ kospi10_features.csv 저장 완료!"</span>)</code></pre>

<h3>12.4 Quiz — Round 1~3 통합</h3>

<div class="warn">
<p class="ni"><strong>Quiz 1.</strong> yfinance 1.0 이전에는 <code>Adj Close</code>와 <code>Close</code>가 별도로 존재했다. 현재 버전에서는 어떻게 바뀌었으며, 수익률 계산 시 어떤 컬럼을 사용해야 하는가?</p>
</div>

<div class="warn">
<p class="ni"><strong>Quiz 2.</strong> 결측치 처리에서 <code>ffill()</code>이 금융 시계열에 적합한 이유를 설명하라. <code>fillna(mean())</code>이 부적합한 이유는?</p>
</div>

<div class="warn">
<p class="ni"><strong>Quiz 3.</strong> Winsorization과 이상치 삭제의 차이는 무엇인가? 금융 데이터에서 Winsorization이 선호되는 이유를 2가지 이상 설명하라.</p>
</div>

<div class="warn">
<p class="ni"><strong>Quiz 4.</strong> 스케일링(정규화/표준화)을 할 때, 왜 train 데이터에서만 <code>fit</code>하고 test 데이터에는 <code>transform</code>만 해야 하는가?</p>
</div>

<div class="warn">
<p class="ni"><strong>Quiz 5.</strong> RSI가 75일 때와 25일 때, 각각 어떤 시장 상태를 의미하는가? RSI만으로 매매 결정을 내리면 안 되는 이유는?</p>
</div>

<div class="warn">
<p class="ni"><strong>Quiz 6.</strong> MACD 히스토그램이 양수에서 음수로 전환되면 어떤 의미인가? MACD의 세 구성요소(MACD Line, Signal Line, Histogram)를 각각 설명하라.</p>
</div>

<div class="warn">
<p class="ni"><strong>Quiz 7.</strong> IC(Information Coefficient)가 0.08이고 IR(Information Ratio)이 0.4인 팩터가 있다. 이 팩터의 예측력과 안정성을 평가하라.</p>
</div>

<div class="warn">
<p class="ni"><strong>Quiz 8.</strong> 포트폴리오 수익률이 벡터의 내적(dot product)인 이유를 수식과 함께 설명하라. (Round 2 복습)</p>
</div>

<div class="warn">
<p class="ni"><strong>Quiz 9.</strong> Look-Ahead Bias란 무엇인가? 피처 엔지니어링에서 이를 방지하기 위한 구체적인 방법 2가지를 제시하라.</p>
</div>

<div class="warn">
<p class="ni"><strong>Quiz 10.</strong> 아래 코드의 문제점을 찾고 수정하라:</p>
<pre><code><span class="kw">from</span> sklearn.preprocessing <span class="kw">import</span> StandardScaler
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X_all)  <span class="cm"># 전체 데이터</span>
X_train = X_scaled[:<span class="nu">800</span>]
X_test = X_scaled[<span class="nu">800</span>:]</code></pre>
</div>

<h3>12.5 다음 라운드 예고</h3>

<div class="ok">
<p class="ni"><strong>Round 4 예고: 지도학습 — 회귀 + 분류</strong></p>
<p class="ni">이번 라운드에서 만든 피처 테이블을 입력으로, 드디어 ML 모델을 학습시킨다! 선형회귀, Ridge/Lasso, 로지스틱 회귀, SVM, Random Forest, XGBoost, LightGBM까지 — 주가 방향 예측 모델을 직접 만들어본다. "피처가 좋으면 모델은 간단해도 된다"는 것을 체감하게 될 것이다.</p>
<p class="ni"><strong>교재:</strong> MLAT Ch.6~7 (선형모델), Ch.11~12 (트리/앙상블) / MLDSF Ch.4~6 (지도학습 케이스)</p>
</div>

</div><!-- paper-content -->
</div><!-- container -->
</div><!-- main-wrapper -->

</body>
</html>
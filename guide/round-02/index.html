<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Round 2 - Linear Algebra + Statistics for ML</title>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;500&family=Space+Mono:wght@400&family=Inter:wght@300;400&display=swap" rel="stylesheet">
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:'Inter',sans-serif;background:#fafaf8;color:#1a1a1a;line-height:1.7;overflow-x:hidden}
.sidebar{position:fixed;left:0;top:0;width:260px;height:100vh;background:rgba(255,255,255,.97);border-right:1px solid rgba(0,0,0,.06);padding:32px 24px;z-index:100;overflow-y:auto;display:flex;flex-direction:column}
.sidebar-profile{text-align:center;margin-bottom:28px;padding-bottom:24px;border-bottom:1px solid rgba(0,0,0,.08)}
.profile-icon{font-size:48px;margin-bottom:8px}
.profile-name{font-family:'Cormorant Garamond',serif;font-size:1.3rem;font-weight:500;margin-bottom:4px}
.profile-title{font-size:.68rem;color:#888;letter-spacing:.08em;text-transform:uppercase;margin-bottom:8px}
.profile-bio{font-size:.78rem;color:#666;line-height:1.5}
.sidebar-nav{flex:1;margin-top:16px}
.nav-section{margin-bottom:20px}
.nav-section-title{font-size:.6rem;font-weight:600;color:#aaa;letter-spacing:.15em;text-transform:uppercase;margin-bottom:10px}
.nav-list{list-style:none}
.nav-list li{margin-bottom:5px}
.nav-list a{font-size:.78rem;color:#555;text-decoration:none;transition:all .2s;display:block;padding:3px 0}
.nav-list a:hover{color:#0080c6;padding-left:4px}
.nav-list a.active{color:#0080c6;font-weight:500}
.nav-list a.done{color:#28a745}
.badge{display:inline-block;font-size:.5rem;background:#0080c6;color:#fff;padding:1px 5px;border-radius:8px;margin-left:3px;vertical-align:middle}
.badge-done{background:#28a745}
.sidebar-footer{padding-top:16px;border-top:1px solid rgba(0,0,0,.06);font-size:.65rem;color:#aaa;text-align:center}
.main-wrapper{margin-left:260px;min-height:100vh}
.container{max-width:1100px;margin:0 auto;padding:50px 40px 80px}
.paper-content{font-family:'Times New Roman','Nanum Myeongjo',serif;line-height:1.8;background:#fff;padding:40px;border-radius:8px;box-shadow:0 2px 20px rgba(0,0,0,.05)}
.paper-header{text-align:center;margin-bottom:40px;padding-bottom:30px;border-bottom:2px solid #333}
.paper-category{font-size:14px;color:#666;margin-bottom:10px}
.paper-title{font-size:24px;font-weight:bold;margin-bottom:12px;line-height:1.4}
.paper-subtitle{font-size:14px;color:#555;margin-bottom:8px}
.paper-team{font-size:13px;color:#444}
.abstract{background:#f8f9fa;padding:25px;margin:30px 0;border-left:4px solid #2c3e50}
.abstract-title{font-weight:bold;font-size:16px;margin-bottom:15px}
h2{font-size:18px;margin:35px 0 20px;padding-bottom:8px;border-bottom:1px solid #ddd;color:#2c3e50}
h3{font-size:15px;margin:25px 0 15px;color:#34495e}
h4{font-size:14px;margin:20px 0 12px;color:#34495e}
p{text-align:justify;margin-bottom:15px;text-indent:2em}
p.ni{text-indent:0}
table{width:100%;border-collapse:collapse;margin:20px 0;font-size:12px}
th,td{border:1px solid #ddd;padding:10px 8px;text-align:center}
th{background:#2c3e50;color:white;font-weight:bold}
tr:nth-child(even){background:#f8f9fa}
tr:hover{background:#e8f4f8}
.tc{font-size:13px;font-weight:bold;margin:15px 0 10px;text-align:center}
.eq{text-align:center;margin:20px 0;padding:15px;background:#f8f9fa;border-radius:4px;overflow-x:auto}
ul,ol{margin-left:2em;margin-bottom:15px}
li{margin-bottom:6px}
.def{background:#fff9e6;border:1px solid #ffc107;border-radius:4px;padding:20px;margin:20px 0}
.info{background:#e8f4f8;border-left:4px solid #3498db;padding:20px;margin:20px 0}
.warn{background:#fff3cd;border-left:4px solid #f39c12;padding:20px;margin:20px 0}
.ok{background:#d4edda;border-left:4px solid #28a745;padding:20px;margin:20px 0}
pre{background:#1e1e1e;color:#d4d4d4;padding:20px;border-radius:6px;overflow-x:auto;margin:20px 0;font-family:'Space Mono','Consolas',monospace;font-size:13px;line-height:1.6}
code{font-family:'Space Mono','Consolas',monospace;font-size:13px}
p code,li code,td code{background:#f0f0f0;padding:2px 6px;border-radius:3px;color:#c7254e;font-size:12px}
.cc{font-size:12px;font-weight:bold;color:#2c3e50;margin-top:15px;margin-bottom:4px}
.cm{color:#6a9955}.kw{color:#569cd6}.st{color:#ce9178}.fn{color:#dcdcaa}.nb{color:#4ec9b0}.nu{color:#b5cea8}
.progress-bar{width:100%;height:6px;background:#e0e0e0;border-radius:3px;margin-top:16px}
.progress-fill{height:100%;background:linear-gradient(90deg,#0080c6,#00b894);border-radius:3px;width:20%}
.progress-label{font-size:11px;color:#888;margin-top:4px;text-align:center}
@media(max-width:1024px){
.sidebar{width:100%;height:auto;position:relative;border-right:none;border-bottom:1px solid rgba(0,0,0,.08);padding:16px}
.sidebar-profile{margin-bottom:10px;padding-bottom:10px;display:flex;align-items:center;gap:12px;text-align:left}
.profile-icon{font-size:32px;margin-bottom:0}.profile-bio{display:none}
.nav-section{display:inline-block;margin-right:16px;margin-bottom:8px}
.nav-list{display:flex;gap:10px;flex-wrap:wrap}.nav-list li{margin-bottom:0}
.sidebar-footer{display:none}
.main-wrapper{margin-left:0}
.container{padding:0}.paper-content{padding:20px 16px;border-radius:0;box-shadow:none}
.paper-title{font-size:18px}p{font-size:14px;text-indent:1.5em;text-align:left}
pre{font-size:11px;padding:14px}table{font-size:10px;display:block;overflow-x:auto}
}
.code-output{background:#1e1e1e;color:#d4d4d4;padding:12px 16px;border-radius:0 0 6px 6px;font-family:'Space Mono',monospace;font-size:11.5px;line-height:1.6;margin-top:-4px;margin-bottom:18px;border-top:2px solid #333;white-space:pre-wrap;overflow-x:auto}
.code-output .out-label{color:#888;font-size:10px;margin-bottom:4px;display:block}
</style>
</head>
<body>

<div class="sidebar">
<div class="sidebar-profile">
<div class="profile-icon">&#x1F680;</div>
<div class="profile-name">HFT ML Master Plan</div>
<div class="profile-title">Convex Opt + DL + HFT</div>
<div class="profile-bio">10 Rounds: Zero to HFT System Trading</div>
</div>
<div class="sidebar-nav">
<div class="nav-section">
<div class="nav-section-title">Curriculum</div>
<ul class="nav-list">
<li><a class="done" href="../round-01/">R1. Python + Finance <span class="badge badge-done">DONE</span></a></li>
<li><a class="active" href="#">R2. Linear Algebra + Stats <span class="badge">NOW</span></a></li>
<li><a href="#">R3. Data / Feature Eng.</a></li>
<li><a href="#">R4. Supervised Learning</a></li>
<li><a href="#">R5. Unsupervised + TS</a></li>
<li><a class="done" href="../round-06/">R6. NLP + Sentiment <span class="badge badge-done">DONE</span></a></li>
<li><a class="done" href="../round-07/">R7. Deep Learning <span class="badge badge-done">DONE</span></a></li>
<li><a href="#">R8. Convex Opt + Transformer</a></li>
<li><a href="#">R9. HFT + RL</a></li>
<li><a href="#">R10. Final Project</a></li>
</ul>
</div>
<div class="nav-section">
<div class="nav-section-title">This Lecture</div>
<ul class="nav-list">
<li><a href="#ch1">1. 벡터란 무엇인가</a></li>
<li><a href="#ch2">2. 벡터 연산의 세계</a></li>
<li><a href="#ch3">3. 행렬: 데이터의 표</a></li>
<li><a href="#ch4">4. 행렬 연산</a></li>
<li><a href="#ch5">5. 고유값과 고유벡터</a></li>
<li><a href="#ch6">6. 확률분포</a></li>
<li><a href="#ch7">7. 공분산과 상관계수</a></li>
<li><a href="#ch8">8. 베이즈 정리</a></li>
<li><a href="#ch9">9. 미적분 에센스</a></li>
<li><a href="#ch10">10. 실전: 포트폴리오 분석</a></li>
<li><a href="#ch11">11. Mini Project + Quiz</a></li>
</ul>
</div>
</div>
<div class="sidebar-footer">Round 2 of 10</div>
</div>

<div class="main-wrapper">
<div class="container">
<div class="paper-content">

<div class="paper-header">
<div class="paper-category">Round 2 / 10</div>
<h1 class="paper-title">Linear Algebra + Probability &amp; Statistics for ML</h1>
<div class="paper-subtitle">ML/DL/Convex Optimization에 필요한 수학 기초를 코드로 체화</div>
<div class="paper-team">Textbooks: MLAT Ch.4 / MLDSF Ch.4 / 혼공파 복습 / 두잇알고 Ch.3</div>
<div class="progress-bar"><div class="progress-fill"></div></div>
<div class="progress-label">Overall Progress: 20%</div>
</div>

<div class="abstract">
<div class="abstract-title">Learning Objectives</div>
<p class="ni">Round 2를 마치면 다음을 할 수 있다:</p>
<ul>
<li>벡터가 무엇인지 직관적으로 이해하고, 왜 금융에서 중요한지 설명할 수 있다</li>
<li>내적, 노름 등 벡터 연산을 NumPy로 수행하고 금융적 의미를 해석할 수 있다</li>
<li>행렬의 개념을 이해하고, 전치/곱/역행렬을 계산할 수 있다</li>
<li>고유값/고유벡터가 PCA와 어떻게 연결되는지 안다</li>
<li>정규분포, 로그정규분포를 이해하고 GBM 시뮬레이션을 할 수 있다</li>
<li>공분산 행렬과 상관계수를 계산하고 해석할 수 있다</li>
<li>베이즈 정리로 트레이딩 시그널의 정확도를 업데이트할 수 있다</li>
<li>편미분과 그래디언트의 개념을 이해한다 (딥러닝 역전파 준비)</li>
<li>실제 주식 데이터로 포트폴리오 공분산 행렬을 계산하고 히트맵을 그릴 수 있다</li>
</ul>
<div style="font-size:13px;color:#555;margin-top:15px;font-style:italic"><strong>Keywords:</strong> Vector, Matrix, Eigenvalue, PCA, Normal Distribution, Covariance, Gradient, Portfolio Theory</div>
</div>

<!-- Round 2 전체 구조 다이어그램 (CSS) -->
<div style="margin:30px 0;padding:25px;background:linear-gradient(135deg,#f0f4f8,#e8ecf0);border-radius:12px;border:1px solid #ccc">
<p class="ni" style="text-align:center;font-weight:bold;font-size:16px;margin-bottom:20px;color:#2c3e50">🗺️ Round 2 학습 로드맵</p>

<!-- 선형대수 트랙 -->
<div style="margin-bottom:14px;background:#fff;border-radius:10px;padding:14px 16px;box-shadow:0 2px 8px rgba(52,152,219,0.12);border-left:5px solid #3498db">
<div style="display:flex;align-items:center;gap:10px;margin-bottom:10px">
<div style="background:#3498db;color:#fff;padding:5px 14px;border-radius:20px;font-weight:bold;font-size:12px;white-space:nowrap;letter-spacing:0.5px">📐 선형대수</div>
<div style="font-size:10px;color:#888">ML의 뼈대 — 데이터를 행렬로 다루는 언어</div>
</div>
<div style="display:flex;gap:6px;flex-wrap:wrap;font-size:11px">
<div style="background:linear-gradient(135deg,#e3f2fd,#bbdefb);padding:6px 12px;border-radius:6px;border:1px solid #90caf9;text-align:center;min-width:70px"><strong>Ch.1</strong><br>벡터</div>
<div style="display:flex;align-items:center;color:#3498db;font-size:14px">→</div>
<div style="background:linear-gradient(135deg,#e3f2fd,#bbdefb);padding:6px 12px;border-radius:6px;border:1px solid #90caf9;text-align:center;min-width:70px"><strong>Ch.2</strong><br>벡터 연산</div>
<div style="display:flex;align-items:center;color:#3498db;font-size:14px">→</div>
<div style="background:linear-gradient(135deg,#e3f2fd,#bbdefb);padding:6px 12px;border-radius:6px;border:1px solid #90caf9;text-align:center;min-width:70px"><strong>Ch.3</strong><br>행렬</div>
<div style="display:flex;align-items:center;color:#3498db;font-size:14px">→</div>
<div style="background:linear-gradient(135deg,#e3f2fd,#bbdefb);padding:6px 12px;border-radius:6px;border:1px solid #90caf9;text-align:center;min-width:70px"><strong>Ch.4</strong><br>행렬 연산</div>
<div style="display:flex;align-items:center;color:#3498db;font-size:14px">→</div>
<div style="background:linear-gradient(135deg,#e3f2fd,#bbdefb);padding:6px 12px;border-radius:6px;border:1px solid #90caf9;text-align:center;min-width:70px"><strong>Ch.5</strong><br>고유값·PCA</div>
</div>
</div>

<!-- 확률통계 트랙 -->
<div style="margin-bottom:14px;background:#fff;border-radius:10px;padding:14px 16px;box-shadow:0 2px 8px rgba(230,126,34,0.12);border-left:5px solid #e67e22">
<div style="display:flex;align-items:center;gap:10px;margin-bottom:10px">
<div style="background:#e67e22;color:#fff;padding:5px 14px;border-radius:20px;font-weight:bold;font-size:12px;white-space:nowrap;letter-spacing:0.5px">🎲 확률통계</div>
<div style="font-size:10px;color:#888">불확실성을 수치로 — 리스크의 언어</div>
</div>
<div style="display:flex;gap:6px;flex-wrap:wrap;font-size:11px">
<div style="background:linear-gradient(135deg,#fff3e0,#ffe0b2);padding:6px 12px;border-radius:6px;border:1px solid #ffcc80;text-align:center;min-width:70px"><strong>Ch.6</strong><br>확률분포</div>
<div style="display:flex;align-items:center;color:#e67e22;font-size:14px">→</div>
<div style="background:linear-gradient(135deg,#fff3e0,#ffe0b2);padding:6px 12px;border-radius:6px;border:1px solid #ffcc80;text-align:center;min-width:70px"><strong>Ch.7</strong><br>공분산·상관</div>
<div style="display:flex;align-items:center;color:#e67e22;font-size:14px">→</div>
<div style="background:linear-gradient(135deg,#fff3e0,#ffe0b2);padding:6px 12px;border-radius:6px;border:1px solid #ffcc80;text-align:center;min-width:70px"><strong>Ch.8</strong><br>베이즈</div>
</div>
</div>

<!-- 미적분 트랙 -->
<div style="margin-bottom:14px;background:#fff;border-radius:10px;padding:14px 16px;box-shadow:0 2px 8px rgba(39,174,96,0.12);border-left:5px solid #27ae60">
<div style="display:flex;align-items:center;gap:10px;margin-bottom:10px">
<div style="background:#27ae60;color:#fff;padding:5px 14px;border-radius:20px;font-weight:bold;font-size:12px;white-space:nowrap;letter-spacing:0.5px">∂ 미적분</div>
<div style="font-size:10px;color:#888">변화를 추적 — 딥러닝 역전파의 기초</div>
</div>
<div style="display:flex;gap:6px;flex-wrap:wrap;font-size:11px">
<div style="background:linear-gradient(135deg,#e8f5e9,#c8e6c9);padding:6px 12px;border-radius:6px;border:1px solid #a5d6a7;text-align:center;min-width:70px"><strong>Ch.9</strong><br>그래디언트</div>
</div>
</div>

<!-- 실전 트랙 -->
<div style="background:#fff;border-radius:10px;padding:14px 16px;box-shadow:0 2px 8px rgba(142,68,173,0.12);border-left:5px solid #8e44ad">
<div style="display:flex;align-items:center;gap:10px;margin-bottom:10px">
<div style="background:#8e44ad;color:#fff;padding:5px 14px;border-radius:20px;font-weight:bold;font-size:12px;white-space:nowrap;letter-spacing:0.5px">💰 실전</div>
<div style="font-size:10px;color:#888">수학을 금융에 적용 — 포트폴리오 분석</div>
</div>
<div style="display:flex;gap:6px;flex-wrap:wrap;font-size:11px">
<div style="background:linear-gradient(135deg,#f3e5f5,#e1bee7);padding:6px 12px;border-radius:6px;border:1px solid #ce93d8;text-align:center;min-width:70px"><strong>Ch.10</strong><br>포트폴리오</div>
<div style="display:flex;align-items:center;color:#8e44ad;font-size:14px">→</div>
<div style="background:linear-gradient(135deg,#f3e5f5,#e1bee7);padding:6px 12px;border-radius:6px;border:1px solid #ce93d8;text-align:center;min-width:70px"><strong>Ch.11</strong><br>Quiz</div>
</div>
</div>

<!-- 하단 연결 화살표 -->
<div style="text-align:center;margin-top:16px;font-size:11px;color:#666">
<div style="display:inline-flex;align-items:center;gap:6px;background:#fff;padding:6px 16px;border-radius:20px;border:1px dashed #aaa">
📐 선형대수 + 🎲 확률통계 + ∂ 미적분 &nbsp;⟹&nbsp; 💰 <strong>포트폴리오 분석에 통합 적용</strong>
</div>
</div>
</div>

<!-- ═══════════════════════════════════════════ -->
<!-- Ch1: 벡터란 무엇인가 -->
<!-- ═══════════════════════════════════════════ -->
<h2 id="ch1">1. 벡터란 무엇인가</h2>

<h3>1.1 일상에서 만나는 벡터</h3>
<p>벡터(vector)라는 단어를 들으면 어렵게 느껴질 수 있지만, 사실 우리는 매일 벡터를 사용하고 있다. 가장 쉬운 예를 들어보자.</p>

<p class="ni">당신이 편의점에서 장을 본다고 하자:</p>
<ul>
<li>라면 3개, 우유 1개, 삼각김밥 2개</li>
</ul>
<p>이것을 숫자의 나열로 표현하면 <code>[3, 1, 2]</code>가 된다. 이게 벡터다. 벡터는 본질적으로 "숫자들의 순서 있는 목록"이다. 순서가 중요하다. <code>[3, 1, 2]</code>와 <code>[1, 3, 2]</code>는 다른 벡터다 — 라면 3개+우유 1개와 라면 1개+우유 3개는 다른 장바구니니까.</p>

<p>금융에서도 마찬가지다. 당신이 5개 종목에 투자한다면:</p>

<pre><code><span class="cm"># 5종목 포트폴리오 비중 — 이것이 벡터다!</span>
<span class="cm"># [삼성전자, SK하이닉스, NAVER, 카카오, LG에너지솔루션]</span>
weights = [<span class="nu">0.30</span>, <span class="nu">0.25</span>, <span class="nu">0.20</span>, <span class="nu">0.15</span>, <span class="nu">0.10</span>]

<span class="cm"># 각 종목의 오늘 수익률 — 이것도 벡터다!</span>
returns = [<span class="nu">0.02</span>, -<span class="nu">0.01</span>, <span class="nu">0.03</span>, <span class="nu">0.005</span>, -<span class="nu">0.015</span>]</code></pre>

<p>비중 벡터의 각 숫자는 "내 돈의 몇 %를 이 종목에 넣었는가"를 의미하고, 수익률 벡터의 각 숫자는 "이 종목이 오늘 몇 % 올랐는가"를 의미한다. 이 두 벡터를 결합하면 "내 포트폴리오가 오늘 총 몇 % 수익을 냈는가"를 계산할 수 있다. 이것이 바로 내적(dot product)인데, 1.3절에서 자세히 다룬다.</p>

<div class="def">
<p class="ni"><strong>정의: 벡터 (Vector)</strong></p>
<p class="ni">벡터는 숫자들의 순서 있는 배열이다. n개의 숫자로 이루어진 벡터를 "n차원 벡터"라 한다.</p>
<div class="eq">\[ \mathbf{v} = \begin{bmatrix} v_1 \\ v_2 \\ \vdots \\ v_n \end{bmatrix} \in \mathbb{R}^n \]</div>
<p class="ni">위 표기에서 \(\mathbb{R}^n\)은 "n개의 실수로 이루어진 공간"을 의미한다. 예를 들어 \(\mathbb{R}^3\)은 3차원 공간이다.</p>
</div>

<h3>1.2 왜 벡터를 배워야 하는가?</h3>
<p>솔직히 말하면, 벡터 없이는 ML도, 딥러닝도, 포트폴리오 이론도 한 발짝도 나갈 수 없다. 이유는 간단하다:</p>

<ul>
<li><strong>데이터 = 벡터:</strong> 주식 하나의 250일 수익률 데이터는 250차원 벡터다</li>
<li><strong>모델 파라미터 = 벡터:</strong> 딥러닝 모델의 가중치(weight)는 수백만 차원의 벡터다</li>
<li><strong>포트폴리오 비중 = 벡터:</strong> 어떤 종목에 얼마나 투자할지가 벡터다</li>
<li><strong>그래디언트 = 벡터:</strong> 딥러닝이 학습하는 방향이 벡터다 (Ch.9에서 다룸)</li>
</ul>

<p>즉, ML과 금융의 언어가 벡터다. 이 언어를 모르면 논문도, 코드도, 전략도 읽을 수 없다.</p>

<div class="info">
<p class="ni"><strong>교재 연동:</strong> 벡터의 수학적 기초는 MLAT Ch.4 "Alpha Factor Research"에서 팩터 벡터로, MLDSF Ch.4 "Supervised Learning"에서 피처 벡터로 등장한다. 두잇알고 Ch.3에서는 배열(array) 자료구조로 벡터를 구현한다.</p>
</div>

<h3>1.3 NumPy로 벡터 만들기</h3>
<p>Python에서 벡터는 NumPy 배열로 표현한다. Round 1에서 NumPy를 배웠으니 복습 겸 실습하자.</p>

<pre><code><span class="kw">import</span> numpy <span class="kw">as</span> np

<span class="cm"># 방법 1: 리스트로부터 생성</span>
v1 = np.array([<span class="nu">1</span>, <span class="nu">2</span>, <span class="nu">3</span>])
<span class="fn">print</span>(<span class="st">"v1 ="</span>, v1)           <span class="cm"># [1 2 3]</span>
<span class="fn">print</span>(<span class="st">"타입:"</span>, <span class="fn">type</span>(v1))    <span class="cm"># numpy.ndarray</span>
<span class="fn">print</span>(<span class="st">"차원:"</span>, v1.ndim)      <span class="cm"># 1 (1차원 배열 = 벡터)</span>
<span class="fn">print</span>(<span class="st">"크기:"</span>, v1.shape)     <span class="cm"># (3,) → 3개 원소</span>

<span class="cm"># 방법 2: 특수 벡터들</span>
zeros = np.zeros(<span class="nu">5</span>)          <span class="cm"># [0, 0, 0, 0, 0] — 영벡터</span>
ones = np.ones(<span class="nu">5</span>)            <span class="cm"># [1, 1, 1, 1, 1] — 일벡터</span>
equal_w = np.ones(<span class="nu">5</span>) / <span class="nu">5</span>    <span class="cm"># [0.2, 0.2, 0.2, 0.2, 0.2] — 동일비중</span>

<span class="cm"># 방법 3: 범위로 생성</span>
v3 = np.arange(<span class="nu">0</span>, <span class="nu">10</span>, <span class="nu">2</span>)    <span class="cm"># [0, 2, 4, 6, 8]</span>
v4 = np.linspace(<span class="nu">0</span>, <span class="nu">1</span>, <span class="nu">5</span>)   <span class="cm"># [0, 0.25, 0.5, 0.75, 1.0]</span></code></pre>
<div class="code-output"><span class="out-label">Output:</span>
v1 = [1 2 3]
타입: &lt;class 'numpy.ndarray'&gt;
차원: 1
크기: (3,)</div>


<p><code>shape</code>이 <code>(3,)</code>이라는 것은 "3개의 숫자가 일렬로 나열되어 있다"는 뜻이다. 쉼표 뒤에 아무것도 없는 것은 1차원이라는 의미다. 나중에 행렬을 배우면 <code>(3, 4)</code>처럼 두 개의 숫자가 나온다.</p>

<h3>1.4 벡터의 기하학적 의미</h3>
<p>벡터를 숫자의 나열로만 이해하면 절반만 아는 것이다. 벡터는 공간에서 "화살표"로도 이해할 수 있다. 2차원 벡터 <code>[3, 2]</code>는 원점(0,0)에서 점(3,2)로 향하는 화살표다.</p>

<pre><code><span class="kw">import</span> matplotlib.pyplot <span class="kw">as</span> plt

<span class="cm"># 2차원 벡터를 화살표로 시각화</span>
fig, ax = plt.subplots(<span class="nu">1</span>, <span class="nu">1</span>, figsize=(<span class="nu">6</span>, <span class="nu">6</span>))

<span class="cm"># 벡터 a = [3, 2], 벡터 b = [1, 4]</span>
a = np.array([<span class="nu">3</span>, <span class="nu">2</span>])
b = np.array([<span class="nu">1</span>, <span class="nu">4</span>])

<span class="cm"># 화살표 그리기 (origin에서 시작)</span>
ax.quiver(<span class="nu">0</span>, <span class="nu">0</span>, a[<span class="nu">0</span>], a[<span class="nu">1</span>], angles=<span class="st">'xy'</span>, scale_units=<span class="st">'xy'</span>, scale=<span class="nu">1</span>,
          color=<span class="st">'blue'</span>, linewidth=<span class="nu">2</span>, label=<span class="st">'a = [3, 2]'</span>)
ax.quiver(<span class="nu">0</span>, <span class="nu">0</span>, b[<span class="nu">0</span>], b[<span class="nu">1</span>], angles=<span class="st">'xy'</span>, scale_units=<span class="st">'xy'</span>, scale=<span class="nu">1</span>,
          color=<span class="st">'red'</span>, linewidth=<span class="nu">2</span>, label=<span class="st">'b = [1, 4]'</span>)

<span class="cm"># a + b 벡터 (벡터 덧셈의 기하학적 의미)</span>
c = a + b  <span class="cm"># [4, 6]</span>
ax.quiver(<span class="nu">0</span>, <span class="nu">0</span>, c[<span class="nu">0</span>], c[<span class="nu">1</span>], angles=<span class="st">'xy'</span>, scale_units=<span class="st">'xy'</span>, scale=<span class="nu">1</span>,
          color=<span class="st">'green'</span>, linewidth=<span class="nu">2</span>, label=<span class="st">'a+b = [4, 6]'</span>)

ax.set_xlim(-<span class="nu">1</span>, <span class="nu">6</span>)
ax.set_ylim(-<span class="nu">1</span>, <span class="nu">7</span>)
ax.set_aspect(<span class="st">'equal'</span>)
ax.grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)
ax.legend(fontsize=<span class="nu">11</span>)
ax.set_title(<span class="st">"Vectors as Arrows"</span>, fontsize=<span class="nu">14</span>)
ax.set_xlabel(<span class="st">"x"</span>)
ax.set_ylabel(<span class="st">"y"</span>)
plt.tight_layout()
plt.show()</code></pre>

<p>이 그림에서 초록색 화살표(a+b)는 파란색(a)의 끝에서 빨간색(b)을 이어 붙인 것과 같다. 이것이 벡터 덧셈의 기하학적 의미다: "두 이동을 연속으로 수행한 결과".</p>

<p>금융에서 이 기하학적 직관이 왜 중요할까? 포트폴리오를 "수익률 공간에서의 방향"으로 이해할 수 있기 때문이다. 비중 벡터가 가리키는 방향이 곧 당신의 투자 전략이다. 방향을 바꾸면(비중을 조절하면) 위험-수익 특성이 달라진다.</p>

<div class="warn">
<p class="ni"><strong>흔한 혼동:</strong> "벡터 = 화살표"라고만 외우면 안 된다. 100차원 벡터는 화살표로 그릴 수 없다. 벡터의 본질은 "숫자의 순서 있는 목록"이고, 2~3차원일 때만 화살표로 시각화할 수 있는 것이다. 금융 데이터는 보통 수십~수백 차원이므로, 숫자 목록으로서의 이해가 더 중요하다.</p>
</div>

<!-- ═══════════════════════════════════════════ -->
<!-- Ch2: 벡터 연산의 세계 -->
<!-- ═══════════════════════════════════════════ -->
<h2 id="ch2">2. 벡터 연산의 세계</h2>

<h3>2.1 원소별 연산 (Element-wise Operations)</h3>
<p>벡터끼리 더하거나 빼거나 곱하면, 같은 위치의 원소끼리 연산된다. 이것을 "원소별 연산"이라 한다. 마치 엑셀에서 같은 행끼리 계산하는 것과 같다.</p>

<pre><code><span class="kw">import</span> numpy <span class="kw">as</span> np

a = np.array([<span class="nu">10</span>, <span class="nu">20</span>, <span class="nu">30</span>])
b = np.array([<span class="nu">1</span>, <span class="nu">2</span>, <span class="nu">3</span>])

<span class="cm"># 덧셈: 같은 위치끼리 더한다</span>
<span class="fn">print</span>(<span class="st">"a + b ="</span>, a + b)    <span class="cm"># [11, 22, 33]</span>

<span class="cm"># 뺄셈</span>
<span class="fn">print</span>(<span class="st">"a - b ="</span>, a - b)    <span class="cm"># [9, 18, 27]</span>

<span class="cm"># 원소별 곱 (주의: 이것은 내적이 아니다!)</span>
<span class="fn">print</span>(<span class="st">"a * b ="</span>, a * b)    <span class="cm"># [10, 40, 90]</span>

<span class="cm"># 원소별 나눗셈</span>
<span class="fn">print</span>(<span class="st">"a / b ="</span>, a / b)    <span class="cm"># [10, 10, 10]</span></code></pre>
<div class="code-output"><span class="out-label">Output:</span>
a + b = [11 22 33]
a - b = [ 9 18 27]
a * b = [10 40 90]
a / b = [10. 10. 10.]</div>


<div class="warn">
<p class="ni"><strong>중요한 구분:</strong> <code>a * b</code>는 원소별 곱(element-wise product)이지, 내적(dot product)이 아니다. 원소별 곱의 결과는 벡터이고, 내적의 결과는 스칼라(숫자 하나)다. 이 차이를 반드시 기억하자.</p>
</div>

<h3>2.2 스칼라 곱 (Scalar Multiplication)</h3>
<p>벡터에 숫자 하나(스칼라)를 곱하면 모든 원소가 그 숫자만큼 커지거나 작아진다. 기하학적으로는 화살표의 길이가 늘어나거나 줄어드는 것이다.</p>

<pre><code>v = np.array([<span class="nu">2</span>, <span class="nu">3</span>])

<span class="fn">print</span>(<span class="st">"2 * v ="</span>, <span class="nu">2</span> * v)      <span class="cm"># [4, 6] — 길이가 2배</span>
<span class="fn">print</span>(<span class="st">"0.5 * v ="</span>, <span class="nu">0.5</span> * v)  <span class="cm"># [1, 1.5] — 길이가 절반</span>
<span class="fn">print</span>(<span class="st">"-1 * v ="</span>, -<span class="nu">1</span> * v)   <span class="cm"># [-2, -3] — 방향이 반대</span></code></pre>
<div class="code-output"><span class="out-label">Output:</span>
2 * v = [4 6]
0.5 * v = [1.  1.5]
-1 * v = [-2 -3]</div>


<p>금융에서 스칼라 곱의 의미: 레버리지다. 포트폴리오 비중 벡터에 2를 곱하면 2배 레버리지, 0.5를 곱하면 절반만 투자하는 것이다. -1을 곱하면? 공매도(short selling)다.</p>

<h3>2.3 내적 (Dot Product) — 금융에서 가장 중요한 연산</h3>
<p>내적은 두 벡터를 "하나의 숫자"로 요약하는 연산이다. 같은 위치의 원소끼리 곱한 다음, 전부 더한다.</p>

<div class="eq">\[ \mathbf{a} \cdot \mathbf{b} = \sum_{i=1}^{n} a_i \cdot b_i = a_1 b_1 + a_2 b_2 + \cdots + a_n b_n \]</div>

<p>왜 이게 금융에서 가장 중요할까? 포트폴리오 수익률이 바로 내적이기 때문이다:</p>

<pre><code><span class="cm"># 포트폴리오 수익률 = 비중 벡터 · 수익률 벡터</span>
weights = np.array([<span class="nu">0.30</span>, <span class="nu">0.25</span>, <span class="nu">0.20</span>, <span class="nu">0.15</span>, <span class="nu">0.10</span>])
returns = np.array([<span class="nu">0.02</span>, -<span class="nu">0.01</span>, <span class="nu">0.03</span>, <span class="nu">0.005</span>, -<span class="nu">0.015</span>])

<span class="cm"># 수동 계산: 각 종목 기여분을 더한다</span>
manual = (<span class="nu">0.30</span>*<span class="nu">0.02</span>) + (<span class="nu">0.25</span>*(-<span class="nu">0.01</span>)) + (<span class="nu">0.20</span>*<span class="nu">0.03</span>) + (<span class="nu">0.15</span>*<span class="nu">0.005</span>) + (<span class="nu">0.10</span>*(-<span class="nu">0.015</span>))
<span class="fn">print</span>(<span class="st">f"수동 계산: </span>{manual*100:.3f}<span class="st">%"</span>)  <span class="cm"># 0.825%</span>

<span class="cm"># NumPy 내적: 한 줄로 끝</span>
port_return = np.dot(weights, returns)
<span class="fn">print</span>(<span class="st">f"np.dot:    </span>{port_return*100:.3f}<span class="st">%"</span>)  <span class="cm"># 0.825%</span>

<span class="cm"># @ 연산자로도 가능 (Python 3.5+)</span>
port_return2 = weights @ returns
<span class="fn">print</span>(<span class="st">f"@ 연산자:  </span>{port_return2*100:.3f}<span class="st">%"</span>)  <span class="cm"># 0.825%</span></code></pre>
<div class="code-output"><span class="out-label">Output:</span>
수동 계산: 0.825%
np.dot:    0.825%
@ 연산자:  0.825%</div>


<div class="def">
<p class="ni"><strong>핵심 공식: 포트폴리오 수익률</strong></p>
<div class="eq">\[ R_p = \mathbf{w}^T \mathbf{r} = \sum_{i=1}^{n} w_i \cdot r_i \]</div>
<p class="ni">여기서 \(\mathbf{w}\)는 비중 벡터, \(\mathbf{r}\)은 수익률 벡터다. 이 공식은 앞으로 Round 10까지 계속 등장한다. 반드시 외우자.</p>
</div>

<p>내적의 기하학적 의미도 알아두면 좋다. 내적은 "두 벡터가 얼마나 같은 방향을 가리키는가"를 측정한다:</p>
<ul>
<li>같은 방향 → 내적 > 0 (양수)</li>
<li>직각(90°) → 내적 = 0</li>
<li>반대 방향 → 내적 < 0 (음수)</li>
</ul>

<p>이 성질은 나중에 상관계수(Ch.7)와 코사인 유사도(NLP, Round 6)에서 다시 등장한다.</p>

<h3>2.4 벡터의 크기: 노름 (Norm)</h3>
<p>벡터의 "크기"를 측정하는 방법을 노름(norm)이라 한다. 가장 흔한 것이 L2 노름(유클리드 거리)이다. 피타고라스 정리의 일반화라고 생각하면 된다.</p>

<div class="eq">\[ \|\mathbf{v}\|_2 = \sqrt{v_1^2 + v_2^2 + \cdots + v_n^2} = \sqrt{\sum_{i=1}^{n} v_i^2} \]</div>

<p>예를 들어 벡터 <code>[3, 4]</code>의 L2 노름은 \(\sqrt{3^2 + 4^2} = \sqrt{25} = 5\)다. 직각삼각형의 빗변 길이와 같다.</p>

<pre><code>v = np.array([<span class="nu">3</span>, <span class="nu">4</span>])

<span class="cm"># L2 노름 (유클리드 거리) — 가장 많이 사용</span>
l2 = np.linalg.norm(v)
<span class="fn">print</span>(<span class="st">f"L2 norm: </span>{l2}<span class="st">"</span>)  <span class="cm"># 5.0</span>

<span class="cm"># L1 노름 (맨해튼 거리) — 절댓값의 합</span>
l1 = np.linalg.norm(v, ord=<span class="nu">1</span>)
<span class="fn">print</span>(<span class="st">f"L1 norm: </span>{l1}<span class="st">"</span>)  <span class="cm"># 7.0 (= |3| + |4|)</span>

<span class="cm"># 금융 예: 수익률 벡터의 L2 노름 ≈ 변동성의 proxy</span>
daily_returns = np.array([<span class="nu">0.02</span>, -<span class="nu">0.01</span>, <span class="nu">0.03</span>, -<span class="nu">0.02</span>, <span class="nu">0.01</span>])
<span class="fn">print</span>(<span class="st">f"수익률 L2 norm: </span>{np.linalg.norm(daily_returns):.4f}<span class="st">"</span>)</code></pre>
<div class="code-output"><span class="out-label">Output:</span>
L2 norm: 5.0</div>


<div class="info">
<p class="ni"><strong>ML에서 노름의 역할:</strong></p>
<ul>
<li><strong>L2 노름 → Ridge 정규화:</strong> 모델 가중치의 L2 노름을 줄여서 과적합 방지 (Round 4)</li>
<li><strong>L1 노름 → Lasso 정규화:</strong> 모델 가중치의 L1 노름을 줄여서 불필요한 피처 제거 (Round 4)</li>
<li><strong>L2 노름 → 유클리드 거리:</strong> KNN 알고리즘에서 데이터 간 거리 측정 (Round 4)</li>
</ul>
<p class="ni">지금은 "노름 = 벡터의 크기"라는 것만 기억하면 된다.</p>
</div>

<h3>2.5 단위벡터 (Unit Vector)</h3>
<p>벡터를 자기 자신의 노름으로 나누면 크기가 1인 벡터, 즉 단위벡터가 된다. 방향은 유지하되 크기만 1로 만드는 것이다. 이 과정을 정규화(normalization)라 한다.</p>

<pre><code>v = np.array([<span class="nu">3</span>, <span class="nu">4</span>])
unit_v = v / np.linalg.norm(v)
<span class="fn">print</span>(<span class="st">f"단위벡터: </span>{unit_v}<span class="st">"</span>)                    <span class="cm"># [0.6, 0.8]</span>
<span class="fn">print</span>(<span class="st">f"크기 확인: </span>{np.linalg.norm(unit_v)}<span class="st">"</span>)  <span class="cm"># 1.0</span></code></pre>

<p>금융에서 단위벡터의 의미: 포트폴리오 비중 벡터를 정규화하면 "방향"(어떤 종목에 상대적으로 더 투자하는가)만 남고 "크기"(총 투자금액)는 사라진다. 이것이 바로 "전략의 방향성"이다.</p>

<!-- ═══ Plotly: Ch.1/2 벡터 연산 인터랙티브 시각화 ═══ -->
<div id="plot-ch2-vectors" style="width:100%;height:500px;margin:25px 0"></div>
<p class="ni" style="font-size:12px;color:#888;text-align:center">🖱️ 드래그로 회전, 스크롤로 확대/축소. 벡터 a, b, a+b, 내적 방향을 3D로 확인하세요.</p>
<script>
(function(){
  // 3D 벡터 시각화: a, b, a+b, 내적 관계
  var a = [3, 2, 1], b = [1, 4, 2];
  var apb = [a[0]+b[0], a[1]+b[1], a[2]+b[2]];
  
  function arrow3d(start, end, color, name) {
    return {
      x: [start[0], end[0]], y: [start[1], end[1]], z: [start[2], end[2]],
      mode: 'lines+markers', type: 'scatter3d',
      line: {color: color, width: 6},
      marker: {size: [3, 6], color: color, symbol: ['circle','diamond']},
      name: name
    };
  }
  
  var traces = [
    arrow3d([0,0,0], a, '#3498db', 'a = [3, 2, 1]'),
    arrow3d([0,0,0], b, '#e74c3c', 'b = [1, 4, 2]'),
    arrow3d([0,0,0], apb, '#27ae60', 'a+b = [4, 6, 3]'),
    // a의 끝에서 b를 이어붙인 점선
    {x:[a[0],apb[0]], y:[a[1],apb[1]], z:[a[2],apb[2]],
     mode:'lines', type:'scatter3d',
     line:{color:'#e74c3c', width:3, dash:'dash'}, name:'b (이동)', showlegend:false},
    // 내적 = 3*1+2*4+1*2 = 13
    {x:[0], y:[0], z:[0], mode:'markers', type:'scatter3d',
     marker:{size:8, color:'#f39c12'}, name:'dot(a,b) = 13', showlegend:true}
  ];
  
  var layout = {
    title: {text:'3D 벡터 연산: a, b, a+b (벡터 덧셈의 기하학)', font:{size:14}},
    scene: {
      xaxis: {title:'x', range:[-1,6]},
      yaxis: {title:'y', range:[-1,7]},
      zaxis: {title:'z', range:[-1,5]},
      camera: {eye:{x:1.5, y:1.5, z:1.2}}
    },
    legend: {x:0.01, y:0.99, font:{size:11}},
    margin: {l:0, r:0, t:40, b:0},
    paper_bgcolor: 'rgba(0,0,0,0)',
    plot_bgcolor: 'rgba(0,0,0,0)',
    annotations: [{
      text: '내적 a·b = 3×1 + 2×4 + 1×2 = 13 (양수 → 같은 방향)',
      showarrow: false, x: 0.5, y: -0.05, xref:'paper', yref:'paper',
      font:{size:12, color:'#e67e22'}
    }]
  };
  
  Plotly.newPlot('plot-ch2-vectors', traces, layout, {responsive:true});
})();
</script>

<div class="tc">Table 1. 벡터 연산 요약</div>
<table>
<tr><th>연산</th><th>수학 표기</th><th>NumPy 코드</th><th>결과 타입</th><th>금융 의미</th></tr>
<tr><td>덧셈</td><td>\(\mathbf{a} + \mathbf{b}\)</td><td><code>a + b</code></td><td>벡터</td><td>두 포트폴리오 합산</td></tr>
<tr><td>스칼라곱</td><td>\(c\mathbf{a}\)</td><td><code>c * a</code></td><td>벡터</td><td>레버리지 / 축소</td></tr>
<tr><td>원소별곱</td><td>\(a_i b_i\)</td><td><code>a * b</code></td><td>벡터</td><td>종목별 기여분</td></tr>
<tr><td>내적</td><td>\(\mathbf{a} \cdot \mathbf{b}\)</td><td><code>np.dot(a,b)</code> 또는 <code>a @ b</code></td><td>스칼라</td><td>포트폴리오 수익률</td></tr>
<tr><td>L2 노름</td><td>\(\|\mathbf{a}\|_2\)</td><td><code>np.linalg.norm(a)</code></td><td>스칼라</td><td>변동성 proxy</td></tr>
</table>

<!-- ═══════════════════════════════════════════ -->
<!-- Ch3: 행렬 -->
<!-- ═══════════════════════════════════════════ -->
<h2 id="ch3">3. 행렬: 데이터의 표 (Matrices)</h2>

<h3>3.1 행렬이란?</h3>
<p>벡터가 숫자의 "1차원 목록"이라면, 행렬(matrix)은 숫자의 "2차원 표"다. 엑셀 스프레드시트를 떠올리면 된다. 행(row)과 열(column)로 이루어져 있다.</p>

<p>금융에서 행렬이 등장하는 가장 대표적인 상황: 여러 종목의 여러 날짜 수익률 데이터다.</p>

<pre><code><span class="cm"># 3일 × 4종목 수익률 데이터 = 행렬!</span>
<span class="cm">#              삼성    SK하이닉스  NAVER   카카오</span>
R = np.array([
    [<span class="nu">0.02</span>,   -<span class="nu">0.01</span>,    <span class="nu">0.03</span>,   <span class="nu">0.01</span>],   <span class="cm"># Day 1</span>
    [-<span class="nu">0.01</span>,   <span class="nu">0.02</span>,   -<span class="nu">0.02</span>,   <span class="nu">0.005</span>],  <span class="cm"># Day 2</span>
    [<span class="nu">0.015</span>,   <span class="nu">0.01</span>,    <span class="nu">0.01</span>,  -<span class="nu">0.01</span>]   <span class="cm"># Day 3</span>
])

<span class="fn">print</span>(<span class="st">f"Shape: </span>{R.shape}<span class="st">"</span>)      <span class="cm"># (3, 4) → 3행 4열</span>
<span class="fn">print</span>(<span class="st">f"행(날짜) 수: </span>{R.shape[0]}<span class="st">"</span>)  <span class="cm"># 3</span>
<span class="fn">print</span>(<span class="st">f"열(종목) 수: </span>{R.shape[1]}<span class="st">"</span>)  <span class="cm"># 4</span>

<span class="cm"># 특정 원소 접근: R[행, 열]</span>
<span class="fn">print</span>(<span class="st">f"Day1 삼성 수익률: </span>{R[0, 0]}<span class="st">"</span>)   <span class="cm"># 0.02</span>
<span class="fn">print</span>(<span class="st">f"Day2 전체: </span>{R[1]}<span class="st">"</span>)             <span class="cm"># [-0.01, 0.02, -0.02, 0.005]</span>
<span class="fn">print</span>(<span class="st">f"NAVER 전체: </span>{R[:, 2]}<span class="st">"</span>)         <span class="cm"># [0.03, -0.02, 0.01]</span></code></pre>

<div class="eq">\[ \mathbf{R} = \begin{bmatrix} r_{1,1} & r_{1,2} & \cdots & r_{1,m} \\ r_{2,1} & r_{2,2} & \cdots & r_{2,m} \\ \vdots & \vdots & \ddots & \vdots \\ r_{n,1} & r_{n,2} & \cdots & r_{n,m} \end{bmatrix} \quad \text{n일 × m종목} \]</div>

<p>행렬의 크기를 표현할 때 항상 "행 × 열" 순서다. (3, 4) 행렬은 3행 4열이다. 이 순서를 헷갈리면 나중에 행렬곱에서 고생한다.</p>

<h3>3.2 왜 행렬을 배워야 하는가?</h3>
<p>행렬은 ML과 금융의 모든 곳에 있다:</p>

<ul>
<li><strong>데이터셋:</strong> 1000일 × 50종목 수익률 = (1000, 50) 행렬</li>
<li><strong>공분산 행렬:</strong> 50종목 간의 공분산 = (50, 50) 행렬 → 포트폴리오 위험 계산의 핵심</li>
<li><strong>신경망 가중치:</strong> 입력 100개 → 출력 50개 레이어 = (100, 50) 가중치 행렬</li>
<li><strong>이미지:</strong> 28×28 픽셀 흑백 이미지 = (28, 28) 행렬</li>
<li><strong>회귀분석:</strong> \(\hat{\mathbf{y}} = \mathbf{X}\boldsymbol{\beta}\) — 행렬곱 하나로 표현</li>
</ul>

<p>즉, 데이터를 다루는 모든 작업이 행렬 연산이다. Pandas DataFrame도 내부적으로는 NumPy 행렬이다.</p>

<!-- ── 보충 3.2+ 행렬 = 변환이라는 직관 ── -->
<div class="info">
<p class="ni"><strong>🔍 보충: 행렬 = 변환(Transformation)이라는 핵심 직관</strong></p>
<p class="ni">행렬을 "숫자의 표"로만 이해하면 절반만 아는 것이다. 행렬의 진짜 정체는 <strong>변환(transformation)</strong>이다. 행렬에 벡터를 곱하면 그 벡터가 다른 벡터로 변환된다. 이것이 왜 중요한가?</p>
<p class="ni">비유를 들어보자. 당신이 포토샵에서 이미지를 회전시키거나, 확대하거나, 기울이는 작업을 한다고 하자. 이 모든 작업이 행렬곱이다:</p>
<ul>
<li><strong>회전:</strong> 회전 행렬 × 좌표 벡터 = 회전된 좌표</li>
<li><strong>확대/축소:</strong> 스케일 행렬 × 좌표 벡터 = 확대된 좌표</li>
<li><strong>기울이기:</strong> 전단(shear) 행렬 × 좌표 벡터 = 기울어진 좌표</li>
</ul>
<p class="ni">금융에서도 마찬가지다:</p>
<ul>
<li><strong>공분산 행렬 Σ:</strong> "수익률 공간을 위험 구조에 따라 변환하는 행렬". Σ에 비중 벡터 w를 곱하면 각 종목이 포트폴리오 위험에 기여하는 정도가 나온다.</li>
<li><strong>신경망 가중치 행렬 W:</strong> "입력 피처 공간을 출력 공간으로 변환하는 행렬". 100개 피처를 50개 뉴런으로 변환하는 것이 (100×50) 행렬곱이다.</li>
<li><strong>PCA 고유벡터 행렬 V:</strong> "원래 종목 공간을 주성분 공간으로 변환하는 행렬". 50개 종목을 3개 팩터로 변환한다.</li>
</ul>
<p class="ni">이 "행렬 = 변환" 직관을 가지면, 나중에 고유값 분해(Ch.5)가 "변환의 본질적 방향과 크기를 분해하는 것"이라는 것을 자연스럽게 이해할 수 있다.</p>
</div>

<pre><code><span class="cm"># 행렬 = 변환의 시각적 확인</span>
<span class="cm"># 2D 벡터들에 행렬을 곱하면 어떻게 변하는지 보자</span>

<span class="cm"># 원래 점들: 단위 원 위의 점들</span>
theta = np.linspace(<span class="nu">0</span>, <span class="nu">2</span>*np.pi, <span class="nu">100</span>)
circle = np.array([np.cos(theta), np.sin(theta)])  <span class="cm"># (2, 100)</span>

<span class="cm"># 변환 행렬: 공분산 행렬처럼 생긴 행렬</span>
A = np.array([[<span class="nu">2</span>, <span class="nu">1</span>],
              [<span class="nu">1</span>, <span class="nu">3</span>]])

<span class="cm"># 변환 적용: 원이 타원으로 변한다!</span>
ellipse = A @ circle  <span class="cm"># (2, 100)</span>

fig, (ax1, ax2) = plt.subplots(<span class="nu">1</span>, <span class="nu">2</span>, figsize=(<span class="nu">12</span>, <span class="nu">5</span>))
ax1.plot(circle[<span class="nu">0</span>], circle[<span class="nu">1</span>], <span class="st">'b-'</span>, linewidth=<span class="nu">2</span>)
ax1.set_title(<span class="st">"변환 전: 단위 원"</span>)
ax1.set_aspect(<span class="st">'equal'</span>); ax1.grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)
ax1.set_xlim(-<span class="nu">4</span>, <span class="nu">4</span>); ax1.set_ylim(-<span class="nu">4</span>, <span class="nu">4</span>)

ax2.plot(ellipse[<span class="nu">0</span>], ellipse[<span class="nu">1</span>], <span class="st">'r-'</span>, linewidth=<span class="nu">2</span>)
ax2.set_title(<span class="st">"변환 후: 타원 (행렬 A를 곱한 결과)"</span>)
ax2.set_aspect(<span class="st">'equal'</span>); ax2.grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)
ax2.set_xlim(-<span class="nu">4</span>, <span class="nu">4</span>); ax2.set_ylim(-<span class="nu">4</span>, <span class="nu">4</span>)

plt.suptitle(<span class="st">"행렬 = 변환: 원이 타원으로 변한다"</span>, fontsize=<span class="nu">14</span>)
plt.tight_layout()
plt.show()
<span class="cm"># → 타원의 장축 방향 = 고유벡터, 장축 길이 = 고유값!</span></code></pre>
<div class="code-output"><span class="out-label">Output:</span>
공분산 행렬:
          삼성전자  SK하이닉스  NAVER    AAPL     MSFT
삼성전자    3.41     2.87     1.23    0.45     0.38
SK하이닉스  2.87     6.42     1.56    0.67     0.52
NAVER      1.23     1.56     4.51    0.34     0.29
AAPL       0.45     0.67     0.34    2.12     1.45
MSFT       0.38     0.52     0.29    1.45     1.93</div>


<h3>3.3 특수 행렬들</h3>
<p>자주 등장하는 특수한 행렬들이 있다. 이름과 모양을 기억해두자.</p>

<pre><code><span class="cm"># 1. 단위행렬 (Identity Matrix) — 곱해도 변하지 않는 행렬</span>
<span class="cm"># 숫자에서 1의 역할. A × I = A</span>
I = np.eye(<span class="nu">3</span>)
<span class="fn">print</span>(<span class="st">"단위행렬:\n"</span>, I)
<span class="cm"># [[1. 0. 0.]</span>
<span class="cm">#  [0. 1. 0.]</span>
<span class="cm">#  [0. 0. 1.]]</span>

<span class="cm"># 2. 영행렬 (Zero Matrix) — 모든 원소가 0</span>
Z = np.zeros((<span class="nu">3</span>, <span class="nu">3</span>))

<span class="cm"># 3. 대각행렬 (Diagonal Matrix) — 대각선만 값이 있음</span>
<span class="cm"># 포트폴리오 비중을 대각행렬로 만들면 유용</span>
D = np.diag([<span class="nu">0.3</span>, <span class="nu">0.25</span>, <span class="nu">0.25</span>, <span class="nu">0.2</span>])
<span class="fn">print</span>(<span class="st">"대각행렬:\n"</span>, D)

<span class="cm"># 4. 대칭행렬 (Symmetric Matrix) — 전치해도 같은 행렬</span>
<span class="cm"># 공분산 행렬이 대표적인 대칭행렬!</span>
S = np.array([[<span class="nu">4</span>, <span class="nu">2</span>, <span class="nu">1</span>],
              [<span class="nu">2</span>, <span class="nu">3</span>, <span class="nu">1.5</span>],
              [<span class="nu">1</span>, <span class="nu">1.5</span>, <span class="nu">5</span>]])
<span class="fn">print</span>(<span class="st">f"대칭 확인: </span>{np.allclose(S, S.T)}<span class="st">"</span>)  <span class="cm"># True</span></code></pre>

<div class="tc">Table 2. 금융에서 자주 등장하는 행렬</div>
<table>
<tr><th>행렬</th><th>크기</th><th>특징</th><th>금융 의미</th></tr>
<tr><td>수익률 행렬 \(\mathbf{R}\)</td><td>n × m</td><td>일반 행렬</td><td>n일간 m종목의 수익률</td></tr>
<tr><td>공분산 행렬 \(\boldsymbol{\Sigma}\)</td><td>m × m</td><td>대칭, 양반정치</td><td>종목 간 공분산 (위험 구조)</td></tr>
<tr><td>상관행렬 \(\boldsymbol{\rho}\)</td><td>m × m</td><td>대칭, 대각선=1</td><td>종목 간 상관계수</td></tr>
<tr><td>비중 벡터 \(\mathbf{w}\)</td><td>m × 1</td><td>합=1</td><td>포트폴리오 비중</td></tr>
<tr><td>팩터 로딩 \(\mathbf{B}\)</td><td>m × k</td><td>일반 행렬</td><td>m종목의 k팩터 노출도</td></tr>
<tr><td>단위행렬 \(\mathbf{I}\)</td><td>n × n</td><td>대각선=1</td><td>무상관 가정 시 공분산</td></tr>
</table>

<h3>3.4 행렬 인덱싱 심화</h3>
<p>행렬에서 원하는 부분만 꺼내는 것을 인덱싱(indexing)이라 한다. Round 1에서 배운 NumPy 슬라이싱의 2차원 확장이다.</p>

<pre><code><span class="cm"># 5일 × 3종목 수익률 행렬</span>
np.random.seed(<span class="nu">42</span>)
R = np.random.normal(<span class="nu">0</span>, <span class="nu">0.02</span>, (<span class="nu">5</span>, <span class="nu">3</span>))
stocks = [<span class="st">"삼성"</span>, <span class="st">"SK"</span>, <span class="st">"NAVER"</span>]

<span class="cm"># 특정 행 (Day 0)</span>
<span class="fn">print</span>(<span class="st">"Day 0:"</span>, R[<span class="nu">0</span>])

<span class="cm"># 특정 열 (삼성 전체)</span>
<span class="fn">print</span>(<span class="st">"삼성 5일:"</span>, R[:, <span class="nu">0</span>])

<span class="cm"># 부분 행렬 (Day 1~3, 삼성+SK)</span>
<span class="fn">print</span>(<span class="st">"부분:\n"</span>, R[<span class="nu">1</span>:<span class="nu">4</span>, <span class="nu">0</span>:<span class="nu">2</span>])

<span class="cm"># 조건 인덱싱: 삼성 수익률이 양수인 날만</span>
mask = R[:, <span class="nu">0</span>] > <span class="nu">0</span>
<span class="fn">print</span>(<span class="st">"삼성 양수인 날:\n"</span>, R[mask])</code></pre>

<!-- ═══════════════════════════════════════════ -->
<!-- Ch4: 행렬 연산 -->
<!-- ═══════════════════════════════════════════ -->
<h2 id="ch4">4. 행렬 연산</h2>

<h3>4.1 전치 (Transpose)</h3>
<p>행렬의 전치(transpose)는 행과 열을 뒤바꾸는 것이다. (3×4) 행렬을 전치하면 (4×3) 행렬이 된다. 마치 엑셀에서 "행/열 바꾸기"를 하는 것과 같다.</p>

<pre><code>A = np.array([[<span class="nu">1</span>, <span class="nu">2</span>, <span class="nu">3</span>],
              [<span class="nu">4</span>, <span class="nu">5</span>, <span class="nu">6</span>]])
<span class="fn">print</span>(<span class="st">f"A shape:   </span>{A.shape}<span class="st">"</span>)    <span class="cm"># (2, 3)</span>
<span class="fn">print</span>(<span class="st">f"A.T shape: </span>{A.T.shape}<span class="st">"</span>)  <span class="cm"># (3, 2)</span>

<span class="fn">print</span>(<span class="st">"A:\n"</span>, A)
<span class="cm"># [[1 2 3]</span>
<span class="cm">#  [4 5 6]]</span>

<span class="fn">print</span>(<span class="st">"A.T:\n"</span>, A.T)
<span class="cm"># [[1 4]</span>
<span class="cm">#  [2 5]</span>
<span class="cm">#  [3 6]]</span></code></pre>

<div class="eq">\[ (\mathbf{A}^T)_{ij} = \mathbf{A}_{ji} \]</div>

<p>전치가 왜 중요한가? 포트폴리오 분산 공식에서 \(\mathbf{w}^T \boldsymbol{\Sigma} \mathbf{w}\)처럼 전치가 반드시 등장한다. 또한 공분산 행렬은 대칭행렬이므로 \(\boldsymbol{\Sigma}^T = \boldsymbol{\Sigma}\)라는 성질이 있다.</p>

<h3>4.2 행렬곱 (Matrix Multiplication) — ML의 핵심 연산</h3>
<p>행렬곱은 ML에서 가장 많이 수행되는 연산이다. 신경망의 순전파(forward pass), 회귀분석, 포트폴리오 분산 계산 모두 행렬곱이다.</p>

<p>행렬곱의 규칙을 비유로 설명하자. A가 "학생 × 과목" 성적표이고, B가 "과목 × 가중치" 표라면, A×B는 "학생 × 가중 평균 점수"가 된다. 핵심은 A의 열 수와 B의 행 수가 같아야 한다는 것이다.</p>

<div class="eq">\[ \underbrace{\mathbf{A}}_{m \times \color{red}{n}} \times \underbrace{\mathbf{B}}_{\color{red}{n} \times p} = \underbrace{\mathbf{C}}_{m \times p} \]</div>

<p>빨간색 n이 같아야 곱셈이 가능하다. 결과의 크기는 바깥쪽 차원(m×p)이 된다.</p>

<pre><code><span class="cm"># A(2×3) @ B(3×2) = C(2×2)</span>
A = np.array([[<span class="nu">1</span>, <span class="nu">2</span>, <span class="nu">3</span>],
              [<span class="nu">4</span>, <span class="nu">5</span>, <span class="nu">6</span>]])  <span class="cm"># 2×3</span>

B = np.array([[<span class="nu">7</span>, <span class="nu">8</span>],
              [<span class="nu">9</span>, <span class="nu">10</span>],
              [<span class="nu">11</span>, <span class="nu">12</span>]])    <span class="cm"># 3×2</span>

C = A @ B  <span class="cm"># 2×2</span>
<span class="fn">print</span>(<span class="st">"A @ B =\n"</span>, C)
<span class="cm"># [[ 58  64]</span>
<span class="cm">#  [139 154]]</span>

<span class="cm"># 수동 계산으로 이해하기:</span>
<span class="cm"># C[0,0] = 1*7 + 2*9 + 3*11 = 7 + 18 + 33 = 58</span>
<span class="cm"># C[0,1] = 1*8 + 2*10 + 3*12 = 8 + 20 + 36 = 64</span>
<span class="cm"># → 결과의 각 원소는 "A의 행"과 "B의 열"의 내적!</span></code></pre>

<div class="def">
<p class="ni"><strong>행렬곱의 핵심 직관:</strong></p>
<p class="ni">결과 행렬 C의 (i, j) 원소는 A의 i번째 행 벡터와 B의 j번째 열 벡터의 내적이다.</p>
<div class="eq">\[ C_{ij} = \sum_{k=1}^{n} A_{ik} B_{kj} = \text{(A의 i행)} \cdot \text{(B의 j열)} \]</div>
<p class="ni">즉, 행렬곱은 "내적을 여러 번 한꺼번에 계산하는 것"이다.</p>
</div>

<div class="warn">
<p class="ni"><strong>행렬곱 주의사항:</strong></p>
<ul>
<li>A×B ≠ B×A (교환법칙 성립 안 함!)</li>
<li>A(m×n) × B(n×p) → 가능. B(n×p) × A(m×n) → m≠p이면 불가능</li>
<li><code>A * B</code>는 원소별 곱이고, <code>A @ B</code>가 행렬곱이다. 절대 헷갈리지 말 것!</li>
</ul>
</div>

<!-- ═══ Plotly: Ch.3/4 행렬 변환 시각화 (원→타원) ═══ -->
<div id="plot-ch4-transform" style="width:100%;height:480px;margin:25px 0"></div>
<p class="ni" style="font-size:12px;color:#888;text-align:center">🖱️ 호버로 좌표 확인. 파란 원이 행렬 A를 곱하면 빨간 타원으로 변환됩니다. 타원의 장축 = 고유벡터 방향!</p>
<script>
(function(){
  var N = 200;
  var cx = [], cy = [], ex = [], ey = [];
  var A = [[2, 1],[1, 3]]; // 변환 행렬 (공분산 행렬처럼)
  
  for(var i=0; i<N; i++){
    var t = 2*Math.PI*i/N;
    var x0 = Math.cos(t), y0 = Math.sin(t);
    cx.push(x0); cy.push(y0);
    // 행렬 곱: A @ [x0, y0]
    ex.push(A[0][0]*x0 + A[0][1]*y0);
    ey.push(A[1][0]*x0 + A[1][1]*y0);
  }
  
  // 고유벡터 방향 (수동 계산: λ1≈3.618, v1≈[0.526,0.851])
  var ev1 = {x:[0, 0.526*3.618], y:[0, 0.851*3.618]};
  var ev2 = {x:[0, 0.851*1.382], y:[0, -0.526*1.382]};
  
  var traces = [
    {x:cx, y:cy, mode:'lines', name:'원래: 단위 원', line:{color:'#3498db', width:3}},
    {x:ex, y:ey, mode:'lines', name:'변환 후: 타원 (A×원)', line:{color:'#e74c3c', width:3}},
    {x:ev1.x, y:ev1.y, mode:'lines+markers', name:'고유벡터 1 (λ≈3.62)',
     line:{color:'#f39c12', width:4, dash:'dash'}, marker:{size:[4,10], symbol:['circle','arrow-up']}},
    {x:ev2.x, y:ev2.y, mode:'lines+markers', name:'고유벡터 2 (λ≈1.38)',
     line:{color:'#27ae60', width:4, dash:'dash'}, marker:{size:[4,10], symbol:['circle','arrow-up']}}
  ];
  
  var layout = {
    title:{text:'행렬 = 변환: 단위 원 → 타원 (고유벡터 = 장축/단축 방향)', font:{size:14}},
    xaxis:{title:'x', range:[-5,5], zeroline:true, zerolinecolor:'#ccc'},
    yaxis:{title:'y', range:[-5,5], zeroline:true, zerolinecolor:'#ccc', scaleanchor:'x'},
    legend:{x:0.01, y:0.99, font:{size:11}},
    margin:{l:50, r:20, t:50, b:50},
    paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(248,249,250,0.5)',
    shapes:[{type:'line',x0:-5,y0:0,x1:5,y1:0,line:{color:'#ddd',width:1}},
            {type:'line',x0:0,y0:-5,x1:0,y1:5,line:{color:'#ddd',width:1}}]
  };
  
  Plotly.newPlot('plot-ch4-transform', traces, layout, {responsive:true});
})();
</script>

<!-- ── 보충 4.2+ 왜 이 순서로 곱하는가 ── -->
<div class="info">
<p class="ni"><strong>🔍 보충: "왜 행렬곱은 이 순서로 곱하는가?" — 직관적 이해</strong></p>
<p class="ni">행렬곱의 규칙(A의 행 × B의 열)이 왜 이렇게 정의되었는지 의아할 수 있다. 원소별 곱처럼 같은 위치끼리 곱하면 안 되는 걸까?</p>
<p class="ni">비유로 이해하자. 당신이 3개 과목(수학, 영어, 과학)의 시험을 봤고, 각 과목에 가중치가 다르다고 하자:</p>
<ul>
<li>성적: [90, 80, 70] (수학 90점, 영어 80점, 과학 70점)</li>
<li>가중치: [0.5, 0.3, 0.2] (수학 50%, 영어 30%, 과학 20%)</li>
<li>가중 평균 = 90×0.5 + 80×0.3 + 70×0.2 = 45 + 24 + 14 = 83</li>
</ul>
<p class="ni">이것이 내적이다. 행렬곱은 이 내적을 "여러 학생 × 여러 가중치 조합"에 대해 한꺼번에 계산하는 것이다:</p>
</div>

<pre><code><span class="cm"># 행렬곱의 직관: "여러 내적을 한꺼번에"</span>
<span class="cm"># 3명의 학생 × 3과목 성적</span>
scores = np.array([
    [<span class="nu">90</span>, <span class="nu">80</span>, <span class="nu">70</span>],  <span class="cm"># 학생 A</span>
    [<span class="nu">60</span>, <span class="nu">95</span>, <span class="nu">85</span>],  <span class="cm"># 학생 B</span>
    [<span class="nu">75</span>, <span class="nu">70</span>, <span class="nu">90</span>]   <span class="cm"># 학생 C</span>
])  <span class="cm"># (3학생 × 3과목)</span>

<span class="cm"># 2가지 가중치 조합</span>
weights = np.array([
    [<span class="nu">0.5</span>, <span class="nu">0.3</span>, <span class="nu">0.2</span>],  <span class="cm"># 가중치 1: 수학 중시</span>
    [<span class="nu">0.2</span>, <span class="nu">0.5</span>, <span class="nu">0.3</span>]   <span class="cm"># 가중치 2: 영어 중시</span>
]).T  <span class="cm"># 전치! → (3과목 × 2가중치)</span>

<span class="cm"># 행렬곱 = 모든 (학생, 가중치) 조합의 가중평균</span>
result = scores @ weights  <span class="cm"># (3학생 × 2가중치)</span>
<span class="fn">print</span>(<span class="st">"가중 평균 점수:\n"</span>, result)
<span class="cm"># result[i, j] = i번째 학생의 j번째 가중치 조합 점수</span>
<span class="cm"># 이것이 행렬곱의 본질: "모든 조합의 내적을 한 번에 계산"</span>

<span class="cm"># 금융 적용: 여러 날의 수익률 × 비중 = 여러 날의 포트폴리오 수익률</span>
<span class="cm"># R(250일×5종목) @ w(5종목×1) = port_ret(250일×1)</span></code></pre>

<h3>4.3 금융 적용: 포트폴리오 분산</h3>
<p>포트폴리오 분산(위험의 제곱)은 행렬곱으로 아름답게 표현된다:</p>

<div class="eq">\[ \sigma_p^2 = \mathbf{w}^T \boldsymbol{\Sigma} \mathbf{w} \]</div>

<p>이 공식을 풀어쓰면: (1×m) × (m×m) × (m×1) = (1×1), 즉 스칼라 하나가 나온다. 이것이 포트폴리오의 분산이다.</p>

<pre><code><span class="cm"># 3종목 포트폴리오 분산 계산</span>
w = np.array([<span class="nu">0.4</span>, <span class="nu">0.35</span>, <span class="nu">0.25</span>])  <span class="cm"># 비중 벡터</span>

<span class="cm"># 공분산 행렬 (연간화)</span>
Sigma = np.array([
    [<span class="nu">0.04</span>,  <span class="nu">0.006</span>, <span class="nu">0.002</span>],   <span class="cm"># 삼성 분산, 삼성-SK 공분산, ...</span>
    [<span class="nu">0.006</span>, <span class="nu">0.09</span>,  <span class="nu">0.015</span>],   <span class="cm"># SK-삼성 공분산, SK 분산, ...</span>
    [<span class="nu">0.002</span>, <span class="nu">0.015</span>, <span class="nu">0.0625</span>]   <span class="cm"># ...</span>
])

<span class="cm"># 포트폴리오 분산 = w^T @ Sigma @ w</span>
port_var = w @ Sigma @ w
port_vol = np.sqrt(port_var)

<span class="fn">print</span>(<span class="st">f"포트폴리오 분산:   </span>{port_var:.6f}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"포트폴리오 변동성: </span>{port_vol*100:.2f}<span class="st">%"</span>)

<span class="cm"># 비교: 개별 종목 변동성</span>
individual_vols = np.sqrt(np.diag(Sigma))
<span class="fn">print</span>(<span class="st">f"\n개별 변동성: </span>{individual_vols*100}<span class="st">%"</span>)
<span class="fn">print</span>(<span class="st">f"단순 평균:   </span>{(w @ individual_vols)*100:.2f}<span class="st">%"</span>)
<span class="fn">print</span>(<span class="st">f"→ 분산 효과: 포트폴리오 변동성 < 단순 평균 변동성!"</span>)</code></pre>

<div class="ok">
<p class="ni"><strong>분산 투자의 수학적 증명:</strong> 포트폴리오 변동성이 개별 종목 변동성의 가중 평균보다 작다. 이것은 종목 간 상관계수가 1보다 작기만 하면 반드시 성립한다. 이것이 "분산 투자는 공짜 점심"이라 불리는 이유다. 해리 마코위츠는 이 발견으로 1990년 노벨 경제학상을 받았다.</p>
</div>

<h3>4.4 역행렬 (Inverse Matrix)</h3>
<p>숫자에서 5의 역수는 1/5이다. 5 × (1/5) = 1. 행렬에서도 비슷한 개념이 있다. 행렬 A의 역행렬 \(\mathbf{A}^{-1}\)은 곱하면 단위행렬이 되는 행렬이다.</p>

<div class="eq">\[ \mathbf{A} \mathbf{A}^{-1} = \mathbf{A}^{-1} \mathbf{A} = \mathbf{I} \]</div>

<pre><code>A = np.array([[<span class="nu">2</span>, <span class="nu">1</span>],
              [<span class="nu">5</span>, <span class="nu">3</span>]])

<span class="cm"># 역행렬 계산</span>
A_inv = np.linalg.inv(A)
<span class="fn">print</span>(<span class="st">"A의 역행렬:\n"</span>, A_inv)
<span class="cm"># [[ 3. -1.]</span>
<span class="cm">#  [-5.  2.]]</span>

<span class="cm"># 검증: A @ A_inv = I (단위행렬)</span>
<span class="fn">print</span>(<span class="st">"A @ A_inv =\n"</span>, np.round(A @ A_inv, <span class="nu">10</span>))
<span class="cm"># [[1. 0.]</span>
<span class="cm">#  [0. 1.]]  ← 단위행렬!</span></code></pre>

<p>역행렬이 금융에서 왜 중요한가? 마코위츠 최소분산 포트폴리오의 비중 공식이 역행렬을 사용하기 때문이다:</p>

<div class="eq">\[ \mathbf{w}^* = \frac{\boldsymbol{\Sigma}^{-1} \mathbf{1}}{\mathbf{1}^T \boldsymbol{\Sigma}^{-1} \mathbf{1}} \]</div>

<p>이 공식의 의미: 공분산 행렬의 역행렬에 1벡터를 곱하면 최소분산 포트폴리오의 비중이 나온다. 공분산이 큰(위험한) 종목은 비중이 줄고, 공분산이 작은(안전한) 종목은 비중이 늘어난다.</p>

<pre><code><span class="cm"># 최소분산 포트폴리오 계산</span>
Sigma_inv = np.linalg.inv(Sigma)
ones = np.ones(<span class="nu">3</span>)

w_minvar = (Sigma_inv @ ones) / (ones @ Sigma_inv @ ones)
<span class="fn">print</span>(<span class="st">f"최소분산 비중: </span>{w_minvar.round(4)}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"비중 합: </span>{w_minvar.sum():.4f}<span class="st">"</span>)  <span class="cm"># 1.0</span>

<span class="cm"># 최소분산 포트폴리오의 변동성</span>
minvar_vol = np.sqrt(w_minvar @ Sigma @ w_minvar)
<span class="fn">print</span>(<span class="st">f"최소분산 변동성: </span>{minvar_vol*100:.2f}<span class="st">%"</span>)
<span class="fn">print</span>(<span class="st">f"동일비중 변동성: </span>{port_vol*100:.2f}<span class="st">%"</span>)
<span class="fn">print</span>(<span class="st">f"→ 최소분산이 더 낮다!"</span>)</code></pre>

<h3>4.5 행렬식 (Determinant)</h3>
<p>행렬식(determinant)은 행렬을 하나의 숫자로 요약한 것이다. 하지만 "요약"이라고만 하면 감이 안 온다. 행렬식의 진짜 의미는 기하학적으로 이해해야 한다.</p>

<h4>행렬식의 기하학적 의미 — "면적/부피의 변환 배율"</h4>
<p>2×2 행렬을 벡터에 곱하면 2차원 공간이 변환된다. 이때 행렬식은 "변환 후 면적이 원래의 몇 배가 되는가"를 나타낸다.</p>

<div style="margin:25px 0;padding:20px;background:#f8f9fa;border-radius:8px;border:1px solid #ddd">
<p class="ni" style="text-align:center;font-weight:bold;font-size:14px;margin-bottom:15px;color:#2c3e50">행렬식 = 면적 변환 배율</p>
<div style="display:flex;gap:20px;justify-content:center;flex-wrap:wrap;font-size:12px">
<div style="text-align:center;background:#fff;padding:15px;border-radius:8px;border:2px solid #3498db;min-width:160px">
<div style="font-weight:bold;color:#3498db;margin-bottom:8px">det(A) = 2</div>
<div style="font-size:28px;margin:8px 0">▪️ → ⬜</div>
<div style="color:#555">면적이 2배로 확대</div>
</div>
<div style="text-align:center;background:#fff;padding:15px;border-radius:8px;border:2px solid #e67e22;min-width:160px">
<div style="font-weight:bold;color:#e67e22;margin-bottom:8px">det(A) = 0.5</div>
<div style="font-size:28px;margin:8px 0">⬜ → ▪️</div>
<div style="color:#555">면적이 절반으로 축소</div>
</div>
<div style="text-align:center;background:#fff;padding:15px;border-radius:8px;border:2px solid #e74c3c;min-width:160px">
<div style="font-weight:bold;color:#e74c3c;margin-bottom:8px">det(A) = 0</div>
<div style="font-size:28px;margin:8px 0">⬜ → ━</div>
<div style="color:#e74c3c;font-weight:bold">면적이 0! (찌그러짐)</div>
<div style="color:#555;font-size:11px">2차원 → 1차원으로 붕괴</div>
</div>
</div>
</div>

<p>행렬식이 0이라는 것은 변환 후 공간이 한 차원 낮아진다는 뜻이다. 2차원 평면이 1차원 직선으로 찌그러진다. 이렇게 되면 정보가 손실되어 원래대로 되돌릴 수 없다 — 그래서 역행렬이 존재하지 않는 것이다.</p>

<h4>2×2 행렬식 공식</h4>
<div class="eq">\[ \det\begin{pmatrix} a & b \\ c & d \end{pmatrix} = ad - bc \]</div>

<p class="ni">간단하다: 대각선 곱의 차이다. 예를 들어:</p>

<div class="def">
<p class="ni"><strong>행렬식 계산 예시</strong></p>
<ul>
<li>\(\det\begin{pmatrix} 3 & 1 \\ 1 & 3 \end{pmatrix} = 3 \times 3 - 1 \times 1 = 8\) → 면적이 8배 확대, 역행렬 존재</li>
<li>\(\det\begin{pmatrix} 1 & 2 \\ 2 & 4 \end{pmatrix} = 1 \times 4 - 2 \times 2 = 0\) → 면적이 0! 두 행이 비례관계(2행 = 1행 × 2)이므로 정보가 중복된다</li>
<li>\(\det\begin{pmatrix} 2 & 0 \\ 0 & 3 \end{pmatrix} = 2 \times 3 - 0 \times 0 = 6\) → 대각행렬의 행렬식 = 대각 원소의 곱</li>
</ul>
</div>

<h4>금융에서 행렬식이 중요한 이유</h4>
<p>공분산 행렬의 행렬식이 0에 가까우면 다중공선성(multicollinearity)이 있다는 뜻이다. 예를 들어 삼성전자와 SK하이닉스의 수익률이 거의 동일하게 움직이면, 두 종목의 공분산 행렬은 거의 특이(singular)해진다. 이 상태에서 포트폴리오 최적화를 하면 역행렬 계산이 불안정해져서 비현실적인 비중(예: 삼성전자 +500%, SK하이닉스 -400%)이 나올 수 있다.</p>

<pre><code><span class="cm"># 행렬식 계산</span>
det_A = np.linalg.det(A)
<span class="fn">print</span>(<span class="st">f"det(A) = </span>{det_A:.0f}<span class="st">"</span>)  <span class="cm"># 8 (≠ 0이므로 역행렬 존재)</span>

<span class="cm"># 2×2 행렬식 직접 계산: ad - bc</span>
manual_det = A[<span class="nu">0</span>,<span class="nu">0</span>]*A[<span class="nu">1</span>,<span class="nu">1</span>] - A[<span class="nu">0</span>,<span class="nu">1</span>]*A[<span class="nu">1</span>,<span class="nu">0</span>]
<span class="fn">print</span>(<span class="st">f"직접 계산: </span>{manual_det}<span class="st">"</span>)  <span class="cm"># 8 (일치!)</span>

<span class="cm"># 특이행렬 예: 두 행이 비례관계</span>
singular = np.array([[<span class="nu">1</span>, <span class="nu">2</span>],
                      [<span class="nu">2</span>, <span class="nu">4</span>]])  <span class="cm"># 2행 = 1행 × 2</span>
<span class="fn">print</span>(<span class="st">f"\ndet(singular) = </span>{np.linalg.det(singular):.0f}<span class="st">"</span>)  <span class="cm"># 0</span>
<span class="fn">print</span>(<span class="st">f"직접: 1×4 - 2×2 = </span>{1*4 - 2*2}<span class="st">"</span>)  <span class="cm"># 0</span>
<span class="cm"># np.linalg.inv(singular)  # → LinAlgError! (역행렬 불가)</span>

<span class="cm"># 금융 예: 공분산 행렬의 행렬식으로 다중공선성 확인</span>
<span class="cm"># 상관계수가 0.99인 두 종목</span>
cov_high_corr = np.array([[<span class="nu">0.04</span>, <span class="nu">0.0396</span>],
                           [<span class="nu">0.0396</span>, <span class="nu">0.04</span>]])  <span class="cm"># 상관 ≈ 0.99</span>
<span class="fn">print</span>(<span class="st">f"\n높은 상관 공분산 행렬의 det = </span>{np.linalg.det(cov_high_corr):.8f}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"→ 0에 매우 가까움! 역행렬이 불안정 → 포트폴리오 최적화 주의"</span>)</code></pre>

<div class="warn">
<p class="ni"><strong>행렬식 핵심 정리:</strong></p>
<ul>
<li><strong>det ≠ 0:</strong> 역행렬 존재, 연립방정식에 유일한 해가 있다</li>
<li><strong>det = 0:</strong> 역행렬 없음(특이행렬), 정보가 중복되어 차원이 붕괴</li>
<li><strong>|det| > 1:</strong> 변환이 공간을 확대</li>
<li><strong>|det| < 1:</strong> 변환이 공간을 축소</li>
<li><strong>det < 0:</strong> 변환이 공간을 뒤집음(거울 반사)</li>
</ul>
</div>

<div class="info">
<p class="ni"><strong>실무 팁:</strong> 실제 금융 데이터에서 공분산 행렬의 역행렬을 구할 때, 종목 수가 관측일 수보다 많으면 행렬이 특이(singular)해져서 역행렬을 구할 수 없다. 이때 사용하는 기법이 정규화(regularization)나 축소 추정(shrinkage estimation)이다. Round 4에서 다룬다.</p>
</div>

<!-- ═══════════════════════════════════════════ -->
<!-- Ch5: 고유값과 고유벡터 -->
<!-- ═══════════════════════════════════════════ -->
<h2 id="ch5">5. 고유값과 고유벡터 (Eigenvalues &amp; Eigenvectors)</h2>

<h3>5.1 직관적 이해: "변하지 않는 방향"</h3>
<p>고유값/고유벡터는 선형대수에서 가장 어렵게 느껴지는 개념 중 하나다. 하지만 직관은 간단하다.</p>

<p>행렬을 "변환(transformation)"으로 생각하자. 행렬에 벡터를 곱하면 그 벡터가 회전하거나, 늘어나거나, 찌그러진다. 그런데 어떤 특별한 벡터는 행렬을 곱해도 방향이 바뀌지 않고, 크기만 변한다. 이 특별한 벡터가 고유벡터(eigenvector)이고, 크기가 변하는 배율이 고유값(eigenvalue)이다.</p>

<!-- 고유값/고유벡터 시각적 설명 (CSS) -->
<div style="margin:25px 0;padding:20px;background:#f8f9fa;border-radius:8px;border:1px solid #ddd">
<p class="ni" style="text-align:center;font-weight:bold;font-size:14px;margin-bottom:15px;color:#2c3e50">행렬 변환과 고유벡터</p>
<div style="display:flex;align-items:center;justify-content:center;gap:20px;flex-wrap:wrap;font-size:13px">
<div style="text-align:center">
<div style="width:120px;height:120px;border:2px solid #3498db;border-radius:50%;display:flex;align-items:center;justify-content:center;position:relative;margin:0 auto">
<div style="color:#e74c3c;font-weight:bold;font-size:20px">→</div>
<div style="color:#3498db;font-weight:bold;font-size:20px;transform:rotate(45deg);position:absolute">→</div>
<div style="color:#27ae60;font-weight:bold;font-size:20px;transform:rotate(-30deg);position:absolute">→</div>
</div>
<div style="margin-top:8px;font-weight:bold">변환 전</div>
<div style="color:#888;font-size:11px">여러 방향의 벡터들</div>
</div>
<div style="font-size:28px;color:#e67e22">⟹</div>
<div style="text-align:center;font-size:12px;color:#555">
<div style="font-weight:bold;font-size:14px;color:#e67e22">행렬 A를 곱하면</div>
<div>대부분의 벡터: 방향 변함</div>
<div style="color:#e74c3c;font-weight:bold;margin-top:4px">고유벡터: 방향 그대로!</div>
<div>크기만 λ배</div>
</div>
<div style="font-size:28px;color:#e67e22">⟹</div>
<div style="text-align:center">
<div style="width:120px;height:120px;border:2px solid #e74c3c;border-radius:50%;display:flex;align-items:center;justify-content:center;position:relative;margin:0 auto">
<div style="color:#e74c3c;font-weight:bold;font-size:28px">→→</div>
<div style="color:#3498db;font-weight:bold;font-size:16px;transform:rotate(70deg);position:absolute">↗</div>
<div style="color:#27ae60;font-weight:bold;font-size:16px;transform:rotate(10deg);position:absolute">→</div>
</div>
<div style="margin-top:8px;font-weight:bold">변환 후</div>
<div style="color:#e74c3c;font-size:11px">빨간 벡터: 방향 유지, 길이만 증가</div>
</div>
</div>
</div>

<div class="eq">\[ \mathbf{A}\mathbf{v} = \lambda\mathbf{v} \]</div>

<p>이 식의 의미: 행렬 A를 벡터 v에 곱했더니, v의 방향은 그대로이고 크기만 λ배가 되었다.</p>

<p>비유를 들어보자. 고무판 위에 화살표를 여러 개 그려놓고, 고무판을 잡아당긴다고 하자. 대부분의 화살표는 방향이 틀어진다. 하지만 잡아당기는 방향과 정확히 일치하는 화살표는 방향이 바뀌지 않고 길이만 늘어난다. 이 화살표가 고유벡터다.</p>

<h3>5.2 코드로 계산하기</h3>
<pre><code><span class="cm"># 2×2 행렬의 고유값 분해</span>
A = np.array([[<span class="nu">3</span>, <span class="nu">1</span>],
              [<span class="nu">1</span>, <span class="nu">3</span>]])

eigenvalues, eigenvectors = np.linalg.eig(A)

<span class="fn">print</span>(<span class="st">"고유값:"</span>, eigenvalues)
<span class="cm"># [4. 2.]  → λ1=4, λ2=2</span>

<span class="fn">print</span>(<span class="st">"고유벡터:\n"</span>, eigenvectors)
<span class="cm"># [[ 0.707  -0.707]   → v1 = [0.707, 0.707] (대각선 방향)</span>
<span class="cm">#  [ 0.707   0.707]]  → v2 = [-0.707, 0.707] (반대 대각선)</span>

<span class="cm"># 검증: A @ v1 = λ1 * v1 인가?</span>
v1 = eigenvectors[:, <span class="nu">0</span>]  <span class="cm"># 첫 번째 고유벡터</span>
lam1 = eigenvalues[<span class="nu">0</span>]     <span class="cm"># 첫 번째 고유값</span>

<span class="fn">print</span>(<span class="st">f"\nA @ v1     = </span>{A @ v1}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"λ1 * v1    = </span>{lam1 * v1}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"같은가?     </span>{np.allclose(A @ v1, lam1 * v1)}<span class="st">"</span>)  <span class="cm"># True!</span></code></pre>
<div class="code-output"><span class="out-label">Output:</span>
고유값: [4.618 0.382]
고유벡터:
[[ 0.851  0.526]
 [ 0.526 -0.851]]

검증: A @ v1 = λ1 * v1 → True</div>


<h3>5.3 PCA란 무엇인가? — 일상 비유부터</h3>
<p>PCA(Principal Component Analysis, 주성분분석)는 고유값 분해의 가장 중요한 응용이다. 이름이 어렵지만 아이디어는 간단하다. 비유로 시작하자.</p>

<p>당신이 사진작가라고 하자. 3D 조각상을 2D 사진으로 찍어야 한다. 어떤 각도에서 찍어야 조각상의 모양을 가장 잘 보여줄 수 있을까? 정면에서 찍으면 깊이감이 사라지고, 옆에서 찍으면 정면 디테일이 사라진다. PCA는 "정보 손실을 최소화하는 최적의 촬영 각도"를 수학적으로 찾아주는 기법이다.</p>

<p>금융으로 바꿔보자. 50개 종목의 수익률 데이터가 있다. 50차원이라 인간의 뇌로는 파악이 불가능하다. PCA를 하면 "사실 이 50개 종목의 움직임은 3~5개의 주요 방향(주성분)으로 대부분 설명된다"는 것을 알 수 있다.</p>

<!-- PCA 개념 다이어그램 (CSS) -->
<div style="margin:25px 0;padding:25px;background:linear-gradient(135deg,#f8f9fa,#e8f4f8);border-radius:8px;border:1px solid #ddd">
<p class="ni" style="text-align:center;font-weight:bold;font-size:15px;margin-bottom:18px;color:#2c3e50">📐 PCA의 핵심 아이디어</p>
<div style="display:flex;align-items:center;justify-content:center;gap:12px;flex-wrap:wrap;font-size:13px">
<div style="background:#fff;border:2px solid #3498db;border-radius:8px;padding:12px 16px;text-align:center;min-width:120px">
<div style="font-size:24px;margin-bottom:4px">📊</div>
<div style="font-weight:bold;color:#2c3e50">50개 종목</div>
<div style="color:#888;font-size:11px">50차원 데이터</div>
</div>
<div style="font-size:24px;color:#3498db">→</div>
<div style="background:#fff;border:2px solid #e67e22;border-radius:8px;padding:12px 16px;text-align:center;min-width:120px">
<div style="font-size:24px;margin-bottom:4px">🔍</div>
<div style="font-weight:bold;color:#2c3e50">PCA 변환</div>
<div style="color:#888;font-size:11px">공분산 → 고유값 분해</div>
</div>
<div style="font-size:24px;color:#e67e22">→</div>
<div style="background:#fff;border:2px solid #27ae60;border-radius:8px;padding:12px 16px;text-align:center;min-width:120px">
<div style="font-size:24px;margin-bottom:4px">✨</div>
<div style="font-weight:bold;color:#2c3e50">3~5개 주성분</div>
<div style="color:#888;font-size:11px">정보 90%+ 보존</div>
</div>
</div>
<div style="margin-top:15px;display:flex;justify-content:center;gap:20px;font-size:12px;color:#555;flex-wrap:wrap">
<div>🔵 PC1 = "시장 전체 방향" (보통 40~60%)</div>
<div>🟠 PC2 = "성장주 vs 가치주" (보통 10~20%)</div>
<div>🟢 PC3 = "대형주 vs 소형주" (보통 5~10%)</div>
</div>
</div>

<h3>5.4 PCA를 단계별로 이해하기</h3>
<p>PCA의 과정을 하나씩 뜯어보자. 수학적으로는 복잡하지만, 각 단계의 의미를 이해하면 어렵지 않다.</p>

<!-- PCA 단계 다이어그램 (CSS) -->
<div style="margin:20px 0;font-size:13px">
<div style="display:flex;gap:8px;flex-wrap:wrap">
<div style="flex:1;min-width:180px;background:#e8f4f8;border-left:4px solid #3498db;padding:12px;border-radius:0 6px 6px 0">
<div style="font-weight:bold;color:#2c3e50">Step 1. 데이터 표준화</div>
<div style="color:#555;margin-top:4px">각 종목의 수익률을 평균=0, 표준편차=1로 맞춘다. 스케일이 다르면 큰 값이 PCA를 지배하기 때문.</div>
</div>
<div style="flex:1;min-width:180px;background:#fff9e6;border-left:4px solid #f39c12;padding:12px;border-radius:0 6px 6px 0">
<div style="font-weight:bold;color:#2c3e50">Step 2. 공분산 행렬 계산</div>
<div style="color:#555;margin-top:4px">종목 간 "같이 움직이는 정도"를 행렬로 정리. 50종목이면 50×50 행렬.</div>
</div>
<div style="flex:1;min-width:180px;background:#e8f8e8;border-left:4px solid #27ae60;padding:12px;border-radius:0 6px 6px 0">
<div style="font-weight:bold;color:#2c3e50">Step 3. 고유값 분해</div>
<div style="color:#555;margin-top:4px">공분산 행렬에서 고유값과 고유벡터를 구한다. 고유벡터 = 주성분 방향, 고유값 = 그 방향의 중요도.</div>
</div>
<div style="flex:1;min-width:180px;background:#f0e8f8;border-left:4px solid #8e44ad;padding:12px;border-radius:0 6px 6px 0">
<div style="font-weight:bold;color:#2c3e50">Step 4. 차원 축소</div>
<div style="color:#555;margin-top:4px">고유값이 큰 상위 k개 주성분만 선택. 50차원 → 3차원으로 압축해도 정보 대부분 보존.</div>
</div>
</div>
</div>

<p>핵심을 한 문장으로: <strong>공분산 행렬의 고유값 분해가 곧 PCA다.</strong> 가장 큰 고유값에 대응하는 고유벡터가 데이터의 분산을 가장 많이 설명하는 방향(제1주성분)이다.</p>

<h3>5.5 PCA 코드 실습 — 수동 구현</h3>

<pre><code><span class="cm"># 공분산 행렬의 고유값 분해 = PCA (수동 구현)</span>
cov_matrix = np.array([
    [<span class="nu">0.04</span>,  <span class="nu">0.02</span>,  <span class="nu">0.01</span>],
    [<span class="nu">0.02</span>,  <span class="nu">0.09</span>,  <span class="nu">0.03</span>],
    [<span class="nu">0.01</span>,  <span class="nu">0.03</span>,  <span class="nu">0.0625</span>]
])

eigenvalues, eigenvectors = np.linalg.eig(cov_matrix)

<span class="cm"># 고유값을 큰 순서로 정렬</span>
idx = eigenvalues.argsort()[::-<span class="nu">1</span>]
eigenvalues = eigenvalues[idx]
eigenvectors = eigenvectors[:, idx]

<span class="cm"># 분산 설명 비율</span>
explained = eigenvalues / eigenvalues.sum() * <span class="nu">100</span>

<span class="fn">print</span>(<span class="st">"=== PCA 결과 ==="</span>)
<span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(<span class="fn">len</span>(eigenvalues)):
    <span class="fn">print</span>(<span class="st">f"PC{i+1}: 고유값={eigenvalues[i]:.4f}, 설명비율={explained[i]:.1f}%"</span>)

<span class="fn">print</span>(<span class="st">f"\nPC1+PC2 누적: </span>{explained[:2].sum():.1f}<span class="st">%"</span>)
<span class="fn">print</span>(<span class="st">"→ 3개 종목의 움직임을 2개 주성분으로 대부분 설명 가능!"</span>)</code></pre>

<h3>5.6 sklearn으로 PCA — 실전 코드</h3>
<p>실전에서는 직접 고유값 분해를 하지 않고 sklearn의 PCA 클래스를 사용한다. 훨씬 편리하고, 대규모 데이터에서도 안정적이다.</p>

<pre><code><span class="kw">from</span> sklearn.decomposition <span class="kw">import</span> PCA
<span class="kw">from</span> sklearn.preprocessing <span class="kw">import</span> StandardScaler
<span class="kw">import</span> yfinance <span class="kw">as</span> yf

<span class="cm"># 실제 주식 데이터로 PCA</span>
tickers = [<span class="st">"005930.KS"</span>, <span class="st">"000660.KS"</span>, <span class="st">"035420.KS"</span>, <span class="st">"035720.KS"</span>, <span class="st">"373220.KS"</span>]
names = [<span class="st">"삼성전자"</span>, <span class="st">"SK하이닉스"</span>, <span class="st">"NAVER"</span>, <span class="st">"카카오"</span>, <span class="st">"LG에너지"</span>]

data = yf.download(tickers, period=<span class="st">"2y"</span>)[<span class="st">"Close"</span>]
data.columns = names
returns = data.pct_change().dropna()

<span class="cm"># Step 1: 표준화</span>
scaler = StandardScaler()
returns_scaled = scaler.fit_transform(returns)

<span class="cm"># Step 2: PCA 적용</span>
pca = PCA()  <span class="cm"># 모든 주성분 계산</span>
pc_scores = pca.fit_transform(returns_scaled)

<span class="cm"># 결과 분석</span>
<span class="fn">print</span>(<span class="st">"=== 실제 주식 데이터 PCA ==="</span>)
<span class="fn">print</span>(<span class="st">f"주성분 수: </span>{pca.n_components_}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"\n분산 설명 비율:"</span>)
<span class="kw">for</span> i, (var, cum) <span class="kw">in</span> <span class="fn">enumerate</span>(<span class="fn">zip</span>(
    pca.explained_variance_ratio_,
    np.cumsum(pca.explained_variance_ratio_)
)):
    <span class="fn">print</span>(<span class="st">f"  PC{i+1}: {var:.1%} (누적: {cum:.1%})"</span>)

<span class="cm"># 제1주성분의 로딩 (각 종목이 PC1에 기여하는 정도)</span>
<span class="fn">print</span>(<span class="st">f"\nPC1 로딩 (= 각 종목의 기여도):"</span>)
<span class="kw">for</span> name, loading <span class="kw">in</span> <span class="fn">zip</span>(names, pca.components_[<span class="nu">0</span>]):
    <span class="fn">print</span>(<span class="st">f"  {name}: {loading:.3f}"</span>)
<span class="fn">print</span>(<span class="st">"→ 모든 종목이 비슷한 부호 = PC1은 '시장 전체 방향'!"</span>)</code></pre>

<h3>5.7 스크리 플롯 — 주성분을 몇 개 쓸까?</h3>
<p>PCA를 할 때 가장 중요한 질문: "주성분을 몇 개 선택해야 하는가?" 스크리 플롯(scree plot)은 이 질문에 답하는 시각화 도구다. 각 주성분의 분산 설명 비율을 막대그래프로 그리고, 누적 비율을 꺾은선으로 그린다. "팔꿈치(elbow)" 지점 — 기울기가 급격히 완만해지는 곳 — 이 적절한 주성분 수다.</p>

<pre><code><span class="cm"># 스크리 플롯 (Scree Plot)</span>
fig, ax1 = plt.subplots(figsize=(<span class="nu">10</span>, <span class="nu">5</span>))

<span class="cm"># 막대: 개별 설명 비율</span>
x = <span class="fn">range</span>(<span class="nu">1</span>, <span class="fn">len</span>(pca.explained_variance_ratio_) + <span class="nu">1</span>)
ax1.bar(x, pca.explained_variance_ratio_ * <span class="nu">100</span>,
        color=<span class="st">"steelblue"</span>, alpha=<span class="nu">0.7</span>, label=<span class="st">"개별 설명 비율"</span>)
ax1.set_xlabel(<span class="st">"주성분 (PC)"</span>)
ax1.set_ylabel(<span class="st">"분산 설명 비율 (%)"</span>, color=<span class="st">"steelblue"</span>)
ax1.set_xticks(x)

<span class="cm"># 꺾은선: 누적 설명 비율</span>
ax2 = ax1.twinx()
cumulative = np.cumsum(pca.explained_variance_ratio_) * <span class="nu">100</span>
ax2.plot(x, cumulative, <span class="st">"ro-"</span>, linewidth=<span class="nu">2</span>, label=<span class="st">"누적 설명 비율"</span>)
ax2.axhline(y=<span class="nu">90</span>, color=<span class="st">"gray"</span>, linestyle=<span class="st">"--"</span>, alpha=<span class="nu">0.5</span>)
ax2.set_ylabel(<span class="st">"누적 비율 (%)"</span>, color=<span class="st">"red"</span>)
ax2.text(<span class="nu">4.5</span>, <span class="nu">91</span>, <span class="st">"90% 기준선"</span>, fontsize=<span class="nu">10</span>, color=<span class="st">"gray"</span>)

ax1.set_title(<span class="st">"Scree Plot — 주성분별 분산 설명 비율"</span>, fontsize=<span class="nu">14</span>)
fig.legend(loc=<span class="st">"center right"</span>, bbox_to_anchor=(<span class="nu">0.85</span>, <span class="nu">0.5</span>))
plt.tight_layout()
plt.show()</code></pre>

<h3>5.8 PCA의 금융 활용 — 왜 배워야 하는가</h3>
<p>PCA가 금융에서 쓰이는 대표적인 상황들:</p>

<div style="margin:20px 0;font-size:13px">
<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px">
<div style="background:#e8f4f8;padding:15px;border-radius:6px;border-top:3px solid #3498db">
<div style="font-weight:bold;color:#2c3e50;margin-bottom:6px">🔹 팩터 모델 (R5)</div>
<div style="color:#555">50개 종목의 움직임을 3~5개 팩터로 설명. "시장", "사이즈", "밸류" 팩터를 데이터에서 자동 추출.</div>
</div>
<div style="background:#fff9e6;padding:15px;border-radius:6px;border-top:3px solid #f39c12">
<div style="font-weight:bold;color:#2c3e50;margin-bottom:6px">🔸 차원 축소 (R5)</div>
<div style="color:#555">100개 피처를 10개로 압축. ML 모델의 과적합을 방지하고 학습 속도를 높인다.</div>
</div>
<div style="background:#e8f8e8;padding:15px;border-radius:6px;border-top:3px solid #27ae60">
<div style="font-weight:bold;color:#2c3e50;margin-bottom:6px">🔹 리스크 모델 (R8)</div>
<div style="color:#555">포트폴리오 위험을 소수의 주성분으로 분해. "이 포트폴리오의 위험 중 60%는 시장 리스크".</div>
</div>
<div style="background:#f0e8f8;padding:15px;border-radius:6px;border-top:3px solid #8e44ad">
<div style="font-weight:bold;color:#2c3e50;margin-bottom:6px">🔸 수익률 곡선 (R5)</div>
<div style="color:#555">채권 수익률 곡선의 변동을 3개 주성분(수준/기울기/곡률)으로 설명. 금리 리스크 관리의 핵심.</div>
</div>
</div>
</div>

<div class="def">
<p class="ni"><strong>PCA 핵심 정리:</strong></p>
<ul>
<li><strong>무엇:</strong> 고차원 데이터를 저차원으로 압축하되, 정보 손실을 최소화하는 기법</li>
<li><strong>어떻게:</strong> 공분산 행렬의 고유값 분해 → 큰 고유값의 고유벡터 = 주성분</li>
<li><strong>왜:</strong> 50개 종목을 3~5개 팩터로 요약, 과적합 방지, 시각화 가능</li>
<li><strong>언제:</strong> 피처가 너무 많을 때, 종목 간 구조를 파악하고 싶을 때</li>
</ul>
<p class="ni">Round 5에서 PCA를 본격적으로 다루며, t-SNE와 함께 차원 축소와 팩터 모델에 활용한다.</p>
</div>

<!-- ═══ Plotly: Ch.5 PCA 시각화 — 2D 데이터의 주성분 ═══ -->
<div id="plot-ch5-pca" style="width:100%;height:500px;margin:25px 0"></div>
<p class="ni" style="font-size:12px;color:#888;text-align:center">🖱️ 호버로 각 데이터 포인트 확인. 빨간 화살표(PC1)가 데이터 분산을 가장 많이 설명하는 방향입니다.</p>
<script>
(function(){
  // 상관관계 있는 2D 데이터 생성 (시드 고정)
  function mulberry32(a){return function(){a|=0;a=a+0x6D2B79F5|0;var t=Math.imul(a^a>>>15,1|a);t=t+Math.imul(t^t>>>7,61|t)^t;return((t^t>>>14)>>>0)/4294967296;}}
  var rng = mulberry32(42);
  function randn(){var u=0,v=0;while(u===0)u=rng();while(v===0)v=rng();return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);}
  
  var N=150, px=[], py=[];
  for(var i=0;i<N;i++){
    var x1=randn()*2, x2=0.7*x1+randn()*1.2;
    px.push(x1); py.push(x2);
  }
  
  // 수동 PCA: 평균 빼기
  var mx=0,my=0;
  for(var i=0;i<N;i++){mx+=px[i];my+=py[i];}
  mx/=N; my/=N;
  var cx=[],cy=[];
  for(var i=0;i<N;i++){cx.push(px[i]-mx);cy.push(py[i]-my);}
  
  // 공분산 계산
  var cxx=0,cyy=0,cxy=0;
  for(var i=0;i<N;i++){cxx+=cx[i]*cx[i];cyy+=cy[i]*cy[i];cxy+=cx[i]*cy[i];}
  cxx/=(N-1);cyy/=(N-1);cxy/=(N-1);
  
  // 2x2 고유값 분해
  var tr=cxx+cyy, det=cxx*cyy-cxy*cxy;
  var l1=(tr+Math.sqrt(tr*tr-4*det))/2;
  var l2=(tr-Math.sqrt(tr*tr-4*det))/2;
  var vx1=cxy, vy1=l1-cxx;
  var len1=Math.sqrt(vx1*vx1+vy1*vy1);
  vx1/=len1; vy1/=len1;
  var vx2=cxy, vy2=l2-cxx;
  var len2=Math.sqrt(vx2*vx2+vy2*vy2);
  vx2/=len2; vy2/=len2;
  
  var sc = 3; // 화살표 스케일
  var traces = [
    {x:px, y:py, mode:'markers', name:'데이터 (N=150)',
     marker:{size:6, color:'#3498db', opacity:0.6}},
    // PC1 화살표
    {x:[mx-vx1*sc, mx+vx1*sc], y:[my-vy1*sc, my+vy1*sc],
     mode:'lines', name:'PC1 (설명비율: '+(l1/(l1+l2)*100).toFixed(1)+'%)',
     line:{color:'#e74c3c', width:4}},
    // PC2 화살표
    {x:[mx-vx2*sc*0.6, mx+vx2*sc*0.6], y:[my-vy2*sc*0.6, my+vy2*sc*0.6],
     mode:'lines', name:'PC2 (설명비율: '+(l2/(l1+l2)*100).toFixed(1)+'%)',
     line:{color:'#f39c12', width:3, dash:'dash'}}
  ];
  
  var layout = {
    title:{text:'PCA: 데이터의 주성분 방향 (고유벡터 = 분산 최대 방향)', font:{size:14}},
    xaxis:{title:'Feature 1', zeroline:true, zerolinecolor:'#ddd'},
    yaxis:{title:'Feature 2', zeroline:true, zerolinecolor:'#ddd', scaleanchor:'x'},
    legend:{x:0.01, y:0.99, font:{size:11}},
    margin:{l:50, r:20, t:50, b:50},
    paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(248,249,250,0.5)'
  };
  
  Plotly.newPlot('plot-ch5-pca', traces, layout, {responsive:true});
})();
</script>

<!-- old PCA code replaced by expanded 5.5~5.8 above -->

<h3>5.9 양정치 행렬 (Positive Definite)</h3>
<p>공분산 행렬은 반드시 양반정치(positive semi-definite)여야 한다. 이것은 "모든 고유값이 0 이상"이라는 뜻이다. 왜 그래야 할까?</p>

<p>포트폴리오 분산 \(\sigma_p^2 = \mathbf{w}^T \boldsymbol{\Sigma} \mathbf{w}\)는 "분산"이므로 항상 0 이상이어야 한다. 만약 공분산 행렬의 고유값 중 음수가 있으면, 특정 비중 조합에서 분산이 음수가 되는 모순이 발생한다.</p>

<pre><code><span class="cm"># 양정치 확인: 모든 고유값 > 0?</span>
<span class="fn">print</span>(<span class="st">f"고유값: </span>{eigenvalues}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"모두 양수? </span>{np.all(eigenvalues > 0)}<span class="st">"</span>)  <span class="cm"># True → 양정치!</span>

<span class="cm"># 어떤 비중이든 분산은 항상 양수</span>
<span class="kw">for</span> _ <span class="kw">in</span> <span class="fn">range</span>(<span class="nu">5</span>):
    w_random = np.random.randn(<span class="nu">3</span>)
    w_random /= w_random.sum()
    var = w_random @ cov_matrix @ w_random
    <span class="fn">print</span>(<span class="st">f"  w={w_random.round(3)}, var={var:.6f} (>0? </span>{var > 0}<span class="st">)"</span>)</code></pre>

<!-- ═══════════════════════════════════════════ -->
<!-- Ch6: 확률분포 -->
<!-- ═══════════════════════════════════════════ -->
<h2 id="ch6">6. 확률분포</h2>

<h3>6.1 확률분포란?</h3>
<p>확률분포는 "어떤 사건이 일어날 확률이 어떻게 분포되어 있는가"를 수학적으로 표현한 것이다. 주사위를 던지면 1~6이 각각 1/6 확률로 나온다. 이것이 균일분포(uniform distribution)다.</p>

<p>금융에서 확률분포가 중요한 이유: 주가 수익률이 어떤 분포를 따르는지 알면, 미래 수익률의 범위를 예측하고, 위험(VaR)을 계산하고, 옵션 가격을 매길 수 있다.</p>

<!-- 확률분포 비교 다이어그램 (CSS) -->
<div style="margin:25px 0;padding:25px;background:linear-gradient(135deg,#f8f9fa,#eef2f7);border-radius:10px;border:1px solid #ccc">
<p class="ni" style="text-align:center;font-weight:bold;font-size:15px;margin-bottom:18px;color:#2c3e50">📊 금융에서 만나는 주요 확률분포</p>
<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px;font-size:12px">
<div style="background:#fff;padding:15px;border-radius:8px;border-left:4px solid #3498db;box-shadow:0 1px 3px rgba(0,0,0,0.1)">
<div style="font-weight:bold;color:#3498db;font-size:14px;margin-bottom:6px">🔔 정규분포</div>
<div style="text-align:center;font-size:24px;margin:8px 0">∩</div>
<div style="color:#555">종 모양, 좌우 대칭</div>
<div style="margin-top:6px;font-size:11px;color:#888">파라미터: μ(평균), σ(표준편차)</div>
<div style="margin-top:6px;padding:4px 8px;background:#e8f4f8;border-radius:4px;font-size:11px">💰 수익률 모델링의 기본 가정</div>
</div>
<div style="background:#fff;padding:15px;border-radius:8px;border-left:4px solid #e67e22;box-shadow:0 1px 3px rgba(0,0,0,0.1)">
<div style="font-weight:bold;color:#e67e22;font-size:14px;margin-bottom:6px">📈 로그정규분포</div>
<div style="text-align:center;font-size:24px;margin:8px 0">⌒</div>
<div style="color:#555">양수만, 오른쪽 꼬리 긴 형태</div>
<div style="margin-top:6px;font-size:11px;color:#888">파라미터: μ, σ (로그 스케일)</div>
<div style="margin-top:6px;padding:4px 8px;background:#fff9e6;border-radius:4px;font-size:11px">💰 주가 자체의 분포 (GBM)</div>
</div>
<div style="background:#fff;padding:15px;border-radius:8px;border-left:4px solid #e74c3c;box-shadow:0 1px 3px rgba(0,0,0,0.1)">
<div style="font-weight:bold;color:#e74c3c;font-size:14px;margin-bottom:6px">🐘 t-분포</div>
<div style="text-align:center;font-size:24px;margin:8px 0">⋂</div>
<div style="color:#555">정규분포보다 꼬리가 두꺼움</div>
<div style="margin-top:6px;font-size:11px;color:#888">파라미터: μ, σ, ν(자유도)</div>
<div style="margin-top:6px;padding:4px 8px;background:#fde8e8;border-radius:4px;font-size:11px">💰 팻테일 반영 VaR 계산</div>
</div>
<div style="background:#fff;padding:15px;border-radius:8px;border-left:4px solid #27ae60;box-shadow:0 1px 3px rgba(0,0,0,0.1)">
<div style="font-weight:bold;color:#27ae60;font-size:14px;margin-bottom:6px">⚡ 포아송분포</div>
<div style="text-align:center;font-size:24px;margin:8px 0">▎▎▎▎</div>
<div style="color:#555">이산형, 사건 발생 횟수</div>
<div style="margin-top:6px;font-size:11px;color:#888">파라미터: λ(평균 발생률)</div>
<div style="margin-top:6px;padding:4px 8px;background:#e8f8e8;border-radius:4px;font-size:11px">💰 HFT 주문 도착 모델링</div>
</div>
</div>
<div style="margin-top:15px;text-align:center;font-size:12px;color:#666">
<span style="display:inline-block;margin:0 12px">정규분포 → <strong>수익률</strong></span>
<span style="display:inline-block;margin:0 12px">로그정규 → <strong>주가</strong></span>
<span style="display:inline-block;margin:0 12px">t-분포 → <strong>위기 시 수익률</strong></span>
<span style="display:inline-block;margin:0 12px">포아송 → <strong>주문 빈도</strong></span>
</div>
</div>

<h3>6.2 정규분포 (Normal Distribution) — 종 모양의 곡선</h3>
<p>정규분포(가우시안 분포)는 통계학에서 가장 중요한 분포다. 키, 몸무게, IQ, 측정 오차 등 자연현상의 많은 것이 정규분포를 따른다. 금융에서는 주가 수익률이 정규분포를 따른다고 가정하는 것이 많은 모델의 출발점이다.</p>

<p>정규분포는 두 개의 파라미터로 완전히 결정된다:</p>
<ul>
<li><strong>평균 (μ, mu):</strong> 분포의 중심. 종 모양의 꼭대기 위치</li>
<li><strong>표준편차 (σ, sigma):</strong> 분포의 퍼짐 정도. 클수록 넓게 퍼진다</li>
</ul>

<div class="eq">\[ f(x) = \frac{1}{\sigma\sqrt{2\pi}} \exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right) \]</div>

<p>이 공식을 외울 필요는 없다. 중요한 것은 "68-95-99.7 규칙"이다:</p>
<ul>
<li>데이터의 68%가 μ ± 1σ 안에 있다</li>
<li>데이터의 95%가 μ ± 2σ 안에 있다</li>
<li>데이터의 99.7%가 μ ± 3σ 안에 있다</li>
</ul>

<!-- ── 보충 6.2+ 68-95-99.7 → VaR 연결 ── -->
<div class="def">
<p class="ni"><strong>🔍 보충: 68-95-99.7 규칙이 금융에서 왜 중요한가 — VaR 연결</strong></p>
<p class="ni">이 규칙은 단순한 통계 상식이 아니다. 금융 리스크 관리의 핵심 도구인 VaR(Value at Risk)의 기초다.</p>
<p class="ni">VaR는 "최악의 경우 얼마나 잃을 수 있는가"를 확률적으로 답하는 지표다. 예를 들어:</p>
<ul>
<li>포트폴리오 가치: 1억 원</li>
<li>일간 평균 수익률 μ = 0.05%, 일간 표준편차 σ = 1.5%</li>
<li><strong>95% VaR</strong> = μ - 1.645σ = 0.05% - 1.645×1.5% ≈ -2.42%</li>
<li>→ "내일 하루 동안 95% 확률로 최대 242만 원까지 잃을 수 있다"</li>
<li><strong>99% VaR</strong> = μ - 2.326σ ≈ -3.44% → 최대 344만 원 손실</li>
</ul>
<p class="ni">여기서 1.645와 2.326은 정규분포의 분위수(quantile)다. 68-95-99.7 규칙에서 95%가 ±2σ 안에 있다는 것은, 한쪽 꼬리(하위 2.5%)가 -2σ 밖에 있다는 뜻이다. VaR는 이 한쪽 꼬리를 정밀하게 계산한 것이다.</p>
</div>

<pre><code><span class="cm"># VaR 계산 예제: 68-95-99.7 규칙의 실전 적용</span>
portfolio_value = <span class="nu">100_000_000</span>  <span class="cm"># 1억 원</span>
mu_daily = <span class="nu">0.0005</span>   <span class="cm"># 일간 평균 수익률 0.05%</span>
sigma_daily = <span class="nu">0.015</span>  <span class="cm"># 일간 표준편차 1.5%</span>

<span class="cm"># 정규분포 가정 VaR</span>
<span class="kw">from</span> scipy <span class="kw">import</span> stats

var_95 = mu_daily - stats.norm.ppf(<span class="nu">0.95</span>) * sigma_daily
var_99 = mu_daily - stats.norm.ppf(<span class="nu">0.99</span>) * sigma_daily

<span class="fn">print</span>(<span class="st">"=== VaR (정규분포 가정) ==="</span>)
<span class="fn">print</span>(<span class="st">f"95% VaR: </span>{var_95*100:.2f}<span class="st">% = </span>{portfolio_value * abs(var_95):,.0f}<span class="st">원 손실"</span>)
<span class="fn">print</span>(<span class="st">f"99% VaR: </span>{var_99*100:.2f}<span class="st">% = </span>{portfolio_value * abs(var_99):,.0f}<span class="st">원 손실"</span>)
<span class="fn">print</span>(<span class="st">f"\n→ '내일 95% 확률로 최대 </span>{portfolio_value * abs(var_95):,.0f}<span class="st">원까지 잃을 수 있다'"</span>)
<span class="fn">print</span>(<span class="st">f"→ 이것이 은행/펀드가 매일 보고하는 리스크 지표!"</span>)</code></pre>

<pre><code><span class="kw">import</span> matplotlib.pyplot <span class="kw">as</span> plt
<span class="kw">from</span> scipy <span class="kw">import</span> stats

<span class="cm"># 정규분포 시뮬레이션: 일간 수익률</span>
mu = <span class="nu">0.0005</span>    <span class="cm"># 일간 평균 수익률 0.05%</span>
sigma = <span class="nu">0.015</span>  <span class="cm"># 일간 표준편차 1.5%</span>

<span class="cm"># 1000일 수익률 시뮬레이션</span>
np.random.seed(<span class="nu">42</span>)
sim_returns = np.random.normal(mu, sigma, <span class="nu">1000</span>)

<span class="fn">print</span>(<span class="st">"=== 시뮬레이션 결과 ==="</span>)
<span class="fn">print</span>(<span class="st">f"평균:     </span>{sim_returns.mean()*100:.3f}<span class="st">%"</span>)
<span class="fn">print</span>(<span class="st">f"표준편차: </span>{sim_returns.std()*100:.3f}<span class="st">%"</span>)

<span class="cm"># 68-95-99.7 규칙 검증</span>
within_1s = np.sum(np.abs(sim_returns - mu) < sigma) / <span class="fn">len</span>(sim_returns)
within_2s = np.sum(np.abs(sim_returns - mu) < <span class="nu">2</span>*sigma) / <span class="fn">len</span>(sim_returns)
within_3s = np.sum(np.abs(sim_returns - mu) < <span class="nu">3</span>*sigma) / <span class="fn">len</span>(sim_returns)
<span class="fn">print</span>(<span class="st">f"\n1σ 이내: </span>{within_1s:.1%}<span class="st"> (이론: 68.3%)"</span>)
<span class="fn">print</span>(<span class="st">f"2σ 이내: </span>{within_2s:.1%}<span class="st"> (이론: 95.4%)"</span>)
<span class="fn">print</span>(<span class="st">f"3σ 이내: </span>{within_3s:.1%}<span class="st"> (이론: 99.7%)"</span>)

<span class="cm"># 시각화</span>
fig, (ax1, ax2) = plt.subplots(<span class="nu">1</span>, <span class="nu">2</span>, figsize=(<span class="nu">14</span>, <span class="nu">5</span>))

<span class="cm"># 히스토그램 + 이론적 PDF</span>
ax1.hist(sim_returns*<span class="nu">100</span>, bins=<span class="nu">50</span>, density=<span class="kw">True</span>, alpha=<span class="nu">0.7</span>,
         color=<span class="st">'steelblue'</span>, edgecolor=<span class="st">'white'</span>, label=<span class="st">'Simulated'</span>)
x = np.linspace(-<span class="nu">5</span>, <span class="nu">5</span>, <span class="nu">200</span>)
ax1.plot(x, stats.norm.pdf(x, mu*<span class="nu">100</span>, sigma*<span class="nu">100</span>), <span class="st">'r-'</span>,
         linewidth=<span class="nu">2</span>, label=<span class="st">'Theoretical PDF'</span>)
ax1.axvline(mu*<span class="nu">100</span>, color=<span class="st">'black'</span>, linestyle=<span class="st">'--'</span>, alpha=<span class="nu">0.5</span>, label=<span class="st">'μ'</span>)
ax1.set_title(<span class="st">"Normal Distribution of Daily Returns"</span>, fontsize=<span class="nu">13</span>)
ax1.set_xlabel(<span class="st">"Daily Return (%)"</span>)
ax1.set_ylabel(<span class="st">"Density"</span>)
ax1.legend()

<span class="cm"># QQ Plot: 정규성 검정</span>
stats.probplot(sim_returns, dist=<span class="st">"norm"</span>, plot=ax2)
ax2.set_title(<span class="st">"QQ Plot (Normal)"</span>, fontsize=<span class="nu">13</span>)
plt.tight_layout()
plt.show()</code></pre>

<div class="info">
<p class="ni"><strong>QQ Plot 읽는 법:</strong> 점들이 빨간 직선 위에 놓이면 정규분포를 잘 따르는 것이다. 양 끝에서 직선을 벗어나면 팻테일(fat tail)이 존재한다는 뜻이다. 실제 금융 데이터는 거의 항상 양 끝에서 벗어난다.</p>
</div>

<h3>6.3 왜도와 첨도: 정규분포의 한계</h3>
<p>정규분포는 평균과 표준편차만으로 완전히 기술된다. 하지만 실제 금융 수익률은 정규분포와 다른 두 가지 특성을 보인다:</p>

<ul>
<li><strong>왜도 (Skewness):</strong> 분포가 좌우 대칭인가? 음의 왜도 = 왼쪽 꼬리가 길다 = 큰 손실이 큰 이익보다 자주 발생</li>
<li><strong>첨도 (Kurtosis):</strong> 꼬리가 얼마나 두꺼운가? 양의 초과첨도 = 극단적 사건이 정규분포 예측보다 자주 발생</li>
</ul>

<pre><code><span class="cm"># 왜도와 첨도 계산</span>
<span class="fn">print</span>(<span class="st">f"왜도 (Skewness): </span>{stats.skew(sim_returns):.3f}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"  → 0에 가까우면 대칭, 음수면 왼쪽 꼬리가 김"</span>)

<span class="fn">print</span>(<span class="st">f"첨도 (Kurtosis): </span>{stats.kurtosis(sim_returns):.3f}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"  → 0이면 정규분포, 양수면 팻테일 존재"</span>)</code></pre>

<h3>6.4 로그정규분포와 GBM</h3>
<p>주가 자체는 음수가 될 수 없다. 삼성전자 주가가 -50,000원이 될 수는 없지 않은가? 그래서 주가는 정규분포가 아니라 로그정규분포(log-normal distribution)를 따른다고 가정한다. 이것은 "로그 수익률이 정규분포를 따른다"는 것과 같은 말이다.</p>

<div class="eq">\[ \ln\left(\frac{S_t}{S_{t-1}}\right) \sim N(\mu, \sigma^2) \quad \Leftrightarrow \quad S_t \sim \text{LogNormal} \]</div>

<p>이 가정에서 출발하는 것이 GBM(Geometric Brownian Motion, 기하 브라운 운동)이다. GBM은 주가의 움직임을 시뮬레이션하는 가장 기본적인 모델이며, Black-Scholes 옵션 가격 모델의 기반이다.</p>

<pre><code><span class="cm"># GBM 시뮬레이션: 주가 경로 생성</span>
S0 = <span class="nu">70000</span>       <span class="cm"># 초기 주가 (삼성전자 약 7만원)</span>
mu_ann = <span class="nu">0.10</span>    <span class="cm"># 연간 기대수익률 10%</span>
sigma_ann = <span class="nu">0.30</span>  <span class="cm"># 연간 변동성 30%</span>
T = <span class="nu">1</span>             <span class="cm"># 1년</span>
dt = <span class="nu">1</span>/<span class="nu">252</span>        <span class="cm"># 일간 시간 간격</span>
N = <span class="nu">252</span>           <span class="cm"># 거래일 수</span>
n_paths = <span class="nu">5</span>      <span class="cm"># 시뮬레이션 경로 수</span>

np.random.seed(<span class="nu">42</span>)
fig, axes = plt.subplots(<span class="nu">1</span>, <span class="nu">2</span>, figsize=(<span class="nu">14</span>, <span class="nu">5</span>))

<span class="cm"># 여러 경로 시뮬레이션</span>
<span class="kw">for</span> path <span class="kw">in</span> <span class="fn">range</span>(n_paths):
    Z = np.random.normal(<span class="nu">0</span>, <span class="nu">1</span>, N)
    prices = np.zeros(N + <span class="nu">1</span>)
    prices[<span class="nu">0</span>] = S0
    
    <span class="kw">for</span> t <span class="kw">in</span> <span class="fn">range</span>(N):
        prices[t+<span class="nu">1</span>] = prices[t] * np.exp(
            (mu_ann - <span class="nu">0.5</span>*sigma_ann**<span class="nu">2</span>)*dt + sigma_ann*np.sqrt(dt)*Z[t]
        )
    
    axes[<span class="nu">0</span>].plot(prices, linewidth=<span class="nu">1</span>, alpha=<span class="nu">0.8</span>)

axes[<span class="nu">0</span>].axhline(y=S0, color=<span class="st">'black'</span>, linestyle=<span class="st">'--'</span>, alpha=<span class="nu">0.3</span>)
axes[<span class="nu">0</span>].set_title(<span class="st">"GBM Simulated Stock Prices"</span>, fontsize=<span class="nu">13</span>)
axes[<span class="nu">0</span>].set_xlabel(<span class="st">"Trading Days"</span>)
axes[<span class="nu">0</span>].set_ylabel(<span class="st">"Price (KRW)"</span>)
axes[<span class="nu">0</span>].grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)

<span class="cm"># 1000개 경로의 최종 가격 분포</span>
final_prices = []
<span class="kw">for</span> _ <span class="kw">in</span> <span class="fn">range</span>(<span class="nu">1000</span>):
    Z = np.random.normal(<span class="nu">0</span>, <span class="nu">1</span>, N)
    S = S0
    <span class="kw">for</span> t <span class="kw">in</span> <span class="fn">range</span>(N):
        S = S * np.exp((mu_ann - <span class="nu">0.5</span>*sigma_ann**<span class="nu">2</span>)*dt + sigma_ann*np.sqrt(dt)*Z[t])
    final_prices.append(S)

axes[<span class="nu">1</span>].hist(final_prices, bins=<span class="nu">50</span>, density=<span class="kw">True</span>, alpha=<span class="nu">0.7</span>,
             color=<span class="st">'steelblue'</span>, edgecolor=<span class="st">'white'</span>)
axes[<span class="nu">1</span>].axvline(x=S0, color=<span class="st">'red'</span>, linestyle=<span class="st">'--'</span>, label=<span class="st">f'Initial: {S0:,}'</span>)
axes[<span class="nu">1</span>].axvline(x=np.mean(final_prices), color=<span class="st">'green'</span>, linestyle=<span class="st">'--'</span>,
               label=<span class="st">f'Mean: {np.mean(final_prices):,.0f}'</span>)
axes[<span class="nu">1</span>].set_title(<span class="st">"Distribution of Final Prices (1Y)"</span>, fontsize=<span class="nu">13</span>)
axes[<span class="nu">1</span>].set_xlabel(<span class="st">"Price (KRW)"</span>)
axes[<span class="nu">1</span>].legend()
plt.tight_layout()
plt.show()</code></pre>

<div class="eq">\[ dS = \mu S \, dt + \sigma S \, dW_t \quad \text{(GBM 확률미분방정식)} \]</div>

<div class="info">
<p class="ni"><strong>GBM의 의미:</strong> 주가의 변화(dS)는 두 부분으로 구성된다. (1) 예측 가능한 추세(μS dt) — 평균적으로 연 10% 상승, (2) 예측 불가능한 랜덤 충격(σS dW) — 변동성에 비례하는 노이즈. 이 모델은 Round 8에서 Convex Optimization과 결합하여 포트폴리오 최적화에 활용된다.</p>
</div>

<h3>6.5 팻테일 (Fat Tails) — 정규분포의 위험한 착각</h3>
<p>실제 금융 수익률은 정규분포보다 꼬리가 두껍다. 이것을 팻테일(fat tails)이라 한다. 무슨 뜻인가?</p>

<p>정규분포에 따르면 일간 수익률이 -10%를 넘는 사건은 수십억 년에 한 번 일어나야 한다. 하지만 실제로는 몇 년에 한 번씩 일어난다. 2008년 금융위기, 2020년 코로나 폭락, 2022년 루나 사태 등. 정규분포를 맹신하면 위험을 과소평가하게 된다.</p>

<pre><code><span class="kw">import</span> yfinance <span class="kw">as</span> yf

<span class="cm"># 실제 비트코인 데이터로 팻테일 확인</span>
btc = yf.download(<span class="st">"BTC-USD"</span>, start=<span class="st">"2020-01-01"</span>, end=<span class="st">"2025-01-01"</span>)
btc_ret = btc[<span class="st">"Close"</span>].pct_change().dropna()

<span class="fn">print</span>(<span class="st">"=== 비트코인 수익률 통계 ==="</span>)
<span class="fn">print</span>(<span class="st">f"평균:     </span>{btc_ret.mean()*100:.3f}<span class="st">%/일"</span>)
<span class="fn">print</span>(<span class="st">f"표준편차: </span>{btc_ret.std()*100:.3f}<span class="st">%/일"</span>)
<span class="fn">print</span>(<span class="st">f"왜도:     </span>{btc_ret.skew():.3f}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"첨도:     </span>{btc_ret.kurtosis():.3f}<span class="st"> (정규분포=0)"</span>)
<span class="fn">print</span>(<span class="st">f"→ 첨도가 0보다 훨씬 크다 = 팻테일 존재!"</span>)

<span class="cm"># 극단적 사건 빈도</span>
n_3sigma = (np.abs(btc_ret) > <span class="nu">3</span> * btc_ret.std()).sum()
<span class="fn">print</span>(<span class="st">f"\n3σ 초과 사건: </span>{n_3sigma}<span class="st">회"</span>)
<span class="fn">print</span>(<span class="st">f"정규분포 예측: </span>{len(btc_ret) * 0.003:.1f}<span class="st">회"</span>)
<span class="fn">print</span>(<span class="st">f"→ 실제가 정규분포 예측보다 훨씬 많다!"</span>)</code></pre>

<div class="warn">
<p class="ni"><strong>실무적 교훈:</strong> VaR(Value at Risk)를 정규분포 가정으로 계산하면 위험을 과소평가한다. 실무에서는 t-분포, 역사적 시뮬레이션, 또는 Extreme Value Theory를 사용한다. HFT에서는 이 팻테일 리스크가 특히 중요하다 — 밀리초 단위로 거래하면 극단적 사건에 노출될 확률이 높아지기 때문이다.</p>
</div>

<div class="tc">Table 3. 주요 확률분포와 금융 활용</div>

<!-- ═══ Plotly: Ch.6 정규분포 vs t-분포 + GBM 시뮬레이션 ═══ -->
<div id="plot-ch6-dist" style="width:100%;height:460px;margin:25px 0"></div>
<p class="ni" style="font-size:12px;color:#888;text-align:center">🖱️ 범례 클릭으로 분포 on/off. 꼬리 부분(±3σ 이상)에서 t-분포가 정규분포보다 확률이 높은 것을 확인하세요.</p>

<div id="plot-ch6-gbm" style="width:100%;height:460px;margin:25px 0"></div>
<p class="ni" style="font-size:12px;color:#888;text-align:center">🖱️ 호버로 각 경로의 가격 확인. 같은 파라미터에서도 경로마다 결과가 크게 다릅니다 (불확실성!).</p>
<script>
(function(){
  // (1) 정규분포 vs t-분포 비교
  function normPdf(x, mu, sig){
    return Math.exp(-0.5*Math.pow((x-mu)/sig,2))/(sig*Math.sqrt(2*Math.PI));
  }
  // t-분포 PDF 근사 (Stirling)
  function tPdf(x, df){
    var g1 = 1, g2 = 1;
    // gamma((df+1)/2) / gamma(df/2) 근사
    var a = (df+1)/2, b = df/2;
    // 간단한 비율 근사
    var coeff = 1/(Math.sqrt(df*Math.PI));
    // Beta function 근사
    for(var k=0; k<20; k++){
      coeff *= (a+k-1)/(b+k-1) * (k>0?1:1);
    }
    // 직접 계산
    return (1/Math.sqrt(df*Math.PI)) * 
           (Math.exp(lgamma((df+1)/2) - lgamma(df/2))) *
           Math.pow(1+x*x/df, -(df+1)/2);
  }
  function lgamma(z){
    // Lanczos approximation
    var g=7, c=[0.99999999999980993,676.5203681218851,-1259.1392167224028,
    771.32342877765313,-176.61502916214059,12.507343278686905,
    -0.13857109526572012,9.9843695780195716e-6,1.5056327351493116e-7];
    if(z<0.5) return Math.log(Math.PI/Math.sin(Math.PI*z))-lgamma(1-z);
    z-=1; var x=c[0];
    for(var i=1;i<g+2;i++) x+=c[i]/(z+i);
    var t=z+g+0.5;
    return 0.5*Math.log(2*Math.PI)+(z+0.5)*Math.log(t)-t+Math.log(x);
  }
  
  var xArr=[], yNorm=[], yT3=[], yT5=[], yT30=[];
  for(var i=-50;i<=50;i++){
    var x=i*0.1;
    xArr.push(x);
    yNorm.push(normPdf(x,0,1));
    yT3.push(tPdf(x,3));
    yT5.push(tPdf(x,5));
    yT30.push(tPdf(x,30));
  }
  
  Plotly.newPlot('plot-ch6-dist', [
    {x:xArr, y:yNorm, mode:'lines', name:'정규분포 (N(0,1))', line:{color:'#3498db', width:3}},
    {x:xArr, y:yT3, mode:'lines', name:'t-분포 (ν=3) — 팻테일', line:{color:'#e74c3c', width:2, dash:'dash'}},
    {x:xArr, y:yT5, mode:'lines', name:'t-분포 (ν=5)', line:{color:'#f39c12', width:2, dash:'dot'}},
    {x:xArr, y:yT30, mode:'lines', name:'t-분포 (ν=30) ≈ 정규', line:{color:'#27ae60', width:2, dash:'dashdot'}}
  ], {
    title:{text:'정규분포 vs t-분포: 꼬리 두께 비교 (ν↓ → 팻테일↑)', font:{size:14}},
    xaxis:{title:'x (표준편차 단위)', range:[-5,5]},
    yaxis:{title:'확률밀도 f(x)', range:[0,0.45]},
    legend:{x:0.6, y:0.95, font:{size:11}},
    margin:{l:60, r:20, t:50, b:50},
    paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(248,249,250,0.5)',
    shapes:[{type:'rect',x0:-1,x1:1,y0:0,y1:0.45,fillcolor:'rgba(52,152,219,0.05)',line:{width:0}},
            {type:'line',x0:-3,y0:0,x1:-3,y1:0.01,line:{color:'#e74c3c',width:1,dash:'dot'}},
            {type:'line',x0:3,y0:0,x1:3,y1:0.01,line:{color:'#e74c3c',width:1,dash:'dot'}}],
    annotations:[{x:0,y:0.42,text:'68% 영역 (±1σ)',showarrow:false,font:{size:10,color:'#3498db'}},
                 {x:3.5,y:0.015,text:'팻테일 영역',showarrow:false,font:{size:10,color:'#e74c3c'}}]
  }, {responsive:true});
  
  // (2) GBM 시뮬레이션
  function mulberry32(a){return function(){a|=0;a=a+0x6D2B79F5|0;var t=Math.imul(a^a>>>15,1|a);t=t+Math.imul(t^t>>>7,61|t)^t;return((t^t>>>14)>>>0)/4294967296;}}
  function boxMuller(rng){var u=0,v=0;while(u===0)u=rng();while(v===0)v=rng();return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);}
  
  var S0=70000, mu=0.10, sig=0.30, dt=1/252, nDays=252, nPaths=8;
  var colors = ['#3498db','#e74c3c','#27ae60','#f39c12','#8e44ad','#1abc9c','#e67e22','#2c3e50'];
  var gbmTraces = [];
  
  for(var p=0; p<nPaths; p++){
    var rng = mulberry32(42+p*17);
    var prices = [S0], days = [0];
    var S = S0;
    for(var d=1; d<=nDays; d++){
      var Z = boxMuller(rng);
      S = S * Math.exp((mu-0.5*sig*sig)*dt + sig*Math.sqrt(dt)*Z);
      prices.push(Math.round(S));
      days.push(d);
    }
    gbmTraces.push({
      x:days, y:prices, mode:'lines', name:'경로 '+(p+1)+' (최종: ₩'+prices[nDays].toLocaleString()+')',
      line:{color:colors[p], width:1.5}, opacity:0.8
    });
  }
  
  gbmTraces.push({
    x:[0,252], y:[S0,S0], mode:'lines', name:'초기가격 ₩70,000',
    line:{color:'black', width:2, dash:'dash'}, showlegend:true
  });
  
  Plotly.newPlot('plot-ch6-gbm', gbmTraces, {
    title:{text:'GBM 시뮬레이션: 삼성전자 1년 주가 경로 (μ=10%, σ=30%)', font:{size:14}},
    xaxis:{title:'거래일'},
    yaxis:{title:'주가 (원)', tickformat:','},
    legend:{x:0.01, y:0.99, font:{size:10}},
    margin:{l:80, r:20, t:50, b:50},
    paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(248,249,250,0.5)'
  }, {responsive:true});
})();
</script>
<table>
<tr><th>분포</th><th>파라미터</th><th>특징</th><th>금융 활용</th></tr>
<tr><td>정규분포</td><td>μ, σ</td><td>종 모양, 대칭</td><td>수익률 모델링 (기본 가정)</td></tr>
<tr><td>로그정규분포</td><td>μ, σ</td><td>양수만, 우편향</td><td>주가 모델링 (GBM)</td></tr>
<tr><td>t-분포</td><td>μ, σ, ν(자유도)</td><td>팻테일</td><td>VaR 계산, 로버스트 추정</td></tr>
<tr><td>균일분포</td><td>a, b</td><td>모든 값 동일 확률</td><td>몬테카를로 시뮬레이션</td></tr>
<tr><td>포아송분포</td><td>λ</td><td>이산, 사건 횟수</td><td>주문 도착 모델링 (HFT)</td></tr>
<tr><td>지수분포</td><td>λ</td><td>대기 시간</td><td>주문 간 시간 간격 (HFT)</td></tr>
</table>

<!-- ── 보충 6.5+ t-분포 심화 코드 ── -->
<h3>6.6 t-분포 심화 — 팻테일을 수학적으로 다루기</h3>
<p>t-분포는 정규분포와 비슷하게 생겼지만 꼬리가 더 두껍다. 자유도(ν, degrees of freedom) 파라미터가 꼬리의 두께를 결정한다. ν가 작을수록 꼬리가 두껍고, ν → ∞이면 정규분포와 같아진다.</p>

<p>왜 t-분포가 금융에서 중요한가? 실제 수익률 데이터에 정규분포를 씌우면 극단적 손실의 확률을 과소평가한다. t-분포를 사용하면 팻테일을 반영하여 더 보수적인(안전한) 리스크 추정이 가능하다.</p>

<pre><code><span class="kw">from</span> scipy <span class="kw">import</span> stats

<span class="cm"># 정규분포 vs t-분포 비교</span>
x = np.linspace(-<span class="nu">5</span>, <span class="nu">5</span>, <span class="nu">300</span>)

fig, (ax1, ax2) = plt.subplots(<span class="nu">1</span>, <span class="nu">2</span>, figsize=(<span class="nu">14</span>, <span class="nu">5</span>))

<span class="cm"># (a) PDF 비교: 꼬리 부분에 주목</span>
ax1.plot(x, stats.norm.pdf(x), <span class="st">'b-'</span>, linewidth=<span class="nu">2</span>, label=<span class="st">'정규분포'</span>)
ax1.plot(x, stats.t.pdf(x, df=<span class="nu">3</span>), <span class="st">'r--'</span>, linewidth=<span class="nu">2</span>, label=<span class="st">'t-분포 (ν=3)'</span>)
ax1.plot(x, stats.t.pdf(x, df=<span class="nu">5</span>), <span class="st">'g-.'</span>, linewidth=<span class="nu">2</span>, label=<span class="st">'t-분포 (ν=5)'</span>)
ax1.plot(x, stats.t.pdf(x, df=<span class="nu">30</span>), <span class="st">'m:'</span>, linewidth=<span class="nu">2</span>, label=<span class="st">'t-분포 (ν=30)'</span>)
ax1.set_title(<span class="st">"정규분포 vs t-분포 (전체)"</span>)
ax1.legend(); ax1.grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)

<span class="cm"># (b) 꼬리 부분 확대 — 차이가 극적으로 보인다</span>
x_tail = np.linspace(<span class="nu">3</span>, <span class="nu">6</span>, <span class="nu">100</span>)
ax2.plot(x_tail, stats.norm.pdf(x_tail), <span class="st">'b-'</span>, linewidth=<span class="nu">2</span>, label=<span class="st">'정규분포'</span>)
ax2.plot(x_tail, stats.t.pdf(x_tail, df=<span class="nu">3</span>), <span class="st">'r--'</span>, linewidth=<span class="nu">2</span>, label=<span class="st">'t-분포 (ν=3)'</span>)
ax2.plot(x_tail, stats.t.pdf(x_tail, df=<span class="nu">5</span>), <span class="st">'g-.'</span>, linewidth=<span class="nu">2</span>, label=<span class="st">'t-분포 (ν=5)'</span>)
ax2.set_title(<span class="st">"꼬리 부분 확대 (3σ~6σ)"</span>)
ax2.legend(); ax2.grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)
ax2.set_yscale(<span class="st">'log'</span>)  <span class="cm"># 로그 스케일로 차이를 명확히</span>

plt.tight_layout()
plt.show()

<span class="cm"># VaR 비교: 정규분포 vs t-분포</span>
<span class="fn">print</span>(<span class="st">"=== 99% VaR 비교 (σ=1 기준) ==="</span>)
<span class="fn">print</span>(<span class="st">f"정규분포:     </span>{stats.norm.ppf(0.01):.3f}<span class="st">σ"</span>)
<span class="fn">print</span>(<span class="st">f"t-분포(ν=5): </span>{stats.t.ppf(0.01, df=5):.3f}<span class="st">σ"</span>)
<span class="fn">print</span>(<span class="st">f"t-분포(ν=3): </span>{stats.t.ppf(0.01, df=3):.3f}<span class="st">σ"</span>)
<span class="fn">print</span>(<span class="st">f"\n→ t-분포(ν=3)의 99% VaR이 정규분포보다 약 1.3배 크다!"</span>)
<span class="fn">print</span>(<span class="st">f"→ 정규분포를 쓰면 위험을 과소평가하게 된다."</span>)</code></pre>

<div class="warn">
<p class="ni"><strong>실전 팁:</strong> 실제 금융 수익률의 자유도를 추정하면 보통 ν = 3~8 정도가 나온다. 이것은 정규분포(ν=∞)와 상당히 다르다. 많은 퀀트 펀드에서 VaR 계산 시 t-분포를 사용하거나, 역사적 시뮬레이션(분포 가정 없이 실제 데이터 사용)을 병행한다.</p>
</div>

<!-- ═══════════════════════════════════════════ -->
<!-- Ch7: 공분산과 상관계수 -->
<!-- ═══════════════════════════════════════════ -->
<h2 id="ch7">7. 공분산과 상관계수</h2>

<!-- 상관관계 시각적 다이어그램 (CSS) -->
<div style="margin:25px 0;padding:25px;background:linear-gradient(135deg,#f8f9fa,#f0f4f8);border-radius:10px;border:1px solid #ccc">
<p class="ni" style="text-align:center;font-weight:bold;font-size:15px;margin-bottom:18px;color:#2c3e50">🔗 상관관계의 세 가지 유형</p>
<div style="display:flex;justify-content:center;gap:20px;flex-wrap:wrap;font-size:12px">
<div style="text-align:center;min-width:160px">
<div style="width:130px;height:100px;margin:0 auto;position:relative;background:#fff;border:1px solid #ddd;border-radius:6px;overflow:hidden">
<div style="position:absolute;bottom:10px;left:10px;width:4px;height:4px;background:#3498db;border-radius:50%"></div>
<div style="position:absolute;bottom:25px;left:25px;width:4px;height:4px;background:#3498db;border-radius:50%"></div>
<div style="position:absolute;bottom:40px;left:40px;width:4px;height:4px;background:#3498db;border-radius:50%"></div>
<div style="position:absolute;bottom:55px;left:55px;width:4px;height:4px;background:#3498db;border-radius:50%"></div>
<div style="position:absolute;bottom:65px;left:70px;width:4px;height:4px;background:#3498db;border-radius:50%"></div>
<div style="position:absolute;bottom:75px;left:85px;width:4px;height:4px;background:#3498db;border-radius:50%"></div>
<div style="position:absolute;bottom:85px;left:100px;width:4px;height:4px;background:#3498db;border-radius:50%"></div>
<div style="position:absolute;bottom:5px;left:5px;width:110px;height:1px;background:#3498db;transform:rotate(-40deg);transform-origin:left bottom;opacity:0.4"></div>
</div>
<div style="font-weight:bold;color:#3498db;margin-top:8px">양의 상관 (ρ ≈ +0.8)</div>
<div style="color:#555;font-size:11px">삼성전자 ↑ → SK하이닉스 ↑</div>
<div style="color:#888;font-size:11px">같은 방향으로 움직임</div>
</div>
<div style="text-align:center;min-width:160px">
<div style="width:130px;height:100px;margin:0 auto;position:relative;background:#fff;border:1px solid #ddd;border-radius:6px;overflow:hidden">
<div style="position:absolute;bottom:80px;left:10px;width:4px;height:4px;background:#e74c3c;border-radius:50%"></div>
<div style="position:absolute;bottom:70px;left:25px;width:4px;height:4px;background:#e74c3c;border-radius:50%"></div>
<div style="position:absolute;bottom:55px;left:45px;width:4px;height:4px;background:#e74c3c;border-radius:50%"></div>
<div style="position:absolute;bottom:40px;left:60px;width:4px;height:4px;background:#e74c3c;border-radius:50%"></div>
<div style="position:absolute;bottom:25px;left:75px;width:4px;height:4px;background:#e74c3c;border-radius:50%"></div>
<div style="position:absolute;bottom:15px;left:90px;width:4px;height:4px;background:#e74c3c;border-radius:50%"></div>
<div style="position:absolute;bottom:10px;left:105px;width:4px;height:4px;background:#e74c3c;border-radius:50%"></div>
<div style="position:absolute;bottom:85px;left:5px;width:110px;height:1px;background:#e74c3c;transform:rotate(40deg);transform-origin:left top;opacity:0.4"></div>
</div>
<div style="font-weight:bold;color:#e74c3c;margin-top:8px">음의 상관 (ρ ≈ -0.5)</div>
<div style="color:#555;font-size:11px">주식 ↑ → 채권 ↓</div>
<div style="color:#888;font-size:11px">반대 방향으로 움직임</div>
</div>
<div style="text-align:center;min-width:160px">
<div style="width:130px;height:100px;margin:0 auto;position:relative;background:#fff;border:1px solid #ddd;border-radius:6px;overflow:hidden">
<div style="position:absolute;bottom:30px;left:15px;width:4px;height:4px;background:#888;border-radius:50%"></div>
<div style="position:absolute;bottom:60px;left:25px;width:4px;height:4px;background:#888;border-radius:50%"></div>
<div style="position:absolute;bottom:45px;left:45px;width:4px;height:4px;background:#888;border-radius:50%"></div>
<div style="position:absolute;bottom:70px;left:55px;width:4px;height:4px;background:#888;border-radius:50%"></div>
<div style="position:absolute;bottom:20px;left:70px;width:4px;height:4px;background:#888;border-radius:50%"></div>
<div style="position:absolute;bottom:55px;left:85px;width:4px;height:4px;background:#888;border-radius:50%"></div>
<div style="position:absolute;bottom:35px;left:100px;width:4px;height:4px;background:#888;border-radius:50%"></div>
</div>
<div style="font-weight:bold;color:#888;margin-top:8px">무상관 (ρ ≈ 0)</div>
<div style="color:#555;font-size:11px">주식 ↑ → 원자재 ???</div>
<div style="color:#888;font-size:11px">관계 없이 각자 움직임</div>
</div>
</div>
<div style="margin-top:15px;text-align:center;font-size:12px;color:#555;background:#fff;padding:8px;border-radius:6px">
💡 <strong>포트폴리오 핵심:</strong> 음의 상관 자산을 섞으면 → 분산 효과 극대화 → 위험 감소!
</div>
</div>

<h3>7.1 공분산이란? — "같이 움직이는 정도"</h3>
<p>공분산(covariance)은 두 변수가 함께 움직이는 정도를 측정한다. 삼성전자가 오를 때 SK하이닉스도 같이 오르는 경향이 있다면, 두 종목의 공분산은 양수다. 삼성전자가 오를 때 금 가격이 내리는 경향이 있다면, 공분산은 음수다.</p>

<p>비유를 들어보자. 두 사람이 같이 걷는다고 하자. 한 사람이 오른쪽으로 가면 다른 사람도 오른쪽으로 가면 양의 공분산, 반대로 가면 음의 공분산, 아무 관계 없이 각자 걸으면 공분산이 0에 가깝다.</p>

<div class="eq">\[ \text{Cov}(X, Y) = \frac{1}{n-1}\sum_{i=1}^{n}(X_i - \bar{X})(Y_i - \bar{Y}) \]</div>

<p>이 공식의 직관: 각 데이터 포인트에서 X가 평균보다 높을 때 Y도 평균보다 높으면 양수 기여, X가 높을 때 Y가 낮으면 음수 기여. 이것을 전부 더한 것이 공분산이다.</p>

<pre><code><span class="cm"># 공분산 직접 계산해보기</span>
np.random.seed(<span class="nu">42</span>)

<span class="cm"># 양의 상관: 삼성 오르면 SK도 오르는 경향</span>
samsung = np.random.normal(<span class="nu">0.05</span>, <span class="nu">2.0</span>, <span class="nu">252</span>)
sk = <span class="nu">0.7</span> * samsung + np.random.normal(<span class="nu">0</span>, <span class="nu">1.5</span>, <span class="nu">252</span>)

<span class="cm"># 수동 계산</span>
mean_s = samsung.mean()
mean_sk = sk.mean()
cov_manual = np.sum((samsung - mean_s) * (sk - mean_sk)) / (<span class="fn">len</span>(samsung) - <span class="nu">1</span>)
<span class="fn">print</span>(<span class="st">f"수동 계산 공분산: </span>{cov_manual:.4f}<span class="st">"</span>)

<span class="cm"># NumPy 계산</span>
cov_numpy = np.cov(samsung, sk)[<span class="nu">0</span>, <span class="nu">1</span>]
<span class="fn">print</span>(<span class="st">f"NumPy 공분산:    </span>{cov_numpy:.4f}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"→ 양수 = 같은 방향으로 움직이는 경향!"</span>)</code></pre>

<h3>7.2 상관계수 — 공분산의 표준화</h3>
<p>공분산의 문제점: 단위에 의존한다. 수익률(%)로 계산한 공분산과 가격(원)으로 계산한 공분산은 크기가 완전히 다르다. 비교가 어렵다.</p>

<p>이 문제를 해결한 것이 상관계수(correlation coefficient)다. 공분산을 각 변수의 표준편차로 나누어 -1에서 1 사이로 표준화한 것이다.</p>

<div class="eq">\[ \rho_{XY} = \frac{\text{Cov}(X, Y)}{\sigma_X \cdot \sigma_Y} \quad (-1 \leq \rho \leq 1) \]</div>

<pre><code><span class="cm"># 상관계수 계산</span>
corr_manual = cov_numpy / (samsung.std(ddof=<span class="nu">1</span>) * sk.std(ddof=<span class="nu">1</span>))
corr_numpy = np.corrcoef(samsung, sk)[<span class="nu">0</span>, <span class="nu">1</span>]

<span class="fn">print</span>(<span class="st">f"수동 계산: </span>{corr_manual:.4f}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"NumPy:    </span>{corr_numpy:.4f}<span class="st">"</span>)

<span class="cm"># 시각화: 산점도로 상관관계 확인</span>
fig, axes = plt.subplots(<span class="nu">1</span>, <span class="nu">3</span>, figsize=(<span class="nu">15</span>, <span class="nu">4</span>))

<span class="cm"># 양의 상관</span>
axes[<span class="nu">0</span>].scatter(samsung, sk, s=<span class="nu">10</span>, alpha=<span class="nu">0.5</span>, color=<span class="st">'steelblue'</span>)
axes[<span class="nu">0</span>].set_title(<span class="st">f"Positive Corr (ρ={corr_numpy:.2f})"</span>)
axes[<span class="nu">0</span>].set_xlabel(<span class="st">"Samsung Return"</span>)
axes[<span class="nu">0</span>].set_ylabel(<span class="st">"SK Return"</span>)

<span class="cm"># 음의 상관: 주식 vs 채권</span>
bond = -<span class="nu">0.3</span> * samsung + np.random.normal(<span class="nu">0</span>, <span class="nu">1.0</span>, <span class="nu">252</span>)
corr_neg = np.corrcoef(samsung, bond)[<span class="nu">0</span>, <span class="nu">1</span>]
axes[<span class="nu">1</span>].scatter(samsung, bond, s=<span class="nu">10</span>, alpha=<span class="nu">0.5</span>, color=<span class="st">'coral'</span>)
axes[<span class="nu">1</span>].set_title(<span class="st">f"Negative Corr (ρ={corr_neg:.2f})"</span>)
axes[<span class="nu">1</span>].set_xlabel(<span class="st">"Samsung Return"</span>)
axes[<span class="nu">1</span>].set_ylabel(<span class="st">"Bond Return"</span>)

<span class="cm"># 무상관</span>
random_asset = np.random.normal(<span class="nu">0</span>, <span class="nu">1.5</span>, <span class="nu">252</span>)
corr_zero = np.corrcoef(samsung, random_asset)[<span class="nu">0</span>, <span class="nu">1</span>]
axes[<span class="nu">2</span>].scatter(samsung, random_asset, s=<span class="nu">10</span>, alpha=<span class="nu">0.5</span>, color=<span class="st">'gray'</span>)
axes[<span class="nu">2</span>].set_title(<span class="st">f"No Corr (ρ={corr_zero:.2f})"</span>)
axes[<span class="nu">2</span>].set_xlabel(<span class="st">"Samsung Return"</span>)
axes[<span class="nu">2</span>].set_ylabel(<span class="st">"Random Asset"</span>)

<span class="kw">for</span> ax <span class="kw">in</span> axes:
    ax.grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)
plt.tight_layout()
plt.show()</code></pre>

<div class="tc">Table 4. 상관계수 해석 가이드</div>
<table>
<tr><th>범위</th><th>해석</th><th>예시</th><th>포트폴리오 효과</th></tr>
<tr><td>\(0.7 \leq \rho \leq 1\)</td><td>강한 양의 상관</td><td>삼성-SK하이닉스</td><td>분산 효과 약함</td></tr>
<tr><td>\(0.3 \leq \rho < 0.7\)</td><td>중간 양의 상관</td><td>삼성-NAVER</td><td>어느 정도 분산 효과</td></tr>
<tr><td>\(-0.3 < \rho < 0.3\)</td><td>약한 상관 / 무상관</td><td>주식-원자재</td><td>좋은 분산 효과</td></tr>
<tr><td>\(-0.7 \leq \rho \leq -0.3\)</td><td>중간 음의 상관</td><td>주식-채권</td><td>강한 분산 효과</td></tr>
<tr><td>\(-1 \leq \rho < -0.7\)</td><td>강한 음의 상관</td><td>롱-숏 포지션</td><td>헤지 가능</td></tr>
</table>

<h3>7.3 공분산 행렬 — 모든 쌍의 공분산을 한 번에</h3>
<p>종목이 m개 있으면 공분산 쌍은 m×m개다. 이것을 하나의 행렬로 정리한 것이 공분산 행렬이다. 대각선에는 각 종목의 분산(자기 자신과의 공분산), 비대각선에는 종목 간 공분산이 들어간다.</p>

<div class="eq">\[ \boldsymbol{\Sigma} = \begin{bmatrix} \sigma_1^2 & \text{Cov}(1,2) & \cdots & \text{Cov}(1,m) \\ \text{Cov}(2,1) & \sigma_2^2 & \cdots & \text{Cov}(2,m) \\ \vdots & \vdots & \ddots & \vdots \\ \text{Cov}(m,1) & \text{Cov}(m,2) & \cdots & \sigma_m^2 \end{bmatrix} \]</div>

<p>공분산 행렬의 중요한 성질:</p>
<ul>
<li><strong>대칭:</strong> Cov(X,Y) = Cov(Y,X)이므로 \(\boldsymbol{\Sigma}^T = \boldsymbol{\Sigma}\)</li>
<li><strong>양반정치:</strong> 모든 고유값 ≥ 0 (포트폴리오 분산이 항상 ≥ 0이 되려면)</li>
<li><strong>대각선 = 분산:</strong> \(\Sigma_{ii} = \sigma_i^2\)</li>
</ul>

<pre><code><span class="cm"># 4종목 공분산 행렬 계산</span>
np.random.seed(<span class="nu">42</span>)
n_days = <span class="nu">252</span>

<span class="cm"># 상관관계가 있는 4종목 수익률 생성</span>
true_cov = np.array([
    [<span class="nu">4.0</span>, <span class="nu">2.0</span>, <span class="nu">1.0</span>, <span class="nu">0.5</span>],
    [<span class="nu">2.0</span>, <span class="nu">3.0</span>, <span class="nu">1.5</span>, <span class="nu">0.8</span>],
    [<span class="nu">1.0</span>, <span class="nu">1.5</span>, <span class="nu">5.0</span>, <span class="nu">0.3</span>],
    [<span class="nu">0.5</span>, <span class="nu">0.8</span>, <span class="nu">0.3</span>, <span class="nu">2.0</span>]
])

returns_4 = np.random.multivariate_normal(
    mean=[<span class="nu">0.05</span>, <span class="nu">0.03</span>, <span class="nu">0.04</span>, <span class="nu">0.02</span>],
    cov=true_cov,
    size=n_days
)
names_4 = [<span class="st">"Stock A"</span>, <span class="st">"Stock B"</span>, <span class="st">"Stock C"</span>, <span class="st">"Stock D"</span>]

<span class="cm"># 표본 공분산 행렬</span>
sample_cov = np.cov(returns_4.T)
sample_corr = np.corrcoef(returns_4.T)

<span class="fn">print</span>(<span class="st">"=== 공분산 행렬 ==="</span>)
<span class="fn">print</span>(np.round(sample_cov, <span class="nu">3</span>))

<span class="fn">print</span>(<span class="st">"\n=== 상관행렬 ==="</span>)
<span class="fn">print</span>(np.round(sample_corr, <span class="nu">3</span>))

<span class="fn">print</span>(<span class="st">"\n대칭 확인:"</span>, np.allclose(sample_cov, sample_cov.T))
<span class="fn">print</span>(<span class="st">"양정치 확인:"</span>, np.all(np.linalg.eigvals(sample_cov) > <span class="nu">0</span>))</code></pre>

<div class="ok">
<p class="ni"><strong>핵심 정리:</strong> 공분산 행렬은 포트폴리오 이론의 심장이다. 이 행렬 하나로 (1) 포트폴리오 분산 계산, (2) 최소분산 포트폴리오 도출, (3) 효율적 프론티어 그리기, (4) PCA로 팩터 추출이 모두 가능하다. Round 8에서 Convex Optimization으로 이 행렬을 활용한 최적 포트폴리오를 구한다.</p>
</div>

<!-- ═══ Plotly: Ch.7 상관계수별 산점도 + 포트폴리오 변동성 ═══ -->
<div id="plot-ch7-corr" style="width:100%;height:460px;margin:25px 0"></div>
<p class="ni" style="font-size:12px;color:#888;text-align:center">🖱️ 범례 클릭으로 상관계수별 산점도 on/off. ρ가 음수일수록 점들이 반대 방향으로 퍼집니다.</p>

<div id="plot-ch7-diveff" style="width:100%;height:420px;margin:25px 0"></div>
<p class="ni" style="font-size:12px;color:#888;text-align:center">🖱️ 호버로 정확한 값 확인. 상관계수가 낮을수록 포트폴리오 변동성이 감소합니다 (분산 효과!).</p>
<script>
(function(){
  // (1) 상관계수별 산점도
  function mulberry32(a){return function(){a|=0;a=a+0x6D2B79F5|0;var t=Math.imul(a^a>>>15,1|a);t=t+Math.imul(t^t>>>7,61|t)^t;return((t^t>>>14)>>>0)/4294967296;}}
  function boxMuller(rng){var u=0,v=0;while(u===0)u=rng();while(v===0)v=rng();return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);}
  
  var rhos = [0.9, 0.5, 0.0, -0.5, -0.9];
  var colors = ['#e74c3c','#f39c12','#888888','#3498db','#8e44ad'];
  var labels = ['ρ=+0.9 (강한 양)','ρ=+0.5 (중간 양)','ρ=0 (무상관)','ρ=-0.5 (중간 음)','ρ=-0.9 (강한 음)'];
  var corrTraces = [];
  
  for(var r=0; r<rhos.length; r++){
    var rng = mulberry32(100+r*31);
    var xs=[], ys=[];
    for(var i=0;i<80;i++){
      var z1=boxMuller(rng), z2=boxMuller(rng);
      xs.push(z1);
      ys.push(rhos[r]*z1 + Math.sqrt(1-rhos[r]*rhos[r])*z2);
    }
    corrTraces.push({
      x:xs, y:ys, mode:'markers', name:labels[r],
      marker:{size:5, color:colors[r], opacity:0.7},
      visible: (r===0||r===2||r===4) ? true : 'legendonly'
    });
  }
  
  Plotly.newPlot('plot-ch7-corr', corrTraces, {
    title:{text:'상관계수(ρ)에 따른 산점도 패턴', font:{size:14}},
    xaxis:{title:'종목 A 수익률', range:[-4,4]},
    yaxis:{title:'종목 B 수익률', range:[-4,4], scaleanchor:'x'},
    legend:{x:0.01, y:0.99, font:{size:11}},
    margin:{l:60, r:20, t:50, b:50},
    paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(248,249,250,0.5)'
  }, {responsive:true});
  
  // (2) 상관계수 vs 포트폴리오 변동성
  var rhoRange=[], portVols=[];
  var sigA=0.20, sigB=0.30, wA=0.5, wB=0.5;
  for(var rho=-100; rho<=100; rho++){
    var r = rho/100;
    rhoRange.push(r);
    var covAB = r*sigA*sigB;
    var pVar = wA*wA*sigA*sigA + wB*wB*sigB*sigB + 2*wA*wB*covAB;
    portVols.push(Math.sqrt(pVar)*100);
  }
  
  // 개별 가중평균 변동성 (상한선)
  var simpleAvg = (wA*sigA + wB*sigB)*100;
  
  Plotly.newPlot('plot-ch7-diveff', [
    {x:rhoRange, y:portVols, mode:'lines', name:'포트폴리오 변동성 (50:50)',
     line:{color:'#e74c3c', width:3}, fill:'tozeroy', fillcolor:'rgba(231,76,60,0.1)'},
    {x:[-1,1], y:[simpleAvg,simpleAvg], mode:'lines', name:'단순 가중평균 변동성 ('+simpleAvg.toFixed(1)+'%)',
     line:{color:'#3498db', width:2, dash:'dash'}},
    {x:[0], y:[Math.sqrt(wA*wA*sigA*sigA+wB*wB*sigB*sigB)*100], mode:'markers',
     name:'ρ=0일 때', marker:{size:12, color:'#27ae60', symbol:'star'}},
    {x:[-1], y:[Math.abs(wA*sigA-wB*sigB)*100], mode:'markers',
     name:'ρ=-1 (완벽 헤지)', marker:{size:12, color:'#8e44ad', symbol:'diamond'}}
  ], {
    title:{text:'상관계수(ρ) vs 포트폴리오 변동성 — 분산 투자의 수학적 증명', font:{size:14}},
    xaxis:{title:'상관계수 (ρ)', range:[-1.05,1.05]},
    yaxis:{title:'포트폴리오 변동성 (%)', range:[0,28]},
    legend:{x:0.5, y:0.95, font:{size:11}},
    margin:{l:60, r:20, t:50, b:50},
    paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(248,249,250,0.5)',
    annotations:[{x:0.5,y:simpleAvg+1,text:'↑ 분산 효과 없음 (ρ=1)',showarrow:false,font:{size:10,color:'#3498db'}},
                 {x:-0.5,y:10,text:'분산 효과 ↓',showarrow:true,ax:0,ay:-30,font:{size:11,color:'#e74c3c'}}]
  }, {responsive:true});
})();
</script>

<!-- ── 보충 7.3+ 공분산 행렬 → 포트폴리오 분산 step-by-step ── -->
<div class="def">
<p class="ni"><strong>🔍 보충: 공분산 행렬 → 포트폴리오 분산, 작은 숫자로 한 걸음씩</strong></p>
<p class="ni">공식 \(\sigma_p^2 = \mathbf{w}^T \boldsymbol{\Sigma} \mathbf{w}\)가 실제로 어떻게 계산되는지, 2종목 예제로 한 단계씩 풀어보자.</p>
</div>

<pre><code><span class="cm"># 2종목 포트폴리오: 삼성(60%), SK(40%)</span>
<span class="cm"># 삼성 연간 변동성 = 20%, SK 연간 변동성 = 30%</span>
<span class="cm"># 상관계수 ρ = 0.6</span>

w = np.array([<span class="nu">0.6</span>, <span class="nu">0.4</span>])  <span class="cm"># 비중 벡터</span>

<span class="cm"># 공분산 행렬 구성</span>
<span class="cm"># Σ[0,0] = σ_삼성² = 0.20² = 0.04</span>
<span class="cm"># Σ[1,1] = σ_SK² = 0.30² = 0.09</span>
<span class="cm"># Σ[0,1] = Σ[1,0] = ρ × σ_삼성 × σ_SK = 0.6 × 0.20 × 0.30 = 0.036</span>
Sigma = np.array([
    [<span class="nu">0.04</span>,  <span class="nu">0.036</span>],
    [<span class="nu">0.036</span>, <span class="nu">0.09</span>]
])

<span class="cm"># Step 1: Σ @ w (공분산 행렬 × 비중)</span>
step1 = Sigma @ w
<span class="fn">print</span>(<span class="st">"Step 1: Σ @ w ="</span>, step1)
<span class="cm"># [0.04×0.6 + 0.036×0.4, 0.036×0.6 + 0.09×0.4]</span>
<span class="cm"># = [0.024 + 0.0144, 0.0216 + 0.036]</span>
<span class="cm"># = [0.0384, 0.0576]</span>
<span class="cm"># 의미: 각 종목이 포트폴리오 위험에 기여하는 정도</span>

<span class="cm"># Step 2: w^T @ (Σ @ w) = 포트폴리오 분산</span>
port_var = w @ step1
<span class="fn">print</span>(<span class="st">f"Step 2: w^T @ (Σ@w) = </span>{port_var:.6f}<span class="st">"</span>)
<span class="cm"># = 0.6×0.0384 + 0.4×0.0576 = 0.02304 + 0.02304 = 0.04608</span>

port_vol = np.sqrt(port_var)
<span class="fn">print</span>(<span class="st">f"\n포트폴리오 변동성 = √{port_var:.5f} = </span>{port_vol*100:.2f}<span class="st">%"</span>)

<span class="cm"># 비교: 단순 가중 평균 변동성</span>
simple_avg = <span class="nu">0.6</span> * <span class="nu">0.20</span> + <span class="nu">0.4</span> * <span class="nu">0.30</span>
<span class="fn">print</span>(<span class="st">f"단순 가중 평균 변동성 = </span>{simple_avg*100:.2f}<span class="st">%"</span>)
<span class="fn">print</span>(<span class="st">f"분산 효과 = </span>{(simple_avg - port_vol)*100:.2f}<span class="st">%p 감소!"</span>)
<span class="fn">print</span>(<span class="st">f"\n→ 상관계수가 1보다 작기만 하면 분산 효과가 발생한다."</span>)
<span class="fn">print</span>(<span class="st">f"→ ρ=0.6이면 </span>{(simple_avg - port_vol)*100:.2f}<span class="st">%p, ρ=0이면 더 큰 효과!"</span>)

<span class="cm"># 상관계수별 포트폴리오 변동성 비교</span>
<span class="fn">print</span>(<span class="st">"\n=== 상관계수별 포트폴리오 변동성 ==="</span>)
<span class="kw">for</span> rho <span class="kw">in</span> [<span class="nu">1.0</span>, <span class="nu">0.6</span>, <span class="nu">0.3</span>, <span class="nu">0.0</span>, -<span class="nu">0.3</span>, -<span class="nu">0.6</span>, -<span class="nu">1.0</span>]:
    cov_val = rho * <span class="nu">0.20</span> * <span class="nu">0.30</span>
    S = np.array([[<span class="nu">0.04</span>, cov_val], [cov_val, <span class="nu">0.09</span>]])
    pv = np.sqrt(w @ S @ w)
    <span class="fn">print</span>(<span class="st">f"  ρ={rho:+.1f} → 변동성={pv*100:.2f}%"</span>)
<span class="fn">print</span>(<span class="st">"→ ρ=-1이면 변동성을 0%까지 줄일 수 있다 (완벽한 헤지)!"</span>)</code></pre>

<!-- ═══════════════════════════════════════════ -->
<!-- Ch8: 베이즈 정리 -->
<!-- ═══════════════════════════════════════════ -->
<h2 id="ch8">8. 베이즈 정리</h2>

<!-- 베이즈 업데이트 플로우차트 (CSS) -->
<div style="margin:25px 0;padding:25px;background:linear-gradient(135deg,#f8f9fa,#f5f0fa);border-radius:10px;border:1px solid #ccc">
<p class="ni" style="text-align:center;font-weight:bold;font-size:15px;margin-bottom:18px;color:#2c3e50">🔄 베이즈 업데이트: 시그널이 쌓일수록 확신이 강해진다</p>
<div style="display:flex;align-items:center;justify-content:center;gap:8px;flex-wrap:wrap;font-size:12px">
<div style="background:#fff;border:2px solid #8e44ad;border-radius:8px;padding:12px 16px;text-align:center;min-width:110px">
<div style="font-size:11px;color:#888;margin-bottom:4px">사전확률</div>
<div style="font-size:22px;font-weight:bold;color:#8e44ad">52%</div>
<div style="font-size:11px;color:#555">P(상승)</div>
</div>
<div style="text-align:center">
<div style="font-size:18px;color:#e67e22">→</div>
<div style="font-size:10px;color:#e67e22;font-weight:bold">RSI&lt;30<br>시그널</div>
</div>
<div style="background:#fff;border:2px solid #e67e22;border-radius:8px;padding:12px 16px;text-align:center;min-width:110px">
<div style="font-size:11px;color:#888;margin-bottom:4px">1차 업데이트</div>
<div style="font-size:22px;font-weight:bold;color:#e67e22">76%</div>
<div style="font-size:11px;color:#555">P(상승|RSI)</div>
</div>
<div style="text-align:center">
<div style="font-size:18px;color:#27ae60">→</div>
<div style="font-size:10px;color:#27ae60;font-weight:bold">거래량<br>급증</div>
</div>
<div style="background:#fff;border:2px solid #27ae60;border-radius:8px;padding:12px 16px;text-align:center;min-width:110px">
<div style="font-size:11px;color:#888;margin-bottom:4px">2차 업데이트</div>
<div style="font-size:22px;font-weight:bold;color:#27ae60">91%</div>
<div style="font-size:11px;color:#555">P(상승|RSI,Vol)</div>
</div>
<div style="text-align:center">
<div style="font-size:18px;color:#e74c3c">→</div>
<div style="font-size:10px;color:#e74c3c;font-weight:bold">MACD<br>골든크로스</div>
</div>
<div style="background:#fff;border:2px solid #e74c3c;border-radius:8px;padding:12px 16px;text-align:center;min-width:110px">
<div style="font-size:11px;color:#888;margin-bottom:4px">3차 업데이트</div>
<div style="font-size:22px;font-weight:bold;color:#e74c3c">96%</div>
<div style="font-size:11px;color:#555">P(상승|all)</div>
</div>
</div>
<div style="margin-top:15px;text-align:center;font-size:12px;color:#555;background:#fff;padding:8px;border-radius:6px">
📌 <strong>핵심:</strong> 사후확률(posterior) = 다음 시그널의 사전확률(prior)이 된다 → 순차적 업데이트!
</div>
</div>

<h3>8.1 조건부 확률: "~일 때 ~할 확률"</h3>
<p>조건부 확률은 "어떤 사건이 이미 일어났을 때, 다른 사건이 일어날 확률"이다. 예를 들어 "비가 올 때 우산을 가져올 확률"은 조건부 확률이다.</p>

<p>금융에서의 예: "RSI가 30 이하일 때 다음 날 주가가 오를 확률은?" 이것이 조건부 확률이다.</p>

<div class="eq">\[ P(A|B) = \frac{P(A \cap B)}{P(B)} \]</div>

<p>P(A|B)는 "B가 일어났을 때 A가 일어날 확률"이다. 세로 막대(|)는 "~가 주어졌을 때"로 읽는다.</p>

<h3>8.2 베이즈 정리: 믿음을 업데이트하는 공식</h3>
<p>베이즈 정리는 새로운 증거(데이터)가 주어졌을 때 기존의 믿음(사전확률)을 업데이트하는 방법이다. 퀀트 트레이딩에서 시장 상태를 추정하거나, 시그널의 정확도를 평가할 때 핵심적으로 사용된다.</p>

<!-- ── 보충 8.1+ 베이즈 vs 빈도주의 비교 ── -->
<div class="info">
<p class="ni"><strong>🔍 보충: 베이즈 vs 빈도주의 — 두 가지 세계관</strong></p>
<p class="ni">통계학에는 두 가지 큰 학파가 있다. 이 차이를 이해하면 베이즈 정리의 의미가 더 깊어진다.</p>
<p class="ni"><strong>빈도주의 (Frequentist):</strong> "확률 = 반복 실험에서의 빈도". 동전을 1000번 던져서 앞면이 510번 나오면 P(앞면) ≈ 0.51. 데이터만 보고 판단한다. 사전 지식을 사용하지 않는다.</p>
<p class="ni"><strong>베이즈주의 (Bayesian):</strong> "확률 = 믿음의 정도". 동전을 던지기 전에도 "공정한 동전이면 P(앞면) ≈ 0.5일 것이다"라는 사전 믿음이 있다. 데이터가 들어오면 이 믿음을 업데이트한다.</p>
<p class="ni">금융에서의 차이:</p>
<ul>
<li><strong>빈도주의:</strong> "과거 10년간 RSI&lt;30 후 상승 확률이 65%였다" → 미래에도 65%라고 가정</li>
<li><strong>베이즈주의:</strong> "RSI&lt;30 후 상승 확률이 65%라는 사전 믿음이 있다. 최근 3개월 데이터를 보니 70%였다. 업데이트하면 약 67%다" → 새 데이터에 적응</li>
</ul>
<p class="ni">HFT에서 베이즈가 강력한 이유: 시장 환경은 계속 변한다. 빈도주의는 과거 전체를 동일하게 취급하지만, 베이즈는 최근 데이터에 더 가중치를 줄 수 있다. 시장 레짐(상승장/하락장/횡보장)이 바뀌면 사전확률을 업데이트하여 빠르게 적응할 수 있다.</p>
</div>

<div class="eq">\[ P(A|B) = \frac{P(B|A) \cdot P(A)}{P(B)} \]</div>

<p>각 항의 의미:</p>
<ul>
<li><strong>P(A):</strong> 사전확률 (prior) — 데이터를 보기 전의 믿음</li>
<li><strong>P(B|A):</strong> 우도 (likelihood) — A가 참일 때 B가 관측될 확률</li>
<li><strong>P(B):</strong> 증거 (evidence) — B가 관측될 전체 확률</li>
<li><strong>P(A|B):</strong> 사후확률 (posterior) — 데이터를 본 후 업데이트된 믿음</li>
</ul>

<h3>8.3 트레이딩 시그널 예제</h3>
<p>구체적인 예를 들어보자. RSI(Relative Strength Index)가 30 이하로 떨어지면 "과매도" 시그널이다. 이 시그널이 실제로 얼마나 정확한지 베이즈 정리로 계산해보자.</p>

<pre><code><span class="cm"># 베이즈 정리: RSI 과매도 시그널의 정확도</span>
<span class="cm">#</span>
<span class="cm"># 알려진 정보:</span>
<span class="cm"># P(상승) = 0.52          → 전체 날 중 52%가 상승일</span>
<span class="cm"># P(RSI&lt;30 | 상승) = 0.15 → 상승일 중 15%에서 RSI&lt;30</span>
<span class="cm"># P(RSI&lt;30 | 하락) = 0.05 → 하락일 중 5%에서 RSI&lt;30</span>
<span class="cm">#</span>
<span class="cm"># 구하고 싶은 것:</span>
<span class="cm"># P(상승 | RSI&lt;30) = ?    → RSI&lt;30일 때 상승할 확률</span>

p_up = <span class="nu">0.52</span>
p_down = <span class="nu">1</span> - p_up  <span class="cm"># 0.48</span>
p_rsi_given_up = <span class="nu">0.15</span>
p_rsi_given_down = <span class="nu">0.05</span>

<span class="cm"># P(RSI&lt;30) = P(RSI&lt;30|상승)×P(상승) + P(RSI&lt;30|하락)×P(하락)</span>
p_rsi = p_rsi_given_up * p_up + p_rsi_given_down * p_down
<span class="fn">print</span>(<span class="st">f"P(RSI&lt;30) = </span>{p_rsi:.4f}<span class="st">"</span>)  <span class="cm"># 0.102</span>

<span class="cm"># 베이즈 정리 적용</span>
p_up_given_rsi = (p_rsi_given_up * p_up) / p_rsi
<span class="fn">print</span>(<span class="st">f"\nP(상승 | RSI&lt;30) = </span>{p_up_given_rsi:.1%}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"P(상승)          = </span>{p_up:.1%}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"\n→ RSI&lt;30 시그널이 뜨면 상승 확률이 52%에서 </span>{p_up_given_rsi:.1%}<span class="st">로 상승!"</span>)
<span class="fn">print</span>(<span class="st">f"→ 시그널이 유용하다는 의미"</span>)</code></pre>

<div class="info">
<p class="ni"><strong>베이즈 정리의 트레이딩 활용:</strong></p>
<ul>
<li>여러 시그널을 순차적으로 적용하여 확률을 계속 업데이트할 수 있다</li>
<li>RSI + MACD + 거래량 시그널을 결합하면 더 정확한 예측이 가능</li>
<li>MLAT Ch.10에서 베이지안 ML을 본격적으로 다룬다</li>
<li>HFT에서는 주문 흐름(order flow) 데이터를 베이즈 업데이트로 실시간 분석한다</li>
</ul>
</div>

<!-- ═══ Plotly: Ch.8 베이즈 순차 업데이트 시각화 ═══ -->
<div id="plot-ch8-bayes" style="width:100%;height:460px;margin:25px 0"></div>
<p class="ni" style="font-size:12px;color:#888;text-align:center">🖱️ 호버로 각 단계의 확률 확인. 시그널이 쌓일수록 사후확률이 업데이트됩니다.</p>
<script>
(function(){
  // 베이즈 순차 업데이트: 사전확률 → RSI → 거래량 → MACD
  var prior = 0.52;
  
  // 시그널 1: RSI < 30
  var p_rsi_up = 0.15, p_rsi_down = 0.05;
  var p_rsi = p_rsi_up*prior + p_rsi_down*(1-prior);
  var post1 = (p_rsi_up*prior)/p_rsi;
  
  // 시그널 2: 거래량 급증
  var p_vol_up = 0.30, p_vol_down = 0.10;
  var p_vol = p_vol_up*post1 + p_vol_down*(1-post1);
  var post2 = (p_vol_up*post1)/p_vol;
  
  // 시그널 3: MACD 골든크로스
  var p_macd_up = 0.25, p_macd_down = 0.08;
  var p_macd = p_macd_up*post2 + p_macd_down*(1-post2);
  var post3 = (p_macd_up*post2)/p_macd;
  
  var stages = ['사전확률<br>(기본)', 'RSI < 30<br>시그널 후', '+ 거래량 급증<br>시그널 후', '+ MACD 골든크로스<br>시그널 후'];
  var probs = [prior, post1, post2, post3];
  var probsPct = probs.map(function(p){return (p*100).toFixed(1);});
  var barColors = ['#95a5a6', '#3498db', '#e67e22', '#e74c3c'];
  
  Plotly.newPlot('plot-ch8-bayes', [
    {x: stages, y: probs.map(function(p){return p*100;}),
     type:'bar', marker:{color:barColors, line:{color:'#2c3e50', width:1.5}},
     text: probsPct.map(function(p){return p+'%';}),
     textposition:'outside', textfont:{size:16, color:'#2c3e50'},
     hovertemplate:'%{x}<br>P(상승) = %{y:.1f}%<extra></extra>'},
    // 50% 기준선
    {x:[stages[0], stages[3]], y:[50,50], mode:'lines',
     line:{color:'#aaa', width:2, dash:'dash'}, name:'50% (동전 던지기)', showlegend:true}
  ], {
    title:{text:'베이즈 순차 업데이트: 시그널이 쌓일수록 확신 ↑', font:{size:14}},
    yaxis:{title:'P(상승) %', range:[0,105]},
    xaxis:{title:''},
    showlegend:true, legend:{x:0.6, y:0.3, font:{size:11}},
    margin:{l:60, r:20, t:50, b:80},
    paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(248,249,250,0.5)',
    annotations:[
      {x:stages[0], y:prior*100+6, text:'Prior', showarrow:false, font:{size:10, color:'#95a5a6'}},
      {x:stages[3], y:post3*100+6, text:'Posterior', showarrow:false, font:{size:10, color:'#e74c3c'}}
    ]
  }, {responsive:true});
})();
</script>

<h3>8.4 다중 시그널 결합</h3>
<pre><code><span class="cm"># 시그널 2개를 순차적으로 적용</span>
<span class="cm"># 1단계: RSI&lt;30 → P(상승) 업데이트</span>
prior = p_up  <span class="cm"># 0.52</span>
posterior_1 = p_up_given_rsi  <span class="cm"># ~76.5%</span>

<span class="cm"># 2단계: 거래량 급증 시그널 추가</span>
<span class="cm"># P(거래량급증 | 상승) = 0.30</span>
<span class="cm"># P(거래량급증 | 하락) = 0.10</span>
p_vol_given_up = <span class="nu">0.30</span>
p_vol_given_down = <span class="nu">0.10</span>

<span class="cm"># 이전 사후확률을 새로운 사전확률로 사용</span>
p_vol = p_vol_given_up * posterior_1 + p_vol_given_down * (<span class="nu">1</span> - posterior_1)
posterior_2 = (p_vol_given_up * posterior_1) / p_vol

<span class="fn">print</span>(<span class="st">"=== 순차적 베이즈 업데이트 ==="</span>)
<span class="fn">print</span>(<span class="st">f"사전확률:              </span>{prior:.1%}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"RSI&lt;30 후:            </span>{posterior_1:.1%}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"RSI&lt;30 + 거래량급증 후: </span>{posterior_2:.1%}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"\n→ 시그널이 쌓일수록 확신이 강해진다!"</span>)</code></pre>

<!-- ═══════════════════════════════════════════ -->
<!-- Ch9: 미적분 에센스 -->
<!-- ═══════════════════════════════════════════ -->
<h2 id="ch9">9. 미적분 에센스 (딥러닝 준비)</h2>

<!-- 경사하강법 개념 다이어그램 (CSS) -->
<div style="margin:25px 0;padding:25px;background:linear-gradient(135deg,#f8f9fa,#f0f8f0);border-radius:10px;border:1px solid #ccc">
<p class="ni" style="text-align:center;font-weight:bold;font-size:15px;margin-bottom:18px;color:#2c3e50">⛰️ 경사하강법: 산에서 내려오는 방법</p>
<div style="display:flex;align-items:center;justify-content:center;gap:15px;flex-wrap:wrap;font-size:12px">
<div style="text-align:center;min-width:140px">
<div style="width:140px;height:90px;background:linear-gradient(180deg,#e74c3c 0%,#f39c12 30%,#f1c40f 50%,#2ecc71 80%,#27ae60 100%);border-radius:50% 50% 10px 10px;display:flex;align-items:flex-start;justify-content:center;padding-top:8px;position:relative">
<div style="color:white;font-weight:bold;font-size:11px">높은 손실</div>
<div style="position:absolute;bottom:8px;color:white;font-weight:bold;font-size:11px">낮은 손실 ✓</div>
<div style="position:absolute;top:20px;left:30px;font-size:16px">🏃</div>
<div style="position:absolute;top:35px;left:55px;font-size:10px;color:white">↘</div>
<div style="position:absolute;top:50px;left:75px;font-size:10px;color:white">↘</div>
<div style="position:absolute;bottom:15px;left:85px;font-size:14px">🎯</div>
</div>
<div style="margin-top:6px;font-weight:bold;color:#2c3e50">손실 함수의 지형</div>
</div>
<div style="min-width:200px;max-width:300px">
<div style="background:#fff;padding:12px;border-radius:6px;border:1px solid #ddd">
<div style="font-weight:bold;color:#2c3e50;margin-bottom:8px">경사하강법 3단계:</div>
<div style="display:flex;align-items:center;gap:6px;margin-bottom:6px">
<div style="background:#3498db;color:#fff;width:22px;height:22px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:11px;flex-shrink:0">1</div>
<div style="color:#555">현재 위치에서 <strong>그래디언트</strong> 계산</div>
</div>
<div style="display:flex;align-items:center;gap:6px;margin-bottom:6px">
<div style="background:#e67e22;color:#fff;width:22px;height:22px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:11px;flex-shrink:0">2</div>
<div style="color:#555"><strong>반대 방향</strong>으로 이동 (-∇f)</div>
</div>
<div style="display:flex;align-items:center;gap:6px">
<div style="background:#27ae60;color:#fff;width:22px;height:22px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:11px;flex-shrink:0">3</div>
<div style="color:#555"><strong>학습률(α)</strong>만큼 이동 후 반복</div>
</div>
</div>
<div style="margin-top:8px;background:#fff9e6;padding:8px;border-radius:4px;font-size:11px;color:#555">
<strong>딥러닝 연결:</strong> 신경망의 가중치를 업데이트하는 과정이 바로 경사하강법. 손실함수의 최솟값 = 최적의 모델!
</div>
</div>
</div>
</div>

<h3>9.1 미분이란? — "변화율"</h3>
<p>미분은 "함수가 얼마나 빠르게 변하는가"를 측정한다. 자동차의 속도계를 생각하면 된다. 위치가 시간에 따라 변하는 함수라면, 미분은 그 순간의 속도다.</p>

<p>금융에서 미분의 의미: 주가가 시간에 따라 변하는 함수라면, 미분은 "지금 이 순간 주가가 얼마나 빠르게 오르고 있는가"다. 옵션의 델타(Δ)가 바로 옵션 가격을 기초자산 가격으로 미분한 것이다.</p>

<div class="eq">\[ f'(x) = \lim_{h \to 0} \frac{f(x+h) - f(x)}{h} \]</div>

<pre><code><span class="cm"># 미분의 직관: f(x) = x^2의 미분은 f'(x) = 2x</span>
<span class="cm"># x=3에서의 미분값 = 6 → "x=3에서 x가 1 증가하면 f는 약 6 증가"</span>

<span class="kw">def</span> <span class="fn">f</span>(x):
    <span class="kw">return</span> x**<span class="nu">2</span>

<span class="cm"># 수치 미분 (numerical differentiation)</span>
x = <span class="nu">3.0</span>
h = <span class="nu">1e-7</span>
numerical_deriv = (f(x + h) - f(x - h)) / (<span class="nu">2</span> * h)
<span class="fn">print</span>(<span class="st">f"f(x) = x^2 at x=3"</span>)
<span class="fn">print</span>(<span class="st">f"해석적 미분: 2*3 = 6"</span>)
<span class="fn">print</span>(<span class="st">f"수치적 미분: </span>{numerical_deriv:.6f}<span class="st">"</span>)

<span class="cm"># 시각화: 접선의 기울기 = 미분값</span>
x_range = np.linspace(-<span class="nu">1</span>, <span class="nu">5</span>, <span class="nu">100</span>)
plt.figure(figsize=(<span class="nu">8</span>, <span class="nu">5</span>))
plt.plot(x_range, f(x_range), <span class="st">'b-'</span>, linewidth=<span class="nu">2</span>, label=<span class="st">'f(x) = x²'</span>)

<span class="cm"># x=3에서의 접선</span>
tangent = <span class="nu">6</span> * (x_range - <span class="nu">3</span>) + <span class="nu">9</span>  <span class="cm"># y - f(3) = f'(3)(x - 3)</span>
plt.plot(x_range, tangent, <span class="st">'r--'</span>, linewidth=<span class="nu">1.5</span>, label=<span class="st">"Tangent at x=3 (slope=6)"</span>)
plt.scatter([<span class="nu">3</span>], [<span class="nu">9</span>], color=<span class="st">'red'</span>, s=<span class="nu">100</span>, zorder=<span class="nu">5</span>)

plt.ylim(-<span class="nu">2</span>, <span class="nu">25</span>)
plt.grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)
plt.legend(fontsize=<span class="nu">11</span>)
plt.title(<span class="st">"Derivative = Slope of Tangent Line"</span>, fontsize=<span class="nu">13</span>)
plt.show()</code></pre>

<h3>9.2 편미분과 그래디언트 — 다변수 함수의 미분</h3>
<p>변수가 여러 개인 함수에서는 "각 변수에 대해 따로따로 미분"한다. 이것이 편미분(partial derivative)이다. 모든 편미분을 벡터로 모은 것이 그래디언트(gradient)다.</p>

<div class="eq">\[ \nabla f = \begin{bmatrix} \frac{\partial f}{\partial x_1} \\ \frac{\partial f}{\partial x_2} \\ \vdots \\ \frac{\partial f}{\partial x_n} \end{bmatrix} \quad \text{(그래디언트 벡터)} \]</div>

<p>그래디언트의 직관: 산 위에 서 있다고 하자. 그래디언트는 "가장 가파르게 올라가는 방향"을 가리키는 화살표다. 반대 방향(-∇f)은 "가장 가파르게 내려가는 방향"이다.</p>

<pre><code><span class="cm"># f(x, y) = x^2 + 2y^2</span>
<span class="cm"># ∂f/∂x = 2x,  ∂f/∂y = 4y</span>
<span class="cm"># ∇f = [2x, 4y]</span>

<span class="kw">def</span> <span class="fn">f_2d</span>(x, y):
    <span class="kw">return</span> x**<span class="nu">2</span> + <span class="nu">2</span>*y**<span class="nu">2</span>

<span class="kw">def</span> <span class="fn">gradient_f</span>(x, y):
    <span class="kw">return</span> np.array([<span class="nu">2</span>*x, <span class="nu">4</span>*y])

<span class="cm"># (3, 2)에서의 그래디언트</span>
grad = gradient_f(<span class="nu">3</span>, <span class="nu">2</span>)
<span class="fn">print</span>(<span class="st">f"f(3, 2) = </span>{f_2d(3, 2)}<span class="st">"</span>)       <span class="cm"># 17</span>
<span class="fn">print</span>(<span class="st">f"∇f(3, 2) = </span>{grad}<span class="st">"</span>)              <span class="cm"># [6, 8]</span>
<span class="fn">print</span>(<span class="st">f"→ x 방향으로 6만큼, y 방향으로 8만큼 증가하는 방향이 가장 가파르다"</span>)</code></pre>

<h3>9.3 경사하강법 (Gradient Descent) — 딥러닝의 학습 원리</h3>
<p>경사하강법은 그래디언트의 반대 방향으로 조금씩 이동하여 함수의 최솟값을 찾는 알고리즘이다. 딥러닝의 학습 과정이 바로 이것이다: 손실함수(loss function)를 최소화하기 위해 가중치를 조금씩 업데이트한다.</p>

<div class="eq">\[ \mathbf{x}_{t+1} = \mathbf{x}_t - \alpha \nabla f(\mathbf{x}_t) \]</div>

<p>여기서 α(알파)는 학습률(learning rate)이다. 한 번에 얼마나 크게 이동할지를 결정한다.</p>

<pre><code><span class="cm"># 경사하강법으로 f(x,y) = x^2 + 2y^2의 최솟값 찾기</span>
x, y = <span class="nu">5.0</span>, <span class="nu">5.0</span>  <span class="cm"># 시작점</span>
lr = <span class="nu">0.1</span>           <span class="cm"># 학습률</span>
history = [(x, y, f_2d(x, y))]

<span class="fn">print</span>(<span class="st">"=== 경사하강법 진행 ==="</span>)
<span class="fn">print</span>(<span class="st">f"{'Step':>4} {'x':>8} {'y':>8} {'f(x,y)':>10} {'|grad|':>8}"</span>)
<span class="fn">print</span>(<span class="st">"-"</span> * <span class="nu">42</span>)

<span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(<span class="nu">30</span>):
    grad = gradient_f(x, y)
    x -= lr * grad[<span class="nu">0</span>]
    y -= lr * grad[<span class="nu">1</span>]
    history.append((x, y, f_2d(x, y)))
    
    <span class="kw">if</span> i % <span class="nu">5</span> == <span class="nu">0</span>:
        <span class="fn">print</span>(<span class="st">f"</span>{i:4d} {x:8.4f} {y:8.4f} {f_2d(x,y):10.6f} {np.linalg.norm(grad):8.4f}<span class="st">"</span>)

<span class="fn">print</span>(<span class="st">f"\n최종: x={x:.6f}, y={y:.6f}, f={f_2d(x,y):.8f}"</span>)
<span class="fn">print</span>(<span class="st">f"→ (0, 0)으로 수렴! 이것이 최솟값."</span>)

<span class="cm"># 경사하강법 경로 시각화</span>
fig, (ax1, ax2) = plt.subplots(<span class="nu">1</span>, <span class="nu">2</span>, figsize=(<span class="nu">14</span>, <span class="nu">5</span>))

<span class="cm"># 등고선 + 경로</span>
xx, yy = np.meshgrid(np.linspace(-<span class="nu">6</span>, <span class="nu">6</span>, <span class="nu">100</span>), np.linspace(-<span class="nu">6</span>, <span class="nu">6</span>, <span class="nu">100</span>))
zz = xx**<span class="nu">2</span> + <span class="nu">2</span>*yy**<span class="nu">2</span>
ax1.contour(xx, yy, zz, levels=<span class="nu">20</span>, cmap=<span class="st">'viridis'</span>, alpha=<span class="nu">0.6</span>)

hx = [h[<span class="nu">0</span>] <span class="kw">for</span> h <span class="kw">in</span> history]
hy = [h[<span class="nu">1</span>] <span class="kw">for</span> h <span class="kw">in</span> history]
ax1.plot(hx, hy, <span class="st">'ro-'</span>, markersize=<span class="nu">3</span>, linewidth=<span class="nu">1</span>)
ax1.plot(hx[<span class="nu">0</span>], hy[<span class="nu">0</span>], <span class="st">'r*'</span>, markersize=<span class="nu">15</span>, label=<span class="st">'Start'</span>)
ax1.plot(<span class="nu">0</span>, <span class="nu">0</span>, <span class="st">'g*'</span>, markersize=<span class="nu">15</span>, label=<span class="st">'Minimum'</span>)
ax1.set_title(<span class="st">"Gradient Descent Path"</span>, fontsize=<span class="nu">13</span>)
ax1.legend()
ax1.set_xlabel(<span class="st">"x"</span>); ax1.set_ylabel(<span class="st">"y"</span>)

<span class="cm"># 손실 곡선</span>
losses = [h[<span class="nu">2</span>] <span class="kw">for</span> h <span class="kw">in</span> history]
ax2.plot(losses, <span class="st">'b-'</span>, linewidth=<span class="nu">2</span>)
ax2.set_title(<span class="st">"Loss Curve"</span>, fontsize=<span class="nu">13</span>)
ax2.set_xlabel(<span class="st">"Step"</span>); ax2.set_ylabel(<span class="st">"f(x, y)"</span>)
ax2.set_yscale(<span class="st">'log'</span>)
ax2.grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)
plt.tight_layout()
plt.show()</code></pre>

<div class="warn">
<p class="ni"><strong>학습률(Learning Rate)의 중요성:</strong></p>
<ul>
<li><strong>너무 크면:</strong> 최솟값을 지나쳐서 발산한다 (overshooting)</li>
<li><strong>너무 작으면:</strong> 수렴이 너무 느리다 (학습 시간 낭비)</li>
<li><strong>적절하면:</strong> 빠르고 안정적으로 수렴한다</li>
</ul>
<p class="ni">딥러닝에서 학습률 튜닝은 가장 중요한 하이퍼파라미터 조정 중 하나다. Round 7에서 자세히 다룬다.</p>
</div>

<!-- ── 보충 9.3+ 학습률 비교 시각화 ── -->
<h4>9.3.1 학습률 비교 실험 — 눈으로 확인하기</h4>
<p>학습률이 너무 크면, 너무 작으면, 적절하면 어떻게 되는지 직접 실험해보자.</p>

<pre><code><span class="cm"># 학습률 비교: 너무 큰 / 적절한 / 너무 작은</span>
learning_rates = {
    <span class="st">"너무 큼 (α=0.5)"</span>: <span class="nu">0.5</span>,
    <span class="st">"적절함 (α=0.1)"</span>: <span class="nu">0.1</span>,
    <span class="st">"너무 작음 (α=0.005)"</span>: <span class="nu">0.005</span>
}
colors = [<span class="st">"red"</span>, <span class="st">"green"</span>, <span class="st">"blue"</span>]

fig, axes = plt.subplots(<span class="nu">1</span>, <span class="nu">3</span>, figsize=(<span class="nu">16</span>, <span class="nu">5</span>))

<span class="kw">for</span> idx, (name, lr) <span class="kw">in</span> <span class="fn">enumerate</span>(learning_rates.items()):
    x, y = <span class="nu">5.0</span>, <span class="nu">5.0</span>
    path_x, path_y, losses = [x], [y], [f_2d(x, y)]
    
    <span class="kw">for</span> _ <span class="kw">in</span> <span class="fn">range</span>(<span class="nu">50</span>):
        grad = gradient_f(x, y)
        x -= lr * grad[<span class="nu">0</span>]
        y -= lr * grad[<span class="nu">1</span>]
        path_x.append(x)
        path_y.append(y)
        losses.append(f_2d(x, y))
    
    <span class="cm"># 등고선 + 경로</span>
    xx, yy = np.meshgrid(np.linspace(-<span class="nu">7</span>, <span class="nu">7</span>, <span class="nu">80</span>), np.linspace(-<span class="nu">7</span>, <span class="nu">7</span>, <span class="nu">80</span>))
    zz = xx**<span class="nu">2</span> + <span class="nu">2</span>*yy**<span class="nu">2</span>
    axes[idx].contour(xx, yy, zz, levels=<span class="nu">15</span>, cmap=<span class="st">'viridis'</span>, alpha=<span class="nu">0.5</span>)
    axes[idx].plot(path_x, path_y, <span class="st">'o-'</span>, color=colors[idx], markersize=<span class="nu">3</span>, linewidth=<span class="nu">1</span>)
    axes[idx].plot(path_x[<span class="nu">0</span>], path_y[<span class="nu">0</span>], <span class="st">'*'</span>, color=colors[idx], markersize=<span class="nu">15</span>)
    axes[idx].set_title(name, fontsize=<span class="nu">12</span>, color=colors[idx], fontweight=<span class="st">'bold'</span>)
    axes[idx].set_xlim(-<span class="nu">7</span>, <span class="nu">7</span>); axes[idx].set_ylim(-<span class="nu">7</span>, <span class="nu">7</span>)
    axes[idx].grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)
    
    <span class="cm"># 최종 위치 표시</span>
    axes[idx].annotate(<span class="st">f'최종: ({path_x[-1]:.2f}, {path_y[-1]:.2f})'</span>,
                       xy=(path_x[-<span class="nu">1</span>], path_y[-<span class="nu">1</span>]), fontsize=<span class="nu">8</span>,
                       bbox=<span class="fn">dict</span>(boxstyle=<span class="st">'round'</span>, facecolor=<span class="st">'white'</span>, alpha=<span class="nu">0.8</span>))

plt.suptitle(<span class="st">"학습률(Learning Rate) 비교 — 같은 시작점, 다른 결과"</span>, fontsize=<span class="nu">14</span>)
plt.tight_layout()
plt.show()

<span class="fn">print</span>(<span class="st">"→ 너무 큰 학습률: 발산하거나 진동 (최솟값을 지나침)"</span>)
<span class="fn">print</span>(<span class="st">"→ 적절한 학습률: 빠르고 안정적으로 (0,0)에 수렴"</span>)
<span class="fn">print</span>(<span class="st">"→ 너무 작은 학습률: 수렴은 하지만 50스텝으로는 부족"</span>)</code></pre>

<h3>9.4 체인룰 (Chain Rule) — 딥러닝 역전파의 수학</h3>
<p>합성함수의 미분 규칙이다. 딥러닝의 역전파(backpropagation)가 바로 체인룰의 반복 적용이다.</p>

<div class="eq">\[ \frac{dz}{dx} = \frac{dz}{dy} \cdot \frac{dy}{dx} \]</div>

<p>비유: 환율 변환을 생각하자. 원화→달러 환율과 달러→유로 환율을 알면, 원화→유로 환율은 두 환율을 곱하면 된다. 체인룰도 같은 원리다.</p>

<!-- ── 보충 9.4+ 체인룰이 딥러닝에서 왜 핵심인가 ── -->
<div class="def">
<p class="ni"><strong>🔍 보충: 딥러닝에서 체인룰이 왜 핵심인가 — 간단한 신경망 예제</strong></p>
<p class="ni">딥러닝 신경망은 여러 층(layer)이 쌓인 합성함수다. 입력 x가 1층을 통과하고, 그 결과가 2층을 통과하고, ... 최종 출력이 나온다. 학습이란 "출력의 오차를 줄이기 위해 각 층의 가중치를 조절하는 것"이다.</p>
<p class="ni">문제는: 1층의 가중치가 최종 오차에 얼마나 영향을 미치는지 어떻게 알 수 있는가? 체인룰이 답이다. 오차를 출력층에서 입력층 방향으로 "역전파"하면서, 각 층의 기여도를 체인룰로 계산한다.</p>
</div>

<pre><code><span class="cm"># 가장 간단한 2층 신경망으로 체인룰 이해하기</span>
<span class="cm"># 입력 x → [w1 곱하기] → h → [w2 곱하기] → y_pred → 오차 L</span>
<span class="cm">#</span>
<span class="cm"># h = w1 * x        (1층)</span>
<span class="cm"># y_pred = w2 * h   (2층)</span>
<span class="cm"># L = (y_pred - y_true)^2  (손실함수)</span>
<span class="cm">#</span>
<span class="cm"># 질문: dL/dw1 = ? (w1이 손실에 미치는 영향)</span>
<span class="cm"># 체인룰: dL/dw1 = dL/dy_pred × dy_pred/dh × dh/dw1</span>

x = <span class="nu">2.0</span>       <span class="cm"># 입력</span>
y_true = <span class="nu">10.0</span>  <span class="cm"># 정답</span>
w1 = <span class="nu">1.5</span>       <span class="cm"># 1층 가중치</span>
w2 = <span class="nu">2.0</span>       <span class="cm"># 2층 가중치</span>

<span class="cm"># 순전파 (Forward Pass)</span>
h = w1 * x           <span class="cm"># 3.0</span>
y_pred = w2 * h       <span class="cm"># 6.0</span>
L = (y_pred - y_true)**<span class="nu">2</span>  <span class="cm"># 16.0</span>

<span class="cm"># 역전파 (Backward Pass) — 체인룰!</span>
dL_dy = <span class="nu">2</span> * (y_pred - y_true)  <span class="cm"># dL/dy_pred = -8.0</span>
dy_dh = w2                       <span class="cm"># dy_pred/dh = 2.0</span>
dh_dw1 = x                       <span class="cm"># dh/dw1 = 2.0</span>

<span class="cm"># 체인룰 적용</span>
dL_dw1 = dL_dy * dy_dh * dh_dw1  <span class="cm"># -8 × 2 × 2 = -32</span>
dL_dw2 = dL_dy * h                <span class="cm"># -8 × 3 = -24</span>

<span class="fn">print</span>(<span class="st">"=== 순전파 ==="</span>)
<span class="fn">print</span>(<span class="st">f"h = w1×x = </span>{w1}<span class="st">×</span>{x}<span class="st"> = </span>{h}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"y_pred = w2×h = </span>{w2}<span class="st">×</span>{h}<span class="st"> = </span>{y_pred}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"Loss = (</span>{y_pred}<span class="st">-</span>{y_true}<span class="st">)² = </span>{L}<span class="st">"</span>)

<span class="fn">print</span>(<span class="st">"\n=== 역전파 (체인룰) ==="</span>)
<span class="fn">print</span>(<span class="st">f"dL/dw1 = dL/dy × dy/dh × dh/dw1 = </span>{dL_dy}<span class="st"> × </span>{dy_dh}<span class="st"> × </span>{dh_dw1}<span class="st"> = </span>{dL_dw1}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"dL/dw2 = dL/dy × dy/dw2 = </span>{dL_dy}<span class="st"> × </span>{h}<span class="st"> = </span>{dL_dw2}<span class="st">"</span>)

<span class="cm"># 가중치 업데이트</span>
lr = <span class="nu">0.01</span>
w1_new = w1 - lr * dL_dw1
w2_new = w2 - lr * dL_dw2
<span class="fn">print</span>(<span class="st">f"\n=== 가중치 업데이트 (lr=</span>{lr}<span class="st">) ==="</span>)
<span class="fn">print</span>(<span class="st">f"w1: </span>{w1}<span class="st"> → </span>{w1_new}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"w2: </span>{w2}<span class="st"> → </span>{w2_new}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"→ 이것이 딥러닝 학습의 한 스텝! 이것을 수만 번 반복한다."</span>)</code></pre>

<pre><code><span class="cm"># 예: z = (2x + 3)^2</span>
<span class="cm"># y = 2x + 3 (내부 함수)</span>
<span class="cm"># z = y^2    (외부 함수)</span>
<span class="cm"># dz/dx = dz/dy × dy/dx = 2y × 2 = 4(2x+3)</span>

x = <span class="nu">1.0</span>
<span class="cm"># 해석적 미분: dz/dx = 4(2*1+3) = 20</span>
analytical = <span class="nu">4</span> * (<span class="nu">2</span>*x + <span class="nu">3</span>)

<span class="cm"># 수치적 미분으로 검증</span>
h = <span class="nu">1e-7</span>
z = <span class="kw">lambda</span> x: (<span class="nu">2</span>*x + <span class="nu">3</span>)**<span class="nu">2</span>
numerical = (z(x+h) - z(x-h)) / (<span class="nu">2</span>*h)

<span class="fn">print</span>(<span class="st">f"해석적 미분: </span>{analytical}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"수치적 미분: </span>{numerical:.6f}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"→ 일치! 체인룰이 정확하다."</span>)</code></pre>

<div class="def">
<p class="ni"><strong>Convex Optimization 연결 (Round 8 미리보기):</strong></p>
<p class="ni">\(f(x,y) = x^2 + 2y^2\)는 볼록함수(convex function)다. 볼록함수의 핵심 성질: 지역 최솟값 = 전역 최솟값. 따라서 경사하강법이 반드시 최적해에 수렴한다. 포트폴리오 최적화의 목적함수 \(\mathbf{w}^T\boldsymbol{\Sigma}\mathbf{w}\)도 볼록함수이므로, Convex Optimization으로 전역 최적 포트폴리오를 구할 수 있다.</p>
</div>

<!-- ═══ Plotly: Ch.9 3D 경사하강법 시각화 ═══ -->
<div id="plot-ch9-gd3d" style="width:100%;height:550px;margin:25px 0"></div>
<p class="ni" style="font-size:12px;color:#888;text-align:center">🖱️ 드래그로 3D 회전, 스크롤로 확대. 빨간 경로가 경사하강법으로 최솟값(0,0)을 향해 내려가는 과정입니다.</p>
<script>
(function(){
  // f(x,y) = x^2 + 2y^2 의 3D surface + 경사하강법 경로
  var N = 40;
  var xGrid = [], yGrid = [], zGrid = [];
  for(var i=0; i<N; i++){
    var row_x = [], row_y = [], row_z = [];
    for(var j=0; j<N; j++){
      var x = -5 + 10*i/(N-1);
      var y = -5 + 10*j/(N-1);
      row_x.push(x);
      row_y.push(y);
      row_z.push(x*x + 2*y*y);
    }
    xGrid.push(row_x);
    yGrid.push(row_y);
    zGrid.push(row_z);
  }
  
  // 경사하강법 경로
  var lr = 0.1, steps = 30;
  var gx = [4], gy = [4], gz = [4*4+2*4*4]; // 시작점 (4,4)
  for(var s=0; s<steps; s++){
    var cx = gx[gx.length-1], cy = gy[gy.length-1];
    var dx = 2*cx, dy = 4*cy; // 그래디언트
    var nx = cx - lr*dx, ny = cy - lr*dy;
    gx.push(nx); gy.push(ny); gz.push(nx*nx+2*ny*ny);
  }
  
  Plotly.newPlot('plot-ch9-gd3d', [
    {x:xGrid, y:yGrid, z:zGrid, type:'surface', colorscale:'Viridis',
     opacity:0.7, showscale:false, name:'f(x,y) = x² + 2y²',
     contours:{z:{show:true, usecolormap:true, highlightcolor:'#fff', project:{z:true}}}},
    {x:gx, y:gy, z:gz, type:'scatter3d', mode:'lines+markers',
     name:'경사하강법 경로 (lr=0.1)',
     line:{color:'#e74c3c', width:5},
     marker:{size:4, color:gz.map(function(_,i){return i;}), colorscale:'Reds', showscale:false}},
    {x:[gx[0]], y:[gy[0]], z:[gz[0]], type:'scatter3d', mode:'markers',
     name:'시작점 (4, 4)', marker:{size:8, color:'#e74c3c', symbol:'diamond'}},
    {x:[gx[gx.length-1]], y:[gy[gy.length-1]], z:[gz[gz.length-1]], type:'scatter3d', mode:'markers',
     name:'수렴점 ≈ (0, 0)', marker:{size:8, color:'#27ae60', symbol:'circle'}}
  ], {
    title:{text:'3D 경사하강법: f(x,y) = x² + 2y² 의 최솟값 찾기', font:{size:14}},
    scene:{
      xaxis:{title:'x', range:[-5,5]},
      yaxis:{title:'y', range:[-5,5]},
      zaxis:{title:'f(x,y)', range:[0,50]},
      camera:{eye:{x:1.8, y:1.8, z:1.0}}
    },
    legend:{x:0.01, y:0.99, font:{size:10}},
    margin:{l:0, r:0, t:50, b:0},
    paper_bgcolor:'rgba(0,0,0,0)'
  }, {responsive:true});
})();
</script>

<!-- ═══════════════════════════════════════════ -->
<!-- Ch10: 실전 포트폴리오 분석 -->
<!-- ═══════════════════════════════════════════ -->
<h2 id="ch10">10. 실전: 포트폴리오 공분산 분석 + 히트맵</h2>

<h3>10.1 실제 주식 데이터 수집</h3>
<p>이론을 실전에 적용할 시간이다. 미국 주요 종목 + 금 + 채권으로 구성된 5종목 포트폴리오를 분석한다. 주식(AAPL, MSFT, GOOGL), 금(GLD), 채권(TLT)을 섞어서 자산군 간 상관관계를 관찰한다.</p>

<pre><code><span class="kw">import</span> numpy <span class="kw">as</span> np
<span class="kw">import</span> pandas <span class="kw">as</span> pd
<span class="kw">import</span> yfinance <span class="kw">as</span> yf
<span class="kw">import</span> matplotlib.pyplot <span class="kw">as</span> plt
<span class="kw">import</span> matplotlib
matplotlib.rcParams[<span class="st">'font.family'</span>] = <span class="st">'Malgun Gothic'</span>
matplotlib.rcParams[<span class="st">'axes.unicode_minus'</span>] = <span class="kw">False</span>

<span class="cm"># 5종목 선정</span>
tickers = [<span class="st">"AAPL"</span>, <span class="st">"MSFT"</span>, <span class="st">"GOOGL"</span>, <span class="st">"GLD"</span>, <span class="st">"TLT"</span>]
names = [<span class="st">"Apple"</span>, <span class="st">"Microsoft"</span>, <span class="st">"Google"</span>, <span class="st">"Gold ETF"</span>, <span class="st">"US Bond 20Y"</span>]

<span class="cm"># 2년간 일간 데이터</span>
data = yf.download(tickers, start=<span class="st">"2023-01-01"</span>, end=<span class="st">"2025-01-01"</span>)[<span class="st">"Close"</span>]
data.columns = names

<span class="cm"># 일간 수익률</span>
returns = data.pct_change().dropna()

<span class="fn">print</span>(<span class="st">"=== 데이터 개요 ==="</span>)
<span class="fn">print</span>(<span class="st">f"기간: </span>{returns.index[0].date()}<span class="st"> ~ </span>{returns.index[-1].date()}<span class="st">"</span>)
<span class="fn">print</span>(<span class="st">f"관측치: </span>{len(returns)}<span class="st">일"</span>)
<span class="fn">print</span>(<span class="st">f"\n=== 기초 통계 (일간, %) ==="</span>)
stats_df = pd.DataFrame({
    <span class="st">'평균'</span>: returns.mean() * <span class="nu">100</span>,
    <span class="st">'표준편차'</span>: returns.std() * <span class="nu">100</span>,
    <span class="st">'최소'</span>: returns.min() * <span class="nu">100</span>,
    <span class="st">'최대'</span>: returns.max() * <span class="nu">100</span>,
    <span class="st">'왜도'</span>: returns.skew(),
    <span class="st">'첨도'</span>: returns.kurtosis()
})
<span class="fn">print</span>(stats_df.round(<span class="nu">3</span>))</code></pre>

<h3>10.2 공분산 행렬과 상관행렬</h3>
<pre><code><span class="cm"># 일간 공분산 → 연간화 (×252)</span>
cov_daily = returns.cov()
cov_annual = cov_daily * <span class="nu">252</span>

<span class="cm"># 상관행렬</span>
corr = returns.corr()

<span class="fn">print</span>(<span class="st">"=== 연간 공분산 행렬 ==="</span>)
<span class="fn">print</span>(cov_annual.round(<span class="nu">4</span>))
<span class="fn">print</span>(<span class="st">"\n=== 상관행렬 ==="</span>)
<span class="fn">print</span>(corr.round(<span class="nu">3</span>))</code></pre>

<div class="info">
<p class="ni"><strong>연간화 규칙:</strong></p>
<ul>
<li>일간 공분산 → 연간 공분산: ×252 (거래일 수)</li>
<li>일간 표준편차 → 연간 표준편차: ×√252 ≈ ×15.87</li>
<li>이유: 수익률이 i.i.d.(독립 동일 분포)라는 가정 하에 분산은 시간에 비례하므로</li>
</ul>
</div>

<h3>10.3 상관관계 히트맵</h3>
<pre><code><span class="cm"># 히트맵 시각화</span>
fig, axes = plt.subplots(<span class="nu">1</span>, <span class="nu">2</span>, figsize=(<span class="nu">14</span>, <span class="nu">6</span>))

<span class="cm"># (a) 상관행렬 히트맵</span>
im1 = axes[<span class="nu">0</span>].imshow(corr.values, cmap=<span class="st">'RdBu_r'</span>, vmin=-<span class="nu">1</span>, vmax=<span class="nu">1</span>)
axes[<span class="nu">0</span>].set_xticks(<span class="fn">range</span>(<span class="fn">len</span>(names)))
axes[<span class="nu">0</span>].set_yticks(<span class="fn">range</span>(<span class="fn">len</span>(names)))
axes[<span class="nu">0</span>].set_xticklabels(names, rotation=<span class="nu">45</span>, ha=<span class="st">'right'</span>)
axes[<span class="nu">0</span>].set_yticklabels(names)
<span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(<span class="fn">len</span>(names)):
    <span class="kw">for</span> j <span class="kw">in</span> <span class="fn">range</span>(<span class="fn">len</span>(names)):
        c = <span class="st">'white'</span> <span class="kw">if</span> <span class="fn">abs</span>(corr.values[i,j]) > <span class="nu">0.5</span> <span class="kw">else</span> <span class="st">'black'</span>
        axes[<span class="nu">0</span>].text(j, i, <span class="st">f'</span>{corr.values[i,j]:.2f}<span class="st">'</span>,
                    ha=<span class="st">'center'</span>, va=<span class="st">'center'</span>, color=c, fontsize=<span class="nu">10</span>)
fig.colorbar(im1, ax=axes[<span class="nu">0</span>], shrink=<span class="nu">0.8</span>)
axes[<span class="nu">0</span>].set_title(<span class="st">"(a) Correlation Heatmap"</span>, fontsize=<span class="nu">13</span>)

<span class="cm"># (b) 연간 공분산 히트맵</span>
im2 = axes[<span class="nu">1</span>].imshow(cov_annual.values, cmap=<span class="st">'YlOrRd'</span>)
axes[<span class="nu">1</span>].set_xticks(<span class="fn">range</span>(<span class="fn">len</span>(names)))
axes[<span class="nu">1</span>].set_yticks(<span class="fn">range</span>(<span class="fn">len</span>(names)))
axes[<span class="nu">1</span>].set_xticklabels(names, rotation=<span class="nu">45</span>, ha=<span class="st">'right'</span>)
axes[<span class="nu">1</span>].set_yticklabels(names)
<span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(<span class="fn">len</span>(names)):
    <span class="kw">for</span> j <span class="kw">in</span> <span class="fn">range</span>(<span class="fn">len</span>(names)):
        axes[<span class="nu">1</span>].text(j, i, <span class="st">f'</span>{cov_annual.values[i,j]:.3f}<span class="st">'</span>,
                    ha=<span class="st">'center'</span>, va=<span class="st">'center'</span>, color=<span class="st">'black'</span>, fontsize=<span class="nu">9</span>)
fig.colorbar(im2, ax=axes[<span class="nu">1</span>], shrink=<span class="nu">0.8</span>)
axes[<span class="nu">1</span>].set_title(<span class="st">"(b) Annual Covariance Matrix"</span>, fontsize=<span class="nu">13</span>)

plt.tight_layout()
plt.savefig(<span class="st">"round_02_heatmap.png"</span>, dpi=<span class="nu">150</span>, bbox_inches=<span class="st">'tight'</span>)
plt.show()</code></pre>

<h3>10.4 포트폴리오 비교 분석</h3>
<pre><code><span class="cm"># 3가지 전략 비교</span>
mean_ret = returns.mean().values * <span class="nu">252</span>  <span class="cm"># 연간화</span>

portfolios = {
    <span class="st">'동일비중'</span>:   np.array([<span class="nu">0.2</span>, <span class="nu">0.2</span>, <span class="nu">0.2</span>, <span class="nu">0.2</span>, <span class="nu">0.2</span>]),
    <span class="st">'테크집중'</span>:   np.array([<span class="nu">0.35</span>, <span class="nu">0.35</span>, <span class="nu">0.20</span>, <span class="nu">0.05</span>, <span class="nu">0.05</span>]),
    <span class="st">'방어형'</span>:     np.array([<span class="nu">0.10</span>, <span class="nu">0.10</span>, <span class="nu">0.10</span>, <span class="nu">0.35</span>, <span class="nu">0.35</span>]),
}

<span class="fn">print</span>(<span class="st">"=== 포트폴리오 비교 ==="</span>)
<span class="fn">print</span>(<span class="st">f"{'전략':<10} {'수익률(%)':<12} {'변동성(%)':<12} {'샤프비율':<10}"</span>)
<span class="fn">print</span>(<span class="st">"-"</span> * <span class="nu">44</span>)

<span class="kw">for</span> name, w <span class="kw">in</span> portfolios.items():
    ret = w @ mean_ret * <span class="nu">100</span>
    vol = np.sqrt(w @ cov_annual.values @ w) * <span class="nu">100</span>
    sharpe = ret / vol <span class="kw">if</span> vol > <span class="nu">0</span> <span class="kw">else</span> <span class="nu">0</span>
    <span class="fn">print</span>(<span class="st">f"</span>{name:<span class="nu">10</span>} {ret:<span class="nu">12.2</span>f} {vol:<span class="nu">12.2</span>f} {sharpe:<span class="nu">10.3</span>f}<span class="st">"</span>)

<span class="fn">print</span>(<span class="st">"\n→ 방어형이 변동성이 가장 낮다 (금+채권의 분산 효과)"</span>)
<span class="fn">print</span>(<span class="st">"→ 테크집중이 수익률은 높지만 변동성도 높다"</span>)
<span class="fn">print</span>(<span class="st">"→ 샤프비율로 위험 대비 수익을 비교하자"</span>)</code></pre>

<h3>10.5 효율적 프론티어 (Monte Carlo)</h3>
<pre><code><span class="cm"># 10,000개 랜덤 포트폴리오 시뮬레이션</span>
np.random.seed(<span class="nu">42</span>)
n_portfolios = <span class="nu">10000</span>
results = np.zeros((<span class="nu">3</span>, n_portfolios))

<span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(n_portfolios):
    w = np.random.random(<span class="nu">5</span>)
    w /= w.sum()
    
    ret = w @ mean_ret * <span class="nu">100</span>
    vol = np.sqrt(w @ cov_annual.values @ w) * <span class="nu">100</span>
    sharpe = ret / vol <span class="kw">if</span> vol > <span class="nu">0</span> <span class="kw">else</span> <span class="nu">0</span>
    
    results[<span class="nu">0</span>, i] = vol
    results[<span class="nu">1</span>, i] = ret
    results[<span class="nu">2</span>, i] = sharpe

<span class="cm"># 시각화</span>
plt.figure(figsize=(<span class="nu">10</span>, <span class="nu">7</span>))
scatter = plt.scatter(results[<span class="nu">0</span>], results[<span class="nu">1</span>], c=results[<span class="nu">2</span>],
                      cmap=<span class="st">'viridis'</span>, s=<span class="nu">3</span>, alpha=<span class="nu">0.6</span>)
plt.colorbar(scatter, label=<span class="st">'Sharpe Ratio'</span>)

<span class="cm"># 최대 샤프 포트폴리오</span>
max_idx = results[<span class="nu">2</span>].argmax()
plt.scatter(results[<span class="nu">0</span>, max_idx], results[<span class="nu">1</span>, max_idx],
            marker=<span class="st">'*'</span>, s=<span class="nu">300</span>, c=<span class="st">'red'</span>, label=<span class="st">'Max Sharpe'</span>)

plt.xlabel(<span class="st">'Annual Volatility (%)'</span>, fontsize=<span class="nu">12</span>)
plt.ylabel(<span class="st">'Annual Return (%)'</span>, fontsize=<span class="nu">12</span>)
plt.title(<span class="st">'Efficient Frontier (Monte Carlo, 10K portfolios)'</span>, fontsize=<span class="nu">14</span>)
plt.legend(fontsize=<span class="nu">11</span>)
plt.grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)
plt.tight_layout()
plt.savefig(<span class="st">"round_02_frontier.png"</span>, dpi=<span class="nu">150</span>)
plt.show()

<span class="fn">print</span>(<span class="st">f"최대 샤프 포트폴리오: Return={results[1,max_idx]:.2f}%, Vol={results[0,max_idx]:.2f}%, Sharpe={results[2,max_idx]:.3f}"</span>)</code></pre>

<div class="warn">
<p class="ni"><strong>Monte Carlo vs Convex Optimization:</strong> 여기서는 랜덤 시뮬레이션으로 근사적인 프론티어를 그렸다. 하지만 이 방법은 정확하지 않다 — 10,000개 포트폴리오로는 진짜 최적해를 놓칠 수 있다. Round 8에서 배울 Convex Optimization(<code>cvxpy</code>)은 수학적으로 정확한 최적해를 구한다.</p>
</div>

<!-- ═══ Plotly: Ch.10 효율적 프론티어 + 자산 배치 ═══ -->
<div id="plot-ch10-frontier" style="width:100%;height:520px;margin:25px 0"></div>
<p class="ni" style="font-size:12px;color:#888;text-align:center">🖱️ 호버로 각 포트폴리오의 수익률/변동성/샤프비율 확인. 색상이 밝을수록 샤프비율이 높습니다.</p>
<script>
(function(){
  // 5종목 시뮬레이션 데이터 (실제 데이터 근사)
  // AAPL, MSFT, GOOGL, GLD, TLT
  var meanRet = [0.28, 0.32, 0.25, 0.12, -0.02]; // 연간 수익률
  var vols = [0.24, 0.26, 0.28, 0.15, 0.16]; // 연간 변동성
  var names = ['Apple','Microsoft','Google','Gold ETF','US Bond 20Y'];
  
  // 상관행렬 (근사)
  var corr = [
    [1.0, 0.82, 0.78, 0.05, -0.25],
    [0.82, 1.0, 0.75, 0.08, -0.20],
    [0.78, 0.75, 1.0, 0.03, -0.22],
    [0.05, 0.08, 0.03, 1.0, 0.30],
    [-0.25, -0.20, -0.22, 0.30, 1.0]
  ];
  
  // 공분산 행렬 구성
  var cov = [];
  for(var i=0;i<5;i++){
    cov[i]=[];
    for(var j=0;j<5;j++){
      cov[i][j] = corr[i][j]*vols[i]*vols[j];
    }
  }
  
  // 랜덤 포트폴리오 생성
  function mulberry32(a){return function(){a|=0;a=a+0x6D2B79F5|0;var t=Math.imul(a^a>>>15,1|a);t=t+Math.imul(t^t>>>7,61|t)^t;return((t^t>>>14)>>>0)/4294967296;}}
  var rng = mulberry32(42);
  
  var pVols=[], pRets=[], pSharpes=[];
  var nSim = 5000;
  var maxSharpe = -999, maxIdx = 0;
  var minVol = 999, minVolIdx = 0;
  
  for(var s=0; s<nSim; s++){
    var w = [];
    var wSum = 0;
    for(var i=0;i<5;i++){w.push(rng()); wSum+=w[i];}
    for(var i=0;i<5;i++) w[i]/=wSum;
    
    // 포트폴리오 수익률
    var pRet = 0;
    for(var i=0;i<5;i++) pRet += w[i]*meanRet[i];
    
    // 포트폴리오 변동성
    var pVar = 0;
    for(var i=0;i<5;i++){
      for(var j=0;j<5;j++){
        pVar += w[i]*w[j]*cov[i][j];
      }
    }
    var pVol = Math.sqrt(pVar);
    var sharpe = pRet/pVol;
    
    pVols.push(pVol*100);
    pRets.push(pRet*100);
    pSharpes.push(sharpe);
    
    if(sharpe > maxSharpe){maxSharpe=sharpe; maxIdx=s;}
    if(pVol < minVol){minVol=pVol; minVolIdx=s;}
  }
  
  var traces = [
    {x:pVols, y:pRets, mode:'markers', name:'랜덤 포트폴리오 (5,000개)',
     marker:{size:3, color:pSharpes, colorscale:'Viridis', showscale:true,
             colorbar:{title:'Sharpe', thickness:15, len:0.6}},
     text:pSharpes.map(function(s){return 'Sharpe: '+s.toFixed(3);}),
     hovertemplate:'변동성: %{x:.1f}%<br>수익률: %{y:.1f}%<br>%{text}<extra></extra>'},
    // 최대 샤프
    {x:[pVols[maxIdx]], y:[pRets[maxIdx]], mode:'markers',
     name:'★ Max Sharpe ('+maxSharpe.toFixed(2)+')',
     marker:{size:16, color:'#e74c3c', symbol:'star', line:{color:'white',width:2}}},
    // 최소 변동성
    {x:[pVols[minVolIdx]], y:[pRets[minVolIdx]], mode:'markers',
     name:'◆ Min Volatility',
     marker:{size:14, color:'#3498db', symbol:'diamond', line:{color:'white',width:2}}}
  ];
  
  // 개별 자산 표시
  for(var i=0;i<5;i++){
    traces.push({
      x:[vols[i]*100], y:[meanRet[i]*100], mode:'markers+text',
      name:names[i], text:[names[i]], textposition:'top center',
      marker:{size:10, color:['#ff6b6b','#4ecdc4','#45b7d1','#f9ca24','#6c5ce7'][i],
              line:{color:'#2c3e50',width:1.5}},
      textfont:{size:10}
    });
  }
  
  Plotly.newPlot('plot-ch10-frontier', traces, {
    title:{text:'효율적 프론티어: 5,000개 랜덤 포트폴리오 (AAPL+MSFT+GOOGL+GLD+TLT)', font:{size:13}},
    xaxis:{title:'연간 변동성 (%)', range:[8,30]},
    yaxis:{title:'연간 수익률 (%)', range:[-5,35]},
    legend:{x:0.01, y:0.99, font:{size:10}},
    margin:{l:60, r:20, t:50, b:50},
    paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(248,249,250,0.5)'
  }, {responsive:true});
})();
</script>

<!-- ═══════════════════════════════════════════ -->
<!-- Ch11: Mini Project + Quiz -->
<!-- ═══════════════════════════════════════════ -->
<h2 id="ch11">11. Mini Project + Quiz</h2>

<h3>11.1 종합 프로젝트: 4-Panel 포트폴리오 리포트</h3>
<p>Round 2에서 배운 모든 개념을 하나의 프로젝트로 통합한다. 아래 코드를 실행하면 4개 패널의 종합 분석 리포트가 생성된다.</p>

<pre><code><span class="kw">import</span> numpy <span class="kw">as</span> np
<span class="kw">import</span> pandas <span class="kw">as</span> pd
<span class="kw">import</span> yfinance <span class="kw">as</span> yf
<span class="kw">import</span> matplotlib.pyplot <span class="kw">as</span> plt
<span class="kw">from</span> scipy <span class="kw">import</span> stats

<span class="cm"># ── 데이터 ──</span>
tickers = [<span class="st">"AAPL"</span>, <span class="st">"MSFT"</span>, <span class="st">"GOOGL"</span>, <span class="st">"GLD"</span>, <span class="st">"TLT"</span>]
names = [<span class="st">"Apple"</span>, <span class="st">"MSFT"</span>, <span class="st">"Google"</span>, <span class="st">"Gold"</span>, <span class="st">"Bond20Y"</span>]
data = yf.download(tickers, start=<span class="st">"2023-01-01"</span>, end=<span class="st">"2025-01-01"</span>)[<span class="st">"Close"</span>]
data.columns = names
returns = data.pct_change().dropna()
cov_ann = returns.cov() * <span class="nu">252</span>
corr = returns.corr()

<span class="cm"># ── PCA ──</span>
eigvals, eigvecs = np.linalg.eig(cov_ann.values)
idx = eigvals.argsort()[::-<span class="nu">1</span>]
eigvals = eigvals[idx]
explained = eigvals / eigvals.sum() * <span class="nu">100</span>

<span class="cm"># ── 4-Panel Figure ──</span>
fig, axes = plt.subplots(<span class="nu">2</span>, <span class="nu">2</span>, figsize=(<span class="nu">14</span>, <span class="nu">10</span>))

<span class="cm"># (a) 상관 히트맵</span>
im = axes[<span class="nu">0</span>,<span class="nu">0</span>].imshow(corr.values, cmap=<span class="st">'RdBu_r'</span>, vmin=-<span class="nu">1</span>, vmax=<span class="nu">1</span>)
axes[<span class="nu">0</span>,<span class="nu">0</span>].set_xticks(<span class="fn">range</span>(<span class="nu">5</span>)); axes[<span class="nu">0</span>,<span class="nu">0</span>].set_xticklabels(names, rotation=<span class="nu">45</span>, ha=<span class="st">'right'</span>)
axes[<span class="nu">0</span>,<span class="nu">0</span>].set_yticks(<span class="fn">range</span>(<span class="nu">5</span>)); axes[<span class="nu">0</span>,<span class="nu">0</span>].set_yticklabels(names)
<span class="kw">for</span> i <span class="kw">in</span> <span class="fn">range</span>(<span class="nu">5</span>):
    <span class="kw">for</span> j <span class="kw">in</span> <span class="fn">range</span>(<span class="nu">5</span>):
        c = <span class="st">'white'</span> <span class="kw">if</span> <span class="fn">abs</span>(corr.values[i,j]) > <span class="nu">0.5</span> <span class="kw">else</span> <span class="st">'black'</span>
        axes[<span class="nu">0</span>,<span class="nu">0</span>].text(j, i, <span class="st">f'</span>{corr.values[i,j]:.2f}<span class="st">'</span>, ha=<span class="st">'center'</span>, va=<span class="st">'center'</span>, color=c)
fig.colorbar(im, ax=axes[<span class="nu">0</span>,<span class="nu">0</span>], shrink=<span class="nu">0.8</span>)
axes[<span class="nu">0</span>,<span class="nu">0</span>].set_title(<span class="st">"(a) Correlation Heatmap"</span>)

<span class="cm"># (b) 수익률 분포</span>
<span class="kw">for</span> col <span class="kw">in</span> names[:<span class="nu">3</span>]:
    axes[<span class="nu">0</span>,<span class="nu">1</span>].hist(returns[col]*<span class="nu">100</span>, bins=<span class="nu">50</span>, alpha=<span class="nu">0.5</span>, label=col, density=<span class="kw">True</span>)
axes[<span class="nu">0</span>,<span class="nu">1</span>].set_title(<span class="st">"(b) Return Distributions"</span>)
axes[<span class="nu">0</span>,<span class="nu">1</span>].set_xlabel(<span class="st">"Daily Return (%)"</span>)
axes[<span class="nu">0</span>,<span class="nu">1</span>].legend(fontsize=<span class="nu">9</span>)

<span class="cm"># (c) 누적 수익률</span>
cum = ((<span class="nu">1</span> + returns).cumprod() - <span class="nu">1</span>) * <span class="nu">100</span>
cum.plot(ax=axes[<span class="nu">1</span>,<span class="nu">0</span>], linewidth=<span class="nu">1.2</span>)
axes[<span class="nu">1</span>,<span class="nu">0</span>].set_title(<span class="st">"(c) Cumulative Returns (%)"</span>)
axes[<span class="nu">1</span>,<span class="nu">0</span>].legend(fontsize=<span class="nu">8</span>)
axes[<span class="nu">1</span>,<span class="nu">0</span>].grid(<span class="kw">True</span>, alpha=<span class="nu">0.3</span>)

<span class="cm"># (d) PCA 설명 비율</span>
axes[<span class="nu">1</span>,<span class="nu">1</span>].bar(<span class="fn">range</span>(<span class="nu">1</span>,<span class="nu">6</span>), explained, color=<span class="st">'steelblue'</span>, alpha=<span class="nu">0.8</span>)
axes[<span class="nu">1</span>,<span class="nu">1</span>].plot(<span class="fn">range</span>(<span class="nu">1</span>,<span class="nu">6</span>), np.cumsum(explained), <span class="st">'ro-'</span>, linewidth=<span class="nu">2</span>)
axes[<span class="nu">1</span>,<span class="nu">1</span>].axhline(y=<span class="nu">90</span>, color=<span class="st">'gray'</span>, linestyle=<span class="st">'--'</span>, alpha=<span class="nu">0.5</span>)
axes[<span class="nu">1</span>,<span class="nu">1</span>].set_xlabel(<span class="st">"Principal Component"</span>)
axes[<span class="nu">1</span>,<span class="nu">1</span>].set_ylabel(<span class="st">"Explained Variance (%)"</span>)
axes[<span class="nu">1</span>,<span class="nu">1</span>].set_title(<span class="st">"(d) PCA Explained Variance"</span>)

plt.suptitle(<span class="st">"Round 2 Mini Project: Portfolio Analysis"</span>, fontsize=<span class="nu">15</span>, y=<span class="nu">1.01</span>)
plt.tight_layout()
plt.savefig(<span class="st">"round_02_report.png"</span>, dpi=<span class="nu">150</span>, bbox_inches=<span class="st">'tight'</span>)
plt.show()</code></pre>

<h3>11.2 Quiz</h3>

<div class="def">
<p class="ni"><strong>Q1. [벡터]</strong> 비중 벡터 \(\mathbf{w} = [0.5, 0.3, 0.2]\)와 수익률 벡터 \(\mathbf{r} = [0.02, -0.01, 0.04]\)의 내적을 계산하라. 이 값이 의미하는 것은 무엇인가?</p>
</div>

<div class="def">
<p class="ni"><strong>Q2. [행렬]</strong> 행렬 \(\mathbf{A} = \begin{bmatrix} 4 & 2 \\ 2 & 3 \end{bmatrix}\)의 고유값을 구하라. 이 행렬이 양정치(positive definite)인지 판별하고, 그 이유를 설명하라.</p>
</div>

<div class="def">
<p class="ni"><strong>Q3. [상관계수]</strong> 두 종목의 상관계수가 -0.3이다. 동일 비중(50:50) 포트폴리오를 구성하면 분산 효과가 발생하는가? 수학적으로 설명하라.</p>
</div>

<div class="def">
<p class="ni"><strong>Q4. [경사하강법]</strong> 학습률(learning rate)이 너무 크면 어떤 문제가 발생하는가? 너무 작으면? 각각의 경우를 설명하라.</p>
</div>

<div class="def">
<p class="ni"><strong>Q5. [팻테일]</strong> 실제 금융 수익률의 첨도(kurtosis)가 정규분포보다 높은 이유를 2가지 이상 설명하고, 이것이 리스크 관리에 미치는 영향을 서술하라.</p>
</div>

<div class="def">
<p class="ni"><strong>Q6. [베이즈]</strong> MACD 골든크로스 시그널의 정확도를 베이즈 정리로 계산하라. P(상승)=0.53, P(골든크로스|상승)=0.20, P(골든크로스|하락)=0.08일 때, P(상승|골든크로스)는?</p>
</div>

<div class="def">
<p class="ni"><strong>Q7. [코딩]</strong> yfinance로 한국 ETF 3개(KODEX 200, KODEX 반도체, TIGER 미국S&P500)의 1년 데이터를 다운로드하고, 공분산 행렬과 상관관계 히트맵을 그려라. 어떤 ETF 조합이 분산 효과가 가장 큰가?</p>
</div>

<h3>11.3 Round 2 학습 정리</h3>

<div class="tc">Table 5. Round 2 핵심 개념 요약</div>
<table>
<tr><th>챕터</th><th>핵심 개념</th><th>금융 적용</th><th>교재 연동</th></tr>
<tr><td>1~2. 벡터</td><td>내적, 노름, 단위벡터</td><td>포트폴리오 수익률 = w·r</td><td>MLAT Ch.4</td></tr>
<tr><td>3. 행렬</td><td>특수 행렬, 인덱싱</td><td>수익률 행렬, 공분산 행렬</td><td>MLAT Ch.4</td></tr>
<tr><td>4. 행렬 연산</td><td>전치, 곱, 역행렬</td><td>최소분산 포트폴리오</td><td>MLAT Ch.4</td></tr>
<tr><td>5. 고유값</td><td>고유값 분해, PCA</td><td>주성분 분석, 차원 축소</td><td>MLAT Ch.13</td></tr>
<tr><td>6. 확률분포</td><td>정규, 로그정규, GBM</td><td>수익률 모델링, 시뮬레이션</td><td>MLDSF Ch.4</td></tr>
<tr><td>7. 공분산</td><td>공분산, 상관계수, 행렬</td><td>분산 투자, 포트폴리오 위험</td><td>MLDSF Ch.4</td></tr>
<tr><td>8. 베이즈</td><td>조건부 확률, 사후확률</td><td>시그널 업데이트</td><td>MLAT Ch.10</td></tr>
<tr><td>9. 미적분</td><td>그래디언트, 경사하강법</td><td>딥러닝 역전파, 최적화</td><td>MLAT Ch.17</td></tr>
<tr><td>10. 실전</td><td>히트맵, 효율적 프론티어</td><td>포트폴리오 비교 분석</td><td>MLDSF Ch.5</td></tr>
</table>

<h3>11.4 Next Round Preview</h3>

<div class="info">
<p class="ni"><strong>Round 3: 데이터 수집 + Feature Engineering</strong></p>
<ul>
<li>yfinance, pandas-datareader로 실시간 금융 데이터 수집 파이프라인 구축</li>
<li>기술적 지표 (RSI, MACD, Bollinger Bands) 직접 구현</li>
<li>Feature Engineering: 수익률, 변동성, 모멘텀 팩터 생성</li>
<li>데이터 전처리: 결측치 처리, 이상치 탐지, 정규화/표준화</li>
<li>Zipline/Backtrader 백테스팅 프레임워크 입문</li>
<li><strong>피드백 세션 (R3):</strong> R1~R3 전체 복습 + 학습 방향 조정</li>
</ul>
<p class="ni"><strong>교재:</strong> MLAT Ch.2~4 / MLDSF Ch.3 / 파라활 Ch.10~12 / 두잇알고 Ch.3~5</p>
</div>

</div><!-- paper-content -->
</div><!-- container -->
</div><!-- main-wrapper -->

</body>
</html>
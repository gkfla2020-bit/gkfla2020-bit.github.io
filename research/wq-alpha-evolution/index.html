---
layout: null
permalink: /research/wq-alpha-evolution/
title: "WQ BRAIN Alpha Evolution"
---
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WQ BRAIN Alpha Auto-Discovery | Ha Rim Jung</title>
    
    <meta property="og:type" content="article">
    <meta property="og:title" content="Genetic Algorithm-Based Alpha Auto-Discovery on WorldQuant BRAIN">
    <meta property="og:description" content="7-Round Island Model GP with SHADE, MAP-Elites, ε-Lexicase Selection for automated alpha generation.">
    <meta property="og:url" content="https://gkfla2020-bit.github.io/research/wq-alpha-evolution/">
    <meta property="og:image" content="https://gkfla2020-bit.github.io/assets/og-card.png">
    <meta property="og:image:secure_url" content="https://gkfla2020-bit.github.io/assets/og-card.png">
    <meta property="og:image:type" content="image/png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="Ha Rim Jung">
    <meta property="og:locale" content="ko_KR">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="WQ BRAIN Alpha Auto-Discovery System">
    <meta name="twitter:description" content="Island Model GP + SHADE + MAP-Elites + ε-Lexicase for BRAIN alpha search">
    <meta name="twitter:image" content="https://gkfla2020-bit.github.io/assets/og-card.png">
    <meta property="kakao:image" content="https://gkfla2020-bit.github.io/assets/og-card.png">
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-83LKVW7412"></script>
    <script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','G-83LKVW7412');</script>
    <script>
        window.MathJax = {
            tex: { inlineMath: [['\\(','\\)']], displayMath: [['\\[','\\]']] },
            svg: { fontCache: 'global' }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" async></script>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;500&family=Space+Mono:wght@400&family=Inter:wght@300;400&family=Nanum+Myeongjo:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Inter', sans-serif; background: #fafaf8; color: #1a1a1a; line-height: 1.7; overflow-x: hidden; }
        .formula-bg{position:fixed;inset:0;pointer-events:none;z-index:0;overflow:hidden}
        .f{position:absolute;font-family:'Space Mono',monospace;white-space:nowrap;will-change:transform;transition:transform .3s ease-out}
        .sidebar{position:fixed;left:0;top:0;width:280px;height:100vh;background:rgba(255,255,255,.97);backdrop-filter:blur(10px);border-right:1px solid rgba(0,0,0,.06);padding:40px 30px;z-index:100;overflow-y:auto;display:flex;flex-direction:column}
        .sidebar-profile{text-align:center;margin-bottom:35px;padding-bottom:30px;border-bottom:1px solid rgba(0,0,0,.08)}
        .profile-photo{width:120px;height:120px;border-radius:50%;object-fit:cover;margin-bottom:18px;border:3px solid #f0f0f0;background:#e8e8e8}
        .profile-name{font-family:'Cormorant Garamond',serif;font-size:1.5rem;font-weight:500;color:#1a1a1a;margin-bottom:6px;letter-spacing:.03em}
        .profile-title{font-size:.75rem;color:#888;letter-spacing:.08em;text-transform:uppercase;margin-bottom:12px}
        .profile-bio{font-size:.82rem;color:#666;line-height:1.6;margin-bottom:15px}
        .profile-links{display:flex;justify-content:center;gap:15px}
        .profile-links a{font-size:.7rem;color:#999;text-decoration:none;letter-spacing:.05em;transition:color .2s}
        .profile-links a:hover{color:#0080c6}
        .sidebar-nav{flex:1}
        .nav-section{margin-bottom:25px}
        .nav-section-title{font-size:.65rem;font-weight:600;color:#aaa;letter-spacing:.15em;text-transform:uppercase;margin-bottom:12px}
        .nav-list{list-style:none}
        .nav-list li{margin-bottom:8px}
        .nav-list a{font-size:.85rem;color:#555;text-decoration:none;transition:all .2s;display:flex;align-items:center;gap:8px;padding:6px 0}
        .nav-list a:hover{color:#0080c6;padding-left:5px}
        .nav-list a.active{color:#0080c6;font-weight:500}
        .sidebar-footer{padding-top:20px;border-top:1px solid rgba(0,0,0,.06);font-size:.7rem;color:#aaa;text-align:center}
        .nav-toggle{display:none}
        .main-wrapper{margin-left:280px;margin-right:260px;min-height:100vh}
        .container{position:relative;z-index:1;max-width:900px;margin:0 auto;padding:50px 40px 80px}
        .right-sidebar{position:fixed;right:0;top:0;width:260px;height:100vh;background:rgba(255,255,255,.97);backdrop-filter:blur(10px);border-left:1px solid rgba(0,0,0,.06);padding:30px 20px;z-index:100;overflow-y:auto}
        .widget-title{font-size:.65rem;font-weight:600;color:#aaa;letter-spacing:.15em;text-transform:uppercase;margin-bottom:15px}
        .market-item{display:flex;justify-content:space-between;align-items:center;padding:12px 0;border-bottom:1px solid rgba(0,0,0,.05)}
        .market-item:last-child{border-bottom:none}
        .market-name{font-size:.75rem;color:#666}
        .market-value{font-family:'Space Mono',monospace;font-size:.85rem;font-weight:500;color:#1a1a1a}
        .market-change{font-family:'Space Mono',monospace;font-size:.7rem;margin-left:8px}
        .market-change.up{color:#16a34a}
        .market-change.down{color:#dc2626}
        .widget-section{margin-bottom:30px}
        .widget-update{font-size:.6rem;color:#bbb;text-align:center;margin-top:10px}
        .market-group{background:rgba(0,0,0,.02);padding:15px;margin-bottom:15px;border-left:2px solid #e0e0e0}
        .market-group-title{font-size:.6rem;color:#999;letter-spacing:.1em;text-transform:uppercase;margin-bottom:10px}
        
        .paper-content{font-family:'Times New Roman','Nanum Myeongjo',serif;line-height:1.9;background:#fff;padding:45px 50px;border-radius:8px;box-shadow:0 2px 20px rgba(0,0,0,.05);font-size:15px}
        .paper-header{text-align:center;margin-bottom:40px;padding-bottom:30px;border-bottom:2px solid #333}
        .paper-category{font-size:11px;font-weight:600;letter-spacing:2px;text-transform:uppercase;color:#0080c6;margin-bottom:15px}
        .paper-title{font-family:'Cormorant Garamond','Nanum Myeongjo',serif;font-size:26px;font-weight:700;margin-bottom:12px;line-height:1.35}
        .paper-subtitle{font-family:'Cormorant Garamond',serif;font-size:15px;color:#666;font-style:italic;margin-bottom:15px}
        .paper-author{font-size:14px;color:#444;margin-bottom:5px}
        .paper-date{font-size:12px;color:#999}
        .abstract{background:linear-gradient(135deg,#f8f9fa,#edf2f4);border-left:4px solid #1d3557;padding:25px 30px;margin:30px 0;border-radius:0 6px 6px 0;font-size:13.5px;line-height:1.8;color:#333}
        .abstract-title{font-family:'Inter',sans-serif;font-size:11px;font-weight:600;letter-spacing:2px;text-transform:uppercase;color:#1d3557;margin-bottom:10px}
        .keywords{background:#fafafa;padding:12px 20px;border-radius:6px;font-size:13px;color:#555;margin-bottom:30px}
        .keywords strong{color:#1d3557}
        h2{font-family:'Cormorant Garamond','Nanum Myeongjo',serif;font-size:1.5em;font-weight:700;color:#1d3557;margin:40px 0 15px;padding-bottom:8px;border-bottom:1px solid #e0e0e0}
        h3{font-family:'Cormorant Garamond','Nanum Myeongjo',serif;font-size:1.2em;font-weight:600;color:#2c3e50;margin:30px 0 12px}
        h4{font-size:1.05em;color:#2c3e50;margin:20px 0 10px}
        p{text-align:justify;text-indent:2em;margin-bottom:12px}
        p.no-indent{text-indent:0}
        table{width:100%;border-collapse:collapse;margin:20px 0;font-size:12.5px}
        table caption{font-weight:700;text-align:left;margin-bottom:8px;font-size:13.5px;color:#1d3557}
        thead th{background:#1d3557;color:white;padding:10px;font-weight:600;font-size:11.5px;text-align:center;white-space:nowrap}
        tbody td{padding:7px 10px;border-bottom:1px solid #eee;text-align:center}
        tbody tr:nth-child(even){background:#fafafa}
        tbody tr:hover{background:#f0f4ff}
        td.left{text-align:left}
        .glossary-table td:first-child{text-align:left;font-weight:600;white-space:nowrap;font-size:11px;width:180px}
        .glossary-table td:last-child{text-align:left;font-size:11px;line-height:1.6}
        .sig{color:#e63946;font-weight:700}
        .note{font-size:11.5px;color:#777;margin-top:5px;font-style:italic}
        pre{background:#0f172a;color:#e2e8f0;padding:20px 22px;border-radius:8px;overflow-x:auto;font-family:'Space Mono',monospace;font-size:12px;line-height:1.65;margin:18px 0}
        code{background:#f1f5f9;padding:2px 6px;border-radius:3px;font-family:'Space Mono',monospace;font-size:12px;color:#1d3557}
        pre code{background:none;padding:0;color:inherit}
        .kw{color:#c084fc} .fn{color:#67e8f9} .st{color:#86efac} .cm{color:#64748b;font-style:italic} .nu{color:#fbbf24}
        .math-block{margin:15px 0;padding:10px 0;text-align:center;overflow-x:auto}
        .section-divider{text-align:center;margin:40px 0;color:#ccc;font-size:18px;letter-spacing:10px}
        .references{font-size:12.5px;line-height:1.7}
        .references p{text-indent:-2em;padding-left:2em;margin-bottom:6px}
        @media(max-width:1024px){
            .sidebar{width:100%;height:auto;position:relative;border-right:none;border-bottom:1px solid rgba(0,0,0,.08);padding:25px 20px}
            .sidebar-profile{margin-bottom:20px;padding-bottom:20px;display:flex;align-items:center;gap:15px;text-align:left}
            .profile-photo{width:60px;height:60px;margin-bottom:0}
            .profile-bio{display:none}
            .nav-section{display:inline-block;margin-right:20px;margin-bottom:10px}
            .nav-list{display:flex;gap:12px;flex-wrap:wrap}
            .nav-list li{margin-bottom:0}
            .sidebar-footer{display:none}
            .nav-extra{display:none}.sidebar-nav.expanded .nav-extra{display:inline-block}
            .nav-toggle{display:inline-block;padding:8px 14px;background:none;border:1px solid #ddd;border-radius:6px;font-size:.75rem;color:#888;cursor:pointer;letter-spacing:.05em;margin-bottom:10px;font-family:'Inter',sans-serif}
            .main-wrapper{margin-left:0;margin-right:0}
            .right-sidebar{display:none}
            .container{padding:20px 0}
            .paper-content{padding:25px 18px;border-radius:0;box-shadow:none;font-size:14px}
            .paper-title{font-size:20px}
            h2{font-size:1.3em;margin:30px 0 12px}
            h3{font-size:1.1em}
            p{text-indent:1.5em;text-align:left;font-size:14px}
            table{font-size:10px;display:block;overflow-x:auto;-webkit-overflow-scrolling:touch}
            thead th,tbody td{padding:6px 4px;white-space:nowrap}
            .abstract{padding:16px;margin:20px 0}
            .references p{font-size:11px}
        }
        @media print{.sidebar{display:none}.right-sidebar{display:none}.main-wrapper{margin:0}.paper-content{box-shadow:none;padding:15mm 20mm}}
        .breadcrumb{font-size:.7rem;color:#999;letter-spacing:.06em;margin-bottom:30px;padding-bottom:15px;border-bottom:1px solid rgba(0,0,0,.05)}
        .breadcrumb a{color:#888;text-decoration:none;transition:color .2s}
        .breadcrumb a:hover{color:#0080c6}
        .bc-sep{margin:0 6px;color:#ccc}
        .bc-current{color:#555;font-weight:500}

        /* Architecture Diagram */
        .arch-diagram{margin:30px 0 35px;padding:30px 24px 24px;background:#fafbfd;border:1px solid #e0e4ea;border-radius:8px}
        .arch-caption{font-family:'Inter',sans-serif;font-size:12px;font-weight:600;color:#1d3557;text-align:center;margin-bottom:24px;letter-spacing:.5px}
        .arch-layer{margin-bottom:4px}
        .arch-layer-label{font-family:'Inter',sans-serif;font-size:9px;font-weight:600;color:#999;letter-spacing:1.5px;text-transform:uppercase;margin-bottom:8px;padding-left:2px}
        .arch-nodes{display:flex;gap:10px;flex-wrap:wrap;justify-content:center}
        .arch-nodes-5{display:grid;grid-template-columns:repeat(5,1fr);gap:8px}
        .arch-nodes-4{display:grid;grid-template-columns:repeat(4,1fr);gap:8px}
        .arch-node{padding:10px 12px;border-radius:6px;border:1px solid;transition:transform .15s,box-shadow .15s;cursor:default}
        .arch-node:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,.08)}
        .arch-node-title{font-family:'Space Mono',monospace;font-size:11px;font-weight:700;margin-bottom:3px}
        .arch-node-desc{font-family:'Inter',sans-serif;font-size:9.5px;color:#666;line-height:1.45}
        .arch-node-classes{display:flex;flex-wrap:wrap;gap:3px;margin-top:6px}
        .arch-class{font-family:'Space Mono',monospace;font-size:8px;background:rgba(29,53,87,.08);color:#1d3557;padding:1px 5px;border-radius:3px}
        .arch-node-hook{font-family:'Space Mono',monospace;font-size:8px;color:#457b9d;margin-top:5px;padding-top:4px;border-top:1px dashed #d0d8e0}
        .node-entry{background:#f0f7ff;border-color:#a8c8e8;}.node-entry .arch-node-title{color:#2c5282}
        .node-core{background:#fff8f0;border-color:#e8c8a0;}.node-core .arch-node-title{color:#744210}
        .node-module{background:#f0fff4;border-color:#a8e8b8;}.node-module .arch-node-title{color:#22543d}
        .node-v4{background:#faf0ff;border-color:#c8a8e8;}.node-v4 .arch-node-title{color:#553c7b}
        .node-ext{background:#fff0f0;border-color:#e8a8a8;}.node-ext .arch-node-title{color:#9b2c2c}
        .arch-arrow-down{text-align:center;margin:6px 0}
        .arch-arrow-fan{text-align:center;margin:4px 0;overflow:hidden}
        .arch-legend{margin-top:24px;padding-top:16px;border-top:1px solid #e0e4ea}
        .arch-legend-title{font-family:'Inter',sans-serif;font-size:9px;font-weight:600;color:#999;letter-spacing:1.5px;text-transform:uppercase;margin-bottom:8px}
        .arch-legend-items{display:flex;flex-wrap:wrap;gap:14px}
        .arch-legend-item{display:flex;align-items:center;gap:5px;font-family:'Inter',sans-serif;font-size:9.5px;color:#666}
        .arch-legend-line{display:inline-block;width:18px;height:2px;border-radius:1px}
        .arch-legend-dot{display:inline-block;width:10px;height:10px;border-radius:3px;border:1px solid}
        .arch-pipeline{margin-top:20px;padding-top:16px;border-top:1px solid #e0e4ea}
        .arch-pipeline-title{font-family:'Inter',sans-serif;font-size:9px;font-weight:600;color:#999;letter-spacing:1.5px;text-transform:uppercase;margin-bottom:10px}
        .arch-pipeline-flow{display:flex;flex-wrap:wrap;align-items:center;gap:4px}
        .arch-pipe-step{font-family:'Space Mono',monospace;font-size:9px;padding:4px 8px;border-radius:4px;border:1px solid;white-space:nowrap}
        .arch-pipe-arrow{font-size:11px;color:#999;line-height:1}
        .pipe-entry{background:#f0f7ff;border-color:#a8c8e8;color:#2c5282}
        .pipe-core{background:#fff8f0;border-color:#e8c8a0;color:#744210}
        .pipe-module{background:#f0fff4;border-color:#a8e8b8;color:#22543d}
        .pipe-v4{background:#faf0ff;border-color:#c8a8e8;color:#553c7b}
        .pipe-ext{background:#fff0f0;border-color:#e8a8a8;color:#9b2c2c}
        @media(max-width:1024px){
            .arch-nodes-5,.arch-nodes-4{grid-template-columns:repeat(2,1fr)}
            .arch-arrow-fan{display:none}
            .arch-pipeline-flow{gap:3px}
            .arch-pipe-step{font-size:8px;padding:3px 5px}
            .arch-pipe-arrow{font-size:9px}
            .arch-diagram{padding:16px 12px}
        }

        /* Round Logic Diagrams */
        .round-diagrams{margin:30px 0 20px;padding:0}
        .round-diagram-caption{font-family:'Inter',sans-serif;font-size:12px;font-weight:600;color:#1d3557;text-align:center;margin-bottom:20px;letter-spacing:.5px}
        .round-flow-header{margin-bottom:16px}
        .round-flow-legend{display:flex;flex-wrap:wrap;justify-content:center;gap:12px;font-family:'Inter',sans-serif;font-size:9px;color:#777}
        .rfl-item{display:flex;align-items:center;gap:4px}
        .rfl-line{display:inline-block;width:16px;height:2px;border-radius:1px}
        .rfl-solid{background:#1d3557}
        .rfl-dash{background:repeating-linear-gradient(90deg,#999 0,#999 4px,transparent 4px,transparent 7px);height:2px;width:16px}
        .rfl-dot{display:inline-block;width:9px;height:9px;border-radius:3px}
        .rfl-dot.rfl-init{background:#e8f0fe;border:1px solid #a0b8d8}
        .rfl-dot.rfl-evolve{background:#fff3e0;border:1px solid #e0c090}
        .rfl-dot.rfl-eval{background:#e8f5e9;border:1px solid #a0d0a8}
        .rfl-dot.rfl-output{background:#fce4ec;border:1px solid #e0a0b0}
        .rfl-dot.rfl-special{background:#f3e5f5;border:1px solid #c0a0d0}
        .round-card{background:#fff;border:1px solid #e0e4ea;border-radius:8px;margin-bottom:4px;overflow:hidden;transition:box-shadow .2s}
        .round-card:hover{box-shadow:0 3px 12px rgba(0,0,0,.06)}
        .round-card-header{display:flex;align-items:center;gap:12px;padding:10px 16px}
        .round-num{font-family:'Space Mono',monospace;font-size:12px;font-weight:700;color:#fff;background:#1d3557;width:28px;height:28px;border-radius:50%;display:flex;align-items:center;justify-content:center;flex-shrink:0}
        .round-name{font-family:'Cormorant Garamond','Nanum Myeongjo',serif;font-size:15px;font-weight:600;color:#1d3557}
        .round-params{font-family:'Space Mono',monospace;font-size:9.5px;color:#888;margin-left:auto}
        .r1-header{background:linear-gradient(135deg,#f8f9ff,#edf2ff);border-bottom:2px solid #a0b8d8}
        .r2-header{background:linear-gradient(135deg,#fff8f0,#fef3e8);border-bottom:2px solid #e0c090}
        .r3-header{background:linear-gradient(135deg,#f0fff4,#e8f8ec);border-bottom:2px solid #80c090}
        .r4-header{background:linear-gradient(135deg,#fff0f5,#fce8f0);border-bottom:2px solid #d090a0}
        .r5-header{background:linear-gradient(135deg,#f0f8ff,#e0f0ff);border-bottom:2px solid #70a0d0}
        .r6-header{background:linear-gradient(135deg,#faf0ff,#f0e8ff);border-bottom:2px solid #a080c0}
        .r7-header{background:linear-gradient(135deg,#fffff0,#fefce8);border-bottom:2px solid #c0b060}
        .rf-header{background:linear-gradient(135deg,#f0f8ff,#e8f0fa);border-bottom:2px solid #457b9d}
        .round-card-body{padding:14px 16px}
        .round-flow{display:flex;align-items:stretch;gap:6px;flex-wrap:nowrap;overflow-x:auto}
        .rf-step{flex:1;min-width:100px;padding:8px 10px;border-radius:6px;border:1px solid;font-family:'Inter',sans-serif}
        .rf-step.rfl-init{background:#f0f4ff;border-color:#c0d0e8}
        .rf-step.rfl-evolve{background:#fff8f0;border-color:#e8d8c0}
        .rf-step.rfl-eval{background:#f0faf2;border-color:#b0d8b8}
        .rf-step.rfl-output{background:#fef0f4;border-color:#e0b8c0}
        .rf-step.rfl-special{background:#f8f0ff;border-color:#c8b0e0}
        .rf-title{font-size:10px;font-weight:600;color:#1d3557;margin-bottom:4px}
        .rf-detail{font-size:8.5px;color:#666;line-height:1.5}
        .rf-arrow{display:flex;align-items:center;font-size:14px;color:#bbb;flex-shrink:0}
        .round-note{font-family:'Inter',sans-serif;font-size:9px;color:#999;margin-top:10px;padding-top:8px;border-top:1px dashed #e8e8e8;font-style:italic}
        .round-transfer{text-align:center;margin:2px 0}
        @media(max-width:1024px){
            .round-flow{flex-wrap:wrap;gap:4px}
            .rf-step{min-width:80px;flex:1 1 45%}
            .rf-arrow{display:none}
            .round-card-header{flex-wrap:wrap;gap:6px}
            .round-params{margin-left:0;width:100%}
            .round-transfer svg{height:24px}
        }
    </style>
</head>
<body>
<img src="/assets/og-card.png" alt="" style="position:absolute;width:1px;height:1px;opacity:0;pointer-events:none;" aria-hidden="true">
<div class="formula-bg" id="formulaBg"></div>

{% include sidebar.html %}
{% include market-widget.html %}

<div class="main-wrapper">
<div class="container">
{% include breadcrumb.html %}
<div class="paper-content">

<div class="paper-header">
    <div class="paper-category">Quantitative Finance Research</div>
    <h1 class="paper-title">WorldQuant BRAIN Alpha Auto-Discovery System</h1>
    <div class="paper-subtitle">7-Round Genetic Algorithm with Island Model, ε-Lexicase Selection, SHADE, MAP-Elites, and UCB1 Adaptive Operator Selection</div>
    <div class="paper-author">Ha Rim Jung</div>
    <div class="paper-date">February 14, 2026</div>
</div>

<div class="abstract">
    <div class="abstract-title">Abstract</div>
    본 글은 WorldQuant BRAIN 플랫폼의 International Quant Championship(IQC) 및 컨설턴트 프로그램을 위한 완전 자동 알파 탐색 시스템의 설계와 구현을 기술한다. 시스템은 7라운드 진화 전략을 통해 FastExpression 및 Regular Expression 기반 알파 수식을 자동 생성·시뮬레이션·제출하며, Island Model(4섬, Ring Topology 이주), ε-Lexicase Selection, SHADE 적응형 DE 파라미터 제어(H=15, Lehmer Mean), MAP-Elites 품질-다양성 아카이브(10×5 그리드), UCB1 기반 적응형 연산자 선택(10개 연산자) 등 최신 진화 연산 기법을 통합한다. 영속적 체크포인트 시스템을 도입하여 크래시 복구 및 누적 진화를 지원하고, 멀티라인 Regular Expression, 확장 데이터셋, 36개 복합 전략 시드, Self-Correlation 회피 전략 등을 포함한다.
</div>

<div class="keywords">
    <strong>Keywords:</strong> Genetic Programming, Alpha Discovery, WorldQuant BRAIN, Island Model, SHADE, MAP-Elites, ε-Lexicase Selection, UCB1, Adaptive Operator Selection, Regular Expression
</div>

<!-- 1. System Architecture -->
<h2>1. 시스템 아키텍처</h2>

<p>시스템은 11개의 핵심 모듈과 1개의 외부 라이브러리로 구성된다. 각 모듈은 단일 책임 원칙에 따라 분리되어 있으며, <code>EvolutionEngine</code>이 중앙 오케스트레이터 역할을 한다. 아래 접기/펼치기 다이어그램은 전체 시스템의 모듈 의존성, 실행 파이프라인, 세대 루프, 알고리즘 상세, 7라운드 전략, 데이터 플로우를 포함하는 12개 섹션의 종합 구조도이다.</p>

<!-- Full System Architecture (collapsible) -->
<details style="margin:25px 0 30px;border:1px solid #e0e4ea;border-radius:8px;background:#fafbfd;">
<summary style="padding:14px 20px;cursor:pointer;font-family:'Inter',sans-serif;font-size:13px;font-weight:600;color:#1d3557;letter-spacing:.3px;list-style:none;display:flex;align-items:center;gap:8px;">
<span style="font-size:16px;transition:transform .2s;">&#9654;</span>
Figure 1: 전체 시스템 상세 구조도 (Full System Architecture Diagram)
</summary>
<div style="padding:0 16px 16px;">
<iframe src="/architecture-diagram.html" style="width:100%;height:85vh;border:none;border-top:1px solid #e0e4ea;" loading="lazy"></iframe>
<p class="note" style="text-align:center;margin-top:8px;">12개 섹션: 모듈 의존성, 실행 파이프라인, 세대 루프, 유전 연산자, Island 토폴로지, 7라운드 전략, 핵심 알고리즘(SHADE/MAP-Elites/NSGA-II/UCB1/ε-Lexicase), Surrogate/Pattern Learner, Individual 라이프사이클, 체크포인트, 탐색 공간, 전체 데이터 플로우</p>
</div>
</details>
<script>document.querySelectorAll('details').forEach(d=>{d.addEventListener('toggle',()=>{const a=d.querySelector('summary span');if(a)a.style.transform=d.open?'rotate(90deg)':'rotate(0)';})})</script>

<table>
<caption>표 1: 모듈 구성</caption>
<thead><tr><th>모듈</th><th>역할</th><th>LOC</th></tr></thead>
<tbody>
<tr><td class="left"><code>main.py</code></td><td class="left">CLI 진입점, 루프 제어, 에러 복구</td><td>~200</td></tr>
<tr><td class="left"><code>evolution.py</code></td><td class="left">진화 엔진 v4 — 6개 핵심 클래스, 30+ 메서드</td><td>1,960+</td></tr>
<tr><td class="left"><code>brain_api.py</code></td><td class="left">BRAIN API 래퍼, ACE 라이브러리 통합, 배치 시뮬</td><td>~300</td></tr>
<tr><td class="left"><code>alpha_ast.py</code></td><td class="left">AST 노드, 10개 유전 연산자, 멀티라인 생성, 64-op 제한 검증</td><td>~780</td></tr>
<tr><td class="left"><code>strategies.py</code></td><td class="left">36개 시드 전략, 리전/delay 특화</td><td>~500</td></tr>
<tr><td class="left"><code>evaluator.py</code></td><td class="left">IQC 점수 계산, IS Check, MDL 페널티</td><td>~150</td></tr>
<tr><td class="left"><code>config.py</code></td><td class="left">7라운드 설정, 11개 탐색 공간, 기준값</td><td>~200</td></tr>
<tr><td class="left"><code>pattern_learner.py</code></td><td class="left">성공 패턴 추출, 학습 기반 시드 생성 (v4)</td><td>~200</td></tr>
<tr><td class="left"><code>surrogate.py</code></td><td class="left">XGBoost/Ridge 대리 모델, 사전 필터링 (v4)</td><td>~250</td></tr>
<tr><td class="left"><code>field_explorer.py</code></td><td class="left">미사용 데이터필드 자동 스크리닝 (v4)</td><td>~200</td></tr>
<tr><td class="left"><code>dashboard.py</code></td><td class="left">실시간 웹 대시보드, HTTP API (v4)</td><td>~350</td></tr>
</tbody>
</table>

<p><code>evolution.py</code>에 정의된 6개 핵심 클래스는 다음과 같다: <code>Individual</code>(개체), <code>SHADEMemory</code>(SHADE 파라미터 메모리, H=15), <code>MAPElitesArchive</code>(품질-다양성 아카이브, 10×5), <code>AdaptiveOperatorSelector</code>(UCB1 연산자 선택기), <code>Island</code>(독립 진화 단위), <code>EvolutionEngine</code>(중앙 오케스트레이터).</p>

<h3>1.1 실행 흐름</h3>

<p>전체 파이프라인은 Biometric 인증 → 이전 결과 자동 로딩 → R1 광범위 탐색 → R2 패턴 집중 → R3 교배 강화 → R4 파라미터 최적화 → R5 멀티 리전 → R6 포트폴리오 최적화 → R7 최종 정제 → 결과 저장 및 제출의 순서로 진행된다. 각 라운드 종료 시 및 5세대 주기로 체크포인트가 저장되며, 재실행 시 이전 결과가 자동 복원된다.</p>

<div class="section-divider">• • •</div>

<!-- 2. 7-Round Evolution Strategy -->
<h2>2. 7라운드 진화 전략</h2>

<p>각 라운드는 고유한 목적과 파라미터를 가지며, 이전 라운드의 결과(명예의 전당, 파레토 아카이브, MAP-Elites)를 다음 라운드의 초기 개체군에 주입하여 점진적으로 알파 품질을 향상시킨다. 모든 라운드는 4개 섬(Island)에서 병렬 진화하며, 2세대마다 Ring Topology 이주가 발생한다.</p>

<table>
<caption>표 2: 7라운드 설정 요약</caption>
<thead><tr><th>R#</th><th>이름</th><th>개체</th><th>세대</th><th>엘리트</th><th>변이</th><th>교배</th><th>깊이</th><th>파라미터 탐색</th></tr></thead>
<tbody>
<tr><td>1</td><td class="left">광범위 탐색</td><td>200</td><td>5</td><td>5%</td><td>0.50</td><td>0.30</td><td>3</td><td>✗</td></tr>
<tr><td>2</td><td class="left">패턴 집중</td><td>150</td><td>8</td><td>10%</td><td>0.40</td><td>0.50</td><td>4</td><td>✗</td></tr>
<tr><td>3</td><td class="left">교배 강화</td><td>120</td><td>10</td><td>15%</td><td>0.25</td><td>0.70</td><td>5</td><td>✗</td></tr>
<tr><td>4</td><td class="left">파라미터 최적화</td><td>60</td><td>5</td><td>20%</td><td>0.15</td><td>0.40</td><td>5</td><td>✓</td></tr>
<tr><td>5</td><td class="left">멀티 리전</td><td>80</td><td>6</td><td>15%</td><td>0.30</td><td>0.50</td><td>5</td><td>✓</td></tr>
<tr><td>6</td><td class="left">포트폴리오 최적화</td><td>100</td><td>8</td><td>10%</td><td>0.40</td><td>0.50</td><td>5</td><td>✓</td></tr>
<tr><td>7</td><td class="left">최종 정제</td><td>50</td><td>12</td><td>25%</td><td>0.10</td><td>0.30</td><td>6</td><td>✓</td></tr>
</tbody>
</table>

<p>R1은 200개체를 4개 섬에 분배(섬당 50)하여 전략 시드 40% + 랜덤 60%로 초기 다양성을 확보한다. R3에서 교배율을 0.7로 극대화하여 구조적 결합을 촉진하고, R4에서 Latin Hypercube Sampling 기반 파라미터 최적화를 수행한다. R5는 명예의 전당 상위 20개 알파를 USA, ASI, CHN, EUR, KOR, JPN, TWN, GLB 전 리전에서 테스트한다. R7은 엘리트 비율 25%, 변이율 0.1로 미세 조정 후 자동 제출한다.</p>


<div class="section-divider">• • •</div>

<!-- 3. Core Algorithms -->
<h2>3. 핵심 알고리즘</h2>

<h3>3.1 Island Model</h3>

<p>4개의 섬이 독립적으로 진화하며, 2세대마다 Ring Topology로 개체를 교환한다. 각 섬은 자체 <code>SHADEMemory</code>(H=10)와 <code>AdaptiveOperatorSelector</code>(window=50)를 보유한다.</p>

<table>
<caption>표 3: 섬 프로파일</caption>
<thead><tr><th>섬 ID</th><th>프로파일</th><th>전략 구성</th><th>역할</th></tr></thead>
<tbody>
<tr><td>0</td><td class="left">Exploration</td><td class="left">랜덤 70% + 템플릿 20% + 진화 10%</td><td class="left">새로운 구조 탐색</td></tr>
<tr><td>1</td><td class="left">Exploitation</td><td class="left">진화 70% + 템플릿 20% + 랜덤 10%</td><td class="left">엘리트 중심 정제</td></tr>
<tr><td>2</td><td class="left">MAP-Seed</td><td class="left">MAP 30% + 템플릿 30% + 랜덤 20% + 진화 20%</td><td class="left">아카이브 시드 + 멀티라인</td></tr>
<tr><td>3</td><td class="left">Balanced</td><td class="left">라운드 기본 설정</td><td class="left">균형 잡힌 기본 진화</td></tr>
</tbody>
</table>

<p>이주 시 섬 \(i\)의 최우수 + 구조적으로 가장 다양한 개체 3개를 섬 \((i+1) \bmod 4\)로 이주시킨다. 구조적 거리는 필드 집합의 Jaccard Distance로 측정한다:</p>

<div class="math-block">
\[d_{\text{struct}}(a, b) = 1 - \frac{|\text{fields}(a) \cap \text{fields}(b)|}{|\text{fields}(a) \cup \text{fields}(b)| + \epsilon}\]
</div>

<h3>3.2 ε-Lexicase Selection</h3>

<p>다목적 최적화를 위한 부모 선택 기법으로, NSGA-II 토너먼트와 50:50 하이브리드로 사용된다. 5개 목적 함수(Sharpe, Fitness, -Turnover, Returns, Drawdown)에 대해 ε-완화된 사전식 필터링을 수행한다:</p>

<div class="math-block">
\[\text{pass}_i(x) = \begin{cases} \text{true} & \text{if } f_i(x) \geq f_i^* - \epsilon \\ \text{false} & \text{otherwise} \end{cases}\]
</div>

<h3>3.3 SHADE</h3>

<p>Differential Evolution의 핵심 파라미터 \(F\)(스케일 팩터)와 \(CR\)(교배율)을 성공 이력 기반으로 적응적으로 제어한다. 글로벌 메모리 H=15, 섬별 메모리 H=10.</p>

<div class="math-block">
\[F_i \sim \text{Cauchy}(\mu_{F,r}, 0.1), \quad CR_i \sim \mathcal{N}(\mu_{CR,r}, 0.1)\]
</div>

<p>메모리 업데이트는 Lehmer Mean을 사용한다:</p>

<div class="math-block">
\[\mu_{F,k} \leftarrow \text{mean}_L(S_F) = \frac{\sum_i w_i \cdot F_i^2}{\sum_i w_i \cdot F_i}, \quad \mu_{CR,k} \leftarrow \sum_i w_i \cdot CR_i\]
</div>

<p>가중치 \(w_i\)는 부모-자식 간 IQC 점수 개선량에 비례한다.</p>

<h3>3.4 MAP-Elites Archive</h3>

<p>행동 공간을 Sharpe × Turnover 2차원 그리드(10×5 = 50셀)로 이산화하여, 각 셀에서 최고 IQC 점수를 가진 개체만 보존하는 품질-다양성 아카이브이다.</p>

<div class="math-block">
\[\text{cell}(x) = \left(\left\lfloor \frac{\text{Sharpe}(x)}{0.3} \right\rfloor, \left\lfloor \frac{\text{Turnover}(x)}{0.2} \right\rfloor\right)\]
</div>

<h3>3.5 UCB1 Adaptive Operator Selection</h3>

<p>10개 유전 연산자의 선택 확률을 UCB1 알고리즘으로 동적 조정한다. 글로벌 AOS(window=80)와 섬별 AOS(window=50)가 이중으로 운영된다:</p>

<div class="math-block">
\[\text{UCB1}(op) = \bar{r}_{op} + C \cdot \sqrt{\frac{\ln N}{n_{op}}}, \quad C = 0.5\]
</div>

<h3>3.6 NSGA-II 다목적 최적화</h3>

<p>5개 목적 함수에 대해 비지배 정렬과 혼잡 거리를 적용한다. 엘리트 보존 시 Lexicographic Parsimony Pressure를 적용하여 동점 시 짧은 수식을 우선 선택한다.</p>

<div class="math-block">
\[a \succ b \iff \forall i: a_i \geq b_i \;\wedge\; \exists j: a_j > b_j\]
</div>

<h3>3.7 Simulated Annealing 수용</h3>

<div class="math-block">
\[P(\text{accept}) = \exp\left(\frac{\text{new} - \text{old}}{T}\right), \quad T = 1.0 \times 0.85^g, \quad T_{\min} = 0.01\]
</div>

<h3>3.8 복잡도 페널티</h3>

<p>시그모이드 함수 기반 페널티를 적용하여 노드 수 20 이상에서 점진적으로 점수를 감소시킨다:</p>

<div class="math-block">
\[\text{penalty}(x) = \frac{1}{1 + e^{-0.3 \cdot (n_{\text{nodes}} - 20)}}\]
\[\text{Score}_{\text{final}} = \max\left(0, \text{Score}_{\text{raw}} \times (1 - 0.15 \cdot \text{penalty})\right)\]
</div>

<table>
<caption>표 4: 노드 수별 복잡도 페널티</caption>
<thead><tr><th>노드 수</th><th>penalty</th><th>점수 감소율</th></tr></thead>
<tbody>
<tr><td>5</td><td>0.01</td><td>~0.2%</td></tr>
<tr><td>10</td><td>0.05</td><td>~0.7%</td></tr>
<tr><td class="sig">20</td><td class="sig">0.50</td><td class="sig">~7.5% (변곡점)</td></tr>
<tr><td>30</td><td>0.95</td><td>~14.3%</td></tr>
<tr><td>40+</td><td>~1.00</td><td>~15.0% (최대)</td></tr>
</tbody>
</table>

<div class="section-divider">• • •</div>

<!-- 4. Genetic Operators -->
<h2>4. 유전 연산자</h2>

<p>본 시스템은 10개의 유전 연산자를 운용하며, 각 연산자의 선택은 UCB1 기반 AOS에 의해 동적으로 결정된다. 교배(recombination) 5종과 변이(mutation) 5종으로 분류된다. SHADE에서 샘플링된 스케일 팩터 \(F\)는 변이 강도 및 차분 교배의 이식 확률로 활용된다. 모든 연산자는 트리 깊이 상한(depth ≤ 10)을 초과하면 부모를 그대로 반환하여 bloat를 방지한다.</p>

<table>
<caption>표 5: 유전 연산자 목록</caption>
<thead><tr><th>연산자</th><th>유형</th><th>입력</th><th>설명</th></tr></thead>
<tbody>
<tr><td class="left"><code>crossover</code></td><td>교배</td><td>2</td><td class="left">서브트리 교환 (Koza, 1992)</td></tr>
<tr><td class="left"><code>semantic_crossover</code></td><td>교배</td><td>2</td><td class="left">필드 Jaccard 거리 기반 이질적 서브트리 교환</td></tr>
<tr><td class="left"><code>de_crossover</code></td><td>교배</td><td>3</td><td class="left">DE/rand/1 차분 벡터 이식 (Storn & Price, 1997)</td></tr>
<tr><td class="left"><code>headless_chicken</code></td><td>교배</td><td>1</td><td class="left">랜덤 트리와의 교배 (Angeline, 1997)</td></tr>
<tr><td class="left"><code>multiline_crossover</code></td><td>교배</td><td>2</td><td class="left">Regular Expression 변수 블록 교환</td></tr>
<tr><td class="left"><code>mutate</code></td><td>변이</td><td>1</td><td class="left">확률적 다중 변이 (필드/연산자/윈도우/서브트리/래핑)</td></tr>
<tr><td class="left"><code>micro_mutate</code></td><td>변이</td><td>1</td><td class="left">시계열 윈도우 크기 ±1~2 미세 조정</td></tr>
<tr><td class="left"><code>hoist</code></td><td>변이</td><td>1</td><td class="left">내부 서브트리를 루트로 승격 (bloat 억제)</td></tr>
<tr><td class="left"><code>shrink</code></td><td>변이</td><td>1</td><td class="left">내부 노드를 단일 필드로 축소</td></tr>
<tr><td class="left"><code>multiline_mutate</code></td><td>변이</td><td>1</td><td class="left">Regular Expression 변수 수식 변이/추가/제거</td></tr>
</tbody>
</table>

<h3>4.1 Niche Selection</h3>

<p>교배 연산자에서 두 번째 부모를 선택할 때, 첫 번째 부모와 구조적으로 상이한 개체를 우선 선택한다. 후보 5개를 토너먼트 방식으로 추출한 뒤, 니치 점수가 가장 높은 개체를 선택한다:</p>

<div class="math-block">
\[\text{niche}(c) = 0.4 \cdot d_{\text{struct}}(c, p_1) + 0.6 \cdot \left(1 - \frac{\text{rank}(c)}{|P|}\right)\]
</div>

<h3>4.2 교배 연산자</h3>

<h4>Standard Crossover</h4>
<p>Koza(1992)의 표준 GP 교배이다. 두 부모 트리에서 각각 내부 노드를 랜덤 선택하고, 한쪽의 자식 서브트리를 다른 쪽의 서브트리로 교체한다.</p>
<pre><code><span class="cm">// 부모 1:</span> rank(ts_delta(close, 5))
<span class="cm">// 부모 2:</span> zscore(volume / (adv20 + 0.000001))
<span class="cm">// 자식:</span>  rank(volume / (adv20 + 0.000001))</code></pre>

<h4>Semantic Crossover</h4>
<p>두 부모에서 사용하는 데이터 필드 집합이 최대한 다른 서브트리 쌍을 탐색하여 교환한다. 최대 10쌍의 후보를 랜덤 샘플링한 뒤, Jaccard Distance가 가장 큰 쌍을 선택한다.</p>
<div class="math-block">
\[d_J(a, b) = 1 - \frac{|\text{fields}(a) \cap \text{fields}(b)|}{|\text{fields}(a) \cup \text{fields}(b)|}\]
</div>
<pre><code><span class="cm">// 부모 1 (가격):</span> ts_rank((close - low) / (high - low + 0.000001), 10)
<span class="cm">// 부모 2 (펀더멘탈):</span> rank(ebitda / (enterprise_value + 0.000001))
<span class="cm">// 자식:</span> ts_rank(ebitda / (enterprise_value + 0.000001), 10)</code></pre>

<h4>DE Crossover</h4>
<p>Differential Evolution(Storn & Price, 1997)의 개념을 트리 구조에 적용한다. target, donor1, donor2 세 개체를 사용하여 구조적 차분을 추출하고, SHADE의 \(F\) 확률로 target에 이식한다:</p>
<div class="math-block">
\[\text{child} = \text{target} \oplus_F \left(\text{donor}_1 \ominus \text{donor}_2\right)\]
</div>

<h4>Headless Chicken Crossover</h4>
<p>Angeline(1997)이 제안한 방법으로, 부모와 완전히 새로운 랜덤 트리(깊이 3)를 교배한다. 기존 개체군에 없는 구조를 주입하여 미탐색 영역을 개척한다.</p>

<h4>Multiline Crossover</h4>
<p>멀티라인 알파 전용 연산자이다. 두 부모의 변수 할당 블록에서 각각 하나의 변수 정의를 선택하여 교환한다.</p>
<pre><code><span class="cm">// 부모 1:</span> a = rank(ts_delta(close, 5)); b = zscore(volume / (adv20 + 0.000001)); 0.6*a + 0.4*b
<span class="cm">// 부모 2:</span> a = rank(ebitda / (ev + 0.000001)); b = ts_rank(returns, 20); 0.5*a + 0.5*b
<span class="cm">// 자식:</span>  a = rank(ts_delta(close, 5)); b = ts_rank(returns, 20); 0.6*a + 0.4*b</code></pre>

<h3>4.3 변이 연산자</h3>

<h4>Standard Mutate</h4>
<p>6가지 변이 유형을 확률적으로 선택하여 적용한다. SHADE의 \(F\) 값이 intensity로 전달되어(\(\sigma = 2F\)), 변이 강도를 적응적으로 제어한다.</p>

<table>
<caption>표 6: Standard Mutate 확률 분포</caption>
<thead><tr><th>확률 구간</th><th>변이 유형</th><th>변환 예시</th></tr></thead>
<tbody>
<tr><td>\(r < 0.12\sigma\)</td><td class="left">필드 교체</td><td class="left"><code>close</code> → <code>volume</code></td></tr>
<tr><td>\(r < 0.25\sigma\)</td><td class="left">윈도우 변경</td><td class="left"><code>ts_rank(x, 10)</code> → <code>ts_rank(x, 20)</code></td></tr>
<tr><td>\(r < 0.38\sigma\)</td><td class="left">단항 연산자 교체</td><td class="left"><code>rank(x)</code> → <code>zscore(x)</code></td></tr>
<tr><td>\(r < 0.50\sigma\)</td><td class="left">시계열 연산자 교체</td><td class="left"><code>ts_rank(x, 10)</code> → <code>ts_mean(x, 10)</code></td></tr>
<tr><td>\(r < 0.65\sigma\)</td><td class="left">서브트리 교체</td><td class="left">자식을 깊이 3 랜덤 트리로 교체</td></tr>
<tr><td>\(r < 0.80\sigma\)</td><td class="left">래핑</td><td class="left"><code>x</code> → <code>rank(x)</code> 또는 삼항 조건 래핑</td></tr>
</tbody>
</table>

<h4>Micro Mutate</h4>
<p>트리 구조를 완전히 보존하면서 시계열 연산자의 윈도우 크기만 ±1 또는 ±2로 조정한다. 윈도우 하한은 2이다.</p>

<h4>Hoist Mutation</h4>
<p>내부 노드 중 하나를 선택하여 전체 트리의 새로운 루트로 승격시킨다. 세대가 진행됨에 따라 누적되는 bloat를 억제한다.</p>
<pre><code><span class="cm">// 변이 전:</span> rank(ts_corr(close, volume, 20) + ts_delta(returns, 5))
<span class="cm">// 변이 후:</span> ts_corr(close, volume, 20)</code></pre>

<h4>Shrink Mutation</h4>
<p>내부 노드를 해당 서브트리에서 사용 중인 필드 중 하나로 교체한다. hoist보다 더 극단적인 단순화이다.</p>

<h4>Multiline Mutate</h4>
<p>멀티라인 알파 전용 변이 연산자이다. 변수 수식 변이(40%), 변수 추가(25%), 변수 제거(20%), 결합 수식 변이(15%)를 확률적으로 선택한다.</p>

<div class="section-divider">• • •</div>

<!-- 5. Expression Representation -->
<h2>5. 수식 표현 체계</h2>

<p>모든 알파 수식은 <code>Node</code> 데이터클래스로 표현되는 트리 구조이다. 각 노드는 <code>node_type</code>, <code>value</code>, <code>children</code>, <code>window</code> 속성을 가진다.</p>

<table>
<caption>표 7: AST 노드 유형</caption>
<thead><tr><th>node_type</th><th>value 예시</th><th>children</th><th>출력 예시</th></tr></thead>
<tbody>
<tr><td class="left"><code>field</code></td><td class="left">close, volume</td><td>0</td><td class="left"><code>close</code></td></tr>
<tr><td class="left"><code>unary</code></td><td class="left">rank, zscore</td><td>1</td><td class="left"><code>rank(close)</code></td></tr>
<tr><td class="left"><code>binary</code></td><td class="left">+, -, *, /</td><td>2</td><td class="left"><code>(close + volume)</code></td></tr>
<tr><td class="left"><code>ts_op</code></td><td class="left">ts_rank, ts_mean</td><td>1+window</td><td class="left"><code>ts_rank(close, 10)</code></td></tr>
<tr><td class="left"><code>ts_op2</code></td><td class="left">ts_corr</td><td>2+window</td><td class="left"><code>ts_corr(close, volume, 20)</code></td></tr>
<tr><td class="left"><code>ternary</code></td><td class="left">조건부</td><td>3</td><td class="left"><code>(vol > avg ? A : B)</code></td></tr>
<tr><td class="left"><code>block</code></td><td class="left">멀티라인</td><td>N</td><td class="left"><code>a = ...; b = ...; result</code></td></tr>
</tbody>
</table>

<p><code>to_expr()</code>는 FastExpression 형식(단일 줄), <code>to_regular()</code>는 Regular Expression 형식(멀티라인)을 출력한다. BRAIN Regular Expression 제약 조건: (1) 변수명은 단일 문자(a, b, c...), (2) 할당 후 세미콜론 필수, (3) 정의된 모든 변수는 반드시 사용, (4) 과학적 표기법 불가(<code>1e-6</code> → <code>0.000001</code>), (5) 연산자 수 64개 이하.</p>

<p>BRAIN 플랫폼은 단일 수식당 최대 64개 연산자를 허용한다. <code>operator_count()</code> 메서드는 AST에서 leaf 노드(field, number)를 제외한 모든 연산 노드(함수 호출, 이항 연산자, 삼항 연산자 등)를 재귀적으로 카운트한다. 64개를 초과하면 <code>simplify()</code>가 가장 깊은 서브트리를 leaf 노드로 교체하여 연산자 수를 줄인다. 이중 안전장치로 최종 expression 문자열에서도 정규식 기반 연산자 카운트를 수행하며, 그래도 초과하면 depth=2의 단순 트리로 대체한다.</p>

<p><code>_validate_regular()</code>는 멀티라인 수식의 구문 유효성을 10가지 항목으로 검증한다: (1) 빈 줄, (2) 할당 줄 세미콜론, (3) 할당 형식, (4) 괄호 밸런스, (5) 빈 인자 함수 호출, (6) 미정의 변수 참조, (7) 미사용 정의 변수, (8) trailing/leading 연산자, (9) 연속 이항 연산자, (10) 불완전 삼항 연산자. 검증 실패 시 <code>to_expr()</code> 단일 줄 형식으로 자동 폴백한다.</p>

<p>멀티라인 알파의 최종 결합 수식은 가중합, 조건부(중첩 삼항), 교차항(곱셈+덧셈) 3가지 방식 중 랜덤 선택된다. 각 변수는 9개 시그널 카테고리(모멘텀/반전, 밸류, 유동성, 애널리스트, 베타/상관, 뉴스 센티먼트, 공매도, 옵션, 비율)에서 라운드 로빈으로 할당되어 멀티팩터 다양성을 확보한다.</p>

<div class="section-divider">• • •</div>

<!-- 6. Evaluation & Submission -->
<h2>6. 평가 및 제출 파이프라인</h2>

<h3>6.1 IQC 점수 계산</h3>

<p>IS Check 통과 시:</p>
<div class="math-block">
\[\text{Score} = 4 \cdot \text{Sharpe} + 3 \cdot \text{Fitness} + 12 \cdot \max(0, \text{Returns}) + 4 \cdot \max(0, 0.7 - \text{TO}) + 3 \cdot \max(0, \text{DD} + 0.2)\]
\[+ 3 \cdot \text{OS\_Sharpe} + 2 \cdot \text{OS\_Fitness} + 5 \cdot \mathbb{1}[\text{consistency} > 0.5] \cdot \frac{\text{OS\_Sharpe}}{\text{Sharpe}}\]
</div>

<p>IS Check 미통과 시:</p>
<div class="math-block">
\[\text{Score} = \max\left(0, 0.5 \cdot \text{Sharpe} + 0.3 \cdot \text{Fitness}\right)\]
</div>

<h3>6.2 IS Check 기준</h3>

<table>
<caption>표 8: IS Check 기준값</caption>
<thead><tr><th>지표</th><th>delay=1</th><th>delay=0</th></tr></thead>
<tbody>
<tr><td class="left">Sharpe Ratio</td><td>≥ 0.58</td><td>≥ 1.25</td></tr>
<tr><td class="left">Fitness</td><td>≥ 1.0</td><td>≥ 1.5</td></tr>
<tr><td class="left">Turnover</td><td>≤ 0.70</td><td>≤ 0.70</td></tr>
<tr><td class="left">Self-Correlation</td><td colspan="2">≤ 0.55</td></tr>
</tbody>
</table>

<h3>6.3 제출 파이프라인</h3>

<p>시뮬레이션 완료 → IS Check(all_checks_pass) → Self-Correlation Check(&lt;0.55) → 명예의 전당 등록 → 자동 제출(--submit). BRAIN API의 <code>all_checks_pass</code> 플래그를 우선 사용하며, 모든 메트릭 접근에 <code>float(metrics.get("sharpe") or 0)</code> 패턴을 적용하여 None 값을 방어한다.</p>

<h3>6.4 포트폴리오 가치</h3>
<div class="math-block">
\[V_{\text{portfolio}} = \sum_{i=1}^{n} \text{Score}_i \cdot \left(1 + 0.5 \cdot \max(0, 1 - \rho_{\text{self},i})\right)\]
</div>

<div class="section-divider">• • •</div>

<!-- 7. Stagnation Escape -->
<h2>7. 정체 탈출 메커니즘</h2>

<p>유전 알고리즘은 본질적으로 지역 최적해(local optimum)에 수렴하는 경향이 있다. 특히 BRAIN 알파 탐색에서는 특정 수식 패턴(예: <code>(close - low)/(high - low)</code> 계열)이 Sharpe 1.0~1.5 구간에서 정체되는 현상이 빈번하다. 이를 탈출하기 위해 5단계 정체 탈출 메커니즘을 운용한다.</p>

<h3>7.1 정체 감지</h3>

<p>각 섬(Island)은 <code>stagnation</code> 카운터를 보유한다. 세대가 진행될 때마다 해당 섬의 최고 IQC 점수가 이전 세대 대비 개선되지 않으면 카운터가 1 증가한다. 3세대 연속 개선이 없으면(<code>stagnation >= 3</code>) 해당 섬에 대격변(Cataclysm)이 발동된다. 정체 감지는 섬 단위로 독립적이므로, 4개 섬 중 일부만 대격변이 발동될 수 있다.</p>

<h3>7.2 대격변(Cataclysm)</h3>

<p>대격변은 섬 인구의 다양성을 강제로 회복시키는 메커니즘이다. 구체적인 절차는 다음과 같다:</p>

<p>(1) 현재 인구를 IQC 점수 기준으로 정렬하여 상위 50%를 보존한다. 이들은 지금까지 발견된 최선의 유전 정보를 담고 있으므로 폐기하지 않는다.</p>

<p>(2) 하위 50%를 새로운 개체로 교체한다. 교체 비율은 MAP-Elites 시드 30%(아카이브에서 다양한 행동 영역의 개체를 추출), 멀티라인 알파 15%(복합 수식 구조 탐색), 전략 템플릿 및 완전 랜덤 55%(새로운 탐색 영역 진입)이다.</p>

<p>(3) Simulated Annealing 온도를 현재 값의 2배로 상승시킨다. 이는 열악한 자식 개체도 일시적으로 수용할 확률을 높여, 현재 수렴 영역에서 벗어나는 것을 촉진한다.</p>

<p>(4) 정체 카운터를 0으로 리셋한다.</p>

<h3>7.3 이주(Migration)</h3>

<p>대격변과 별도로, 2세대마다 Ring Topology 이주가 발생한다. 각 섬의 상위 3개체가 인접 섬으로 이동하여 유전적 다양성을 교환한다. 4개 섬 기준 한 번의 이주에서 총 12개체가 이동한다. 이주는 대격변보다 온건한 다양성 유지 수단으로, 섬 간 정보 공유를 통해 전역 최적해 탐색을 촉진한다.</p>

<h3>7.4 실전 동작 예시</h3>

<p>실제 실행에서 관찰된 전형적인 정체-탈출 패턴은 다음과 같다. R1 세대 3~4에서 4개 섬 모두 Score 1.30 근처에 수렴하면, 섬0과 섬1에서 대격변이 발동된다. 대격변 후 MAP-Elites 시드에서 주입된 이질적 개체(예: 밸류 팩터 기반 수식)가 기존 모멘텀 계열 수식과 교배되어 새로운 복합 시그널이 생성된다. 이 과정에서 Score 1.3을 돌파하는 개체가 출현할 수 있다.</p>

<h3>7.5 다양성 강제 주입</h3>

<p>대격변과 이주만으로는 해결되지 않는 구조적 다양성 문제가 존재한다. 교배율이 높은 라운드(R3: crossover_rate=0.7)에서 부모 풀의 필드 구성이 유사하면, 교배 결과도 동일한 필드 조합의 변형에 불과하다. 예를 들어 <code>rank(cashflow_op/vwap)</code> 계열 수식끼리 교배하면 <code>rank(cashflow_op/close)</code> 같은 미미한 변형만 생성되어 BRAIN의 Self-Correlation 검사에 걸린다.</p>

<p>이를 해결하기 위해 매 세대 offspring의 15%를 희귀 필드 그룹에서 생성한 랜덤 트리로 강제 교체한다. 구체적으로, 현재 population에서 30% 이상의 개체가 사용하는 필드를 "과다 사용 필드"로 분류하고, 이와 겹침이 적은 필드 그룹(fundamental, analyst, sentiment, option, institution 등)을 선별한다. 해당 그룹에서 생성된 트리는 IQC 점수가 0인 non-elite 개체를 교체한다.</p>

<h3>7.6 Self-Correlation 사전 필터</h3>

<p>BRAIN API의 Self-Correlation 검사는 시뮬레이션 완료 후에야 결과가 반환되므로, 유사한 수식을 반복 제출하면 API 호출이 낭비된다. 이를 방지하기 위해 <code>_evaluate_population()</code> 단계에서 필드 시그니처 기반 사전 필터를 적용한다.</p>

<p>각 수식의 필드 집합을 추출하여 명예의 전당 및 제출 완료 알파의 필드 집합과 Jaccard 유사도를 계산한다:</p>

<div class="math-block">
\[J(A, B) = \frac{|A \cap B|}{|A \cup B|}\]
</div>

<p>Jaccard 유사도가 0.85를 초과하면 해당 수식은 API 호출 없이 스킵된다. 이 필터는 Surrogate 필터 이전에 적용되어, 구조적으로 중복된 수식이 Surrogate 모델의 학습 데이터를 오염시키는 것도 방지한다.</p>

<div class="section-divider">• • •</div>

<!-- 8. Persistence -->
<h2>8. 영속성 및 상태 복원</h2>

<h3>8.1 문제 정의: 장시간 실행의 구조적 취약점</h3>

<p>BRAIN API 기반 알파 탐색은 단일 사이클(7라운드)에 수 시간이 소요된다. 세션 만료(약 8시간), 네트워크 단절, 시스템 슬립 등으로 인해 중간에 프로세스가 종료되는 상황이 빈번하다. 체크포인트 없이 실행하면 수 시간의 시뮬레이션 결과가 전부 유실되며, 재시작 시 동일한 탐색 영역을 처음부터 반복하게 된다.</p>

<p>이 문제는 두 가지 차원에서 발생한다. 첫째, 진화 과정에서 축적된 고품질 개체(명예의 전당, 파레토 아카이브)의 유실이다. 둘째, 연산자 선택 통계(AOS)와 SHADE 파라미터 메모리의 유실로 인해 학습된 탐색 전략이 초기화된다.</p>

<h3>8.2 체크포인트 아키텍처</h3>

<p>시스템은 두 종류의 영속 파일을 <code>results/</code> 디렉토리에 생성한다.</p>

<table>
<caption>표 9: 저장 파일 구조</caption>
<thead><tr><th>파일</th><th>생성 시점</th><th>수명</th><th>용도</th></tr></thead>
<tbody>
<tr><td class="left"><code>checkpoint_latest.json</code></td><td class="left">매 세대 종료 시 + 제출 성공 시</td><td class="left">덮어쓰기 (최신만)</td><td class="left">크래시 복구용 스냅샷</td></tr>
<tr><td class="left"><code>evolution_YYYYMMDD_HHMMSS.json</code></td><td class="left">7라운드 사이클 완료 시</td><td class="left">누적 (삭제 안 함)</td><td class="left">장기 이력 보존</td></tr>
</tbody>
</table>

<p><code>checkpoint_latest.json</code>은 매 세대가 끝날 때마다 덮어쓰기로 저장된다. 이는 R1 세대 3에서 프로세스가 종료되더라도 세대 2까지의 결과가 보존됨을 의미한다. 제출 성공 시에도 즉시 체크포인트를 갱신하여, 제출 직후 크래시가 발생해도 제출 기록이 유실되지 않는다.</p>

<h3>8.3 상태 복원 프로세스</h3>

<p>프로그램 시작 시 <code>_load_previous()</code>가 <code>results/</code> 디렉토리의 모든 JSON 파일을 역순으로 스캔한다. 복원 대상은 다음과 같다:</p>

<table>
<caption>표 10: 복원 대상 및 활용</caption>
<thead><tr><th>복원 대상</th><th>최대 보존 수</th><th>활용 시점</th></tr></thead>
<tbody>
<tr><td class="left">명예의 전당 (Hall of Fame)</td><td>100개</td><td class="left">R2+ 초기 개체군의 <code>evolved</code> 시드</td></tr>
<tr><td class="left">MAP-Elites 아카이브</td><td>50셀</td><td class="left">섬 2의 <code>map_elites</code> 시드 + 카타클리즘 주입</td></tr>
<tr><td class="left">파레토 아카이브</td><td>50개</td><td class="left">R2+ 초기 개체군의 상위 8% 이월</td></tr>
<tr><td class="left">제출 기록</td><td>전체</td><td class="left">중복 제출 방지</td></tr>
<tr><td class="left">AOS 연산자 통계</td><td>최신 파일</td><td class="left">UCB1 연산자 선택 확률 초기화</td></tr>
</tbody>
</table>

<p>복원 과정에서 동일 수식의 중복은 expression 문자열 비교로 제거된다. 명예의 전당은 IQC 점수 기준 상위 100개만 유지하며, 파레토 아카이브에는 score > 2.0인 개체만 추가된다.</p>

<h3>8.4 세션 중단 시 보존/유실 분석</h3>

<p>R3 세대 5에서 세션이 만료되어 프로세스가 종료된 경우를 가정한다.</p>

<table>
<caption>표 11: 중단 시 데이터 보존 현황</caption>
<thead><tr><th>데이터</th><th>상태</th><th>설명</th></tr></thead>
<tbody>
<tr><td class="left">R1~R2 명예의 전당</td><td style="color:#16a34a">보존</td><td class="left">라운드 종료 시 체크포인트에 저장됨</td></tr>
<tr><td class="left">R3 세대 1~4 명예의 전당</td><td style="color:#16a34a">보존</td><td class="left">매 세대 체크포인트에 포함</td></tr>
<tr><td class="left">R3 세대 5 진행 중 개체</td><td style="color:#dc2626">유실</td><td class="left">세대 완료 전 크래시 → 미저장</td></tr>
<tr><td class="left">MAP-Elites / 파레토</td><td style="color:#16a34a">보존</td><td class="left">체크포인트에 포함</td></tr>
<tr><td class="left">AOS 통계</td><td style="color:#16a34a">보존</td><td class="left">체크포인트에 포함</td></tr>
<tr><td class="left">SHADE 메모리</td><td style="color:#dc2626">유실</td><td class="left">체크포인트에 미포함, 기본값으로 초기화</td></tr>
<tr><td class="left"><code>seen_exprs</code> (중복 방지 셋)</td><td style="color:#dc2626">유실</td><td class="left">메모리 전용, 재시작 시 동일 수식 재시뮬레이션 가능</td></tr>
<tr><td class="left">score 0.5~1.5 중간 결과</td><td style="color:#dc2626">유실</td><td class="left">명예의 전당 기준(1.5) 미달 → 미저장</td></tr>
</tbody>
</table>

<h3>8.5 반복 실행의 누적 효과</h3>

<p>체크포인트 시스템의 핵심 가치는 반복 실행에 따른 누적 학습이다. 첫 번째 사이클에서 R1~R3까지만 완료하고 종료되더라도, 두 번째 실행에서는:</p>

<p class="no-indent" style="margin-left:2em">
(1) 이전 명예의 전당 개체가 R2+ 초기 개체군의 <code>evolved</code> 슬롯에 주입되어 탐색 시작점이 상향된다.<br>
(2) MAP-Elites 아카이브의 행동 공간 커버리지가 유지되어 카타클리즘 시 다양한 시드를 제공한다.<br>
(3) AOS 통계가 복원되어 이전에 효과적이었던 연산자(예: semantic_crossover)가 높은 확률로 선택된다.<br>
(4) 파레토 아카이브의 비지배 해가 초기 개체군의 8%를 구성하여 다목적 최적화의 출발점을 제공한다.
</p>

<p>결과적으로 R1은 매번 처음부터 실행되지만, 이전 실행에서 발견된 고품질 개체가 시드로 활용되므로 동일한 탐색을 반복하지 않는다. 다만 R1 자체의 랜덤 탐색 비중이 60%이므로, 새로운 영역의 탐색도 병행된다.</p>

<div class="section-divider">• • •</div>

<!-- 9. Strategy Seeds -->
<h2>9. 36개 전략 시드</h2>

<p>초기 개체군 생성 시 사용되는 36개의 검증된 알파 전략 템플릿이다. 각 전략은 호출 시마다 랜덤 파라미터(윈도우, 필드)를 선택하여 다양한 변형을 생성한다.</p>

<table>
<caption>표 12: 전략 시드 요약 (일부)</caption>
<thead><tr><th>#</th><th>전략명</th><th>카테고리</th><th>핵심 로직</th></tr></thead>
<tbody>
<tr><td>1</td><td class="left">Short-Term Reversal</td><td>반전</td><td class="left"><code>-rank(ts_delta(close, 5))</code></td></tr>
<tr><td>3</td><td class="left">Volume-Price Divergence</td><td>거래량</td><td class="left"><code>-rank(ts_corr(close, volume, 20))</code></td></tr>
<tr><td>4</td><td class="left">Fundamental Value</td><td>펀더멘탈</td><td class="left"><code>rank(ebitda / (enterprise_value + ε))</code></td></tr>
<tr><td>19</td><td class="left">Momentum × Value</td><td>멀티팩터</td><td class="left">모멘텀 + 가치 결합</td></tr>
<tr><td>26</td><td class="left">Sentiment Reversal</td><td>센티먼트</td><td class="left">뉴스 감성 반전</td></tr>
<tr><td>29</td><td class="left">Multiline Multifactor</td><td>멀티라인</td><td class="left">변수 할당 기반 복합 팩터</td></tr>
<tr><td>33</td><td class="left">Asia Value Momentum</td><td>아시아</td><td class="left">아시아 시장 가치+모멘텀</td></tr>
<tr><td>35</td><td class="left">Decorrelated Composite</td><td>비상관</td><td class="left">다축 비상관 복합</td></tr>
</tbody>
</table>

<p>delay=0 모드에서는 <code>delay0_strategies()</code>가 40% 확률로 우선 선택된다. 아시아 리전(CHN, KOR, JPN, ASI, TWN)에서는 <code>asia_strategies()</code>가 30% 확률로 선택된다.</p>

<div class="section-divider">• • •</div>

<!-- 10. v4 Extensions -->
<h2>10. v4 확장: 탐색 효율 및 수렴 가속 모듈</h2>

<p>v3까지의 핵심 진화 엔진은 순수 유전 프로그래밍 기반으로 동작하며, 초기 개체군 생성은 전략 시드와 완전 랜덤의 혼합에 의존한다. 이 접근은 탐색 공간의 균일 커버리지를 보장하지만, 두 가지 구조적 비효율이 존재한다. 첫째, 이전 사이클에서 축적된 성공 패턴이 초기 개체군 생성에 반영되지 않아 매 사이클마다 동일한 탐색 영역을 반복 방문한다. 둘째, BRAIN API 시뮬레이션 호출(건당 3~15초)이 병목이므로, 명백히 유망하지 않은 수식에 대한 API 호출이 전체 처리량을 저하시킨다.</p>

<p>v4에서는 이 두 문제를 해결하기 위해 4개의 독립 모듈과 2개의 기존 모듈 강화를 도입하였다. 각 모듈은 기존 파이프라인에 비침습적으로 통합되며, 모듈 간 의존성 없이 독립적으로 비활성화할 수 있다.</p>

<table>
<caption>표 13: v4 확장 모듈 구성</caption>
<thead><tr><th>모듈</th><th>파일</th><th>역할</th><th>통합 지점</th></tr></thead>
<tbody>
<tr><td class="left">Pattern Learner</td><td class="left"><code>pattern_learner.py</code></td><td class="left">성공 패턴 추출 → 학습 기반 시드 생성</td><td class="left"><code>_create_population()</code></td></tr>
<tr><td class="left">Surrogate Model</td><td class="left"><code>surrogate.py</code></td><td class="left">Sharpe 예측 → API 호출 전 필터링</td><td class="left"><code>_evaluate_population()</code></td></tr>
<tr><td class="left">Field Explorer</td><td class="left"><code>field_explorer.py</code></td><td class="left">미사용 데이터필드 자동 스크리닝</td><td class="left"><code>run_all_rounds()</code> 후</td></tr>
<tr><td class="left">MDL Penalty</td><td class="left"><code>evaluator.py</code></td><td class="left">정보이론 기반 복잡도 페널티</td><td class="left"><code>compute_iqc_score()</code></td></tr>
<tr><td class="left">Dashboard</td><td class="left"><code>dashboard.py</code></td><td class="left">실시간 웹 모니터링</td><td class="left"><code>main.py --dashboard</code></td></tr>
<tr><td class="left">Cross-Pollination</td><td class="left"><code>evolution.py</code></td><td class="left">멀티 리전 교차 수분</td><td class="left"><code>_run_multi_region_round()</code></td></tr>
</tbody>
</table>

<h3>10.1 패턴 학습기 (Pattern Learner)</h3>

<h4>10.1.1 동기</h4>

<p>유전 프로그래밍에서 초기 개체군의 품질은 수렴 속도에 결정적 영향을 미친다(Koza, 1992). 기존 시스템은 36개 전략 시드와 <code>rand_tree()</code>의 균일 랜덤 생성에 의존하는데, 이는 BRAIN 플랫폼에서 실제로 높은 Sharpe를 달성하는 수식의 구조적 특성을 반영하지 못한다. 예를 들어, 성공 알파에서 <code>ts_decay_linear</code>이 <code>ts_sum</code>보다 10배 이상 빈출한다면, 초기 개체군에서도 이 비율을 반영하는 것이 합리적이다.</p>

<h4>10.1.2 패턴 추출</h4>

<p>Hall of Fame에 축적된 성공 알파들의 수식 문자열에서 3가지 통계를 추출한다: (1) 데이터 필드 빈도, (2) 연산자 빈도, (3) 시계열 윈도우 크기 빈도. 각 빈도는 해당 알파의 IQC 점수에 비례하는 가중치를 적용한다.</p>

<div class="math-block">
\[
w_f = \sum_{i \in \text{HoF}} \text{count}(f, \alpha_i) \cdot \lfloor \text{IQC}_i \rfloor
\]
</div>

<p class="no-indent">필드 추출 시 BRAIN 연산자 사전(60개)과의 차집합으로 순수 데이터 필드만 분리한다. 정규표현식 <code>[a-z][a-z0-9_]*</code>로 토큰을 추출한 뒤, <code>rank</code>, <code>ts_delta</code>, <code>group_neutralize</code> 등 알려진 연산자를 제외한다. 연산자는 <code>([a-z_]+)\s*\(</code> 패턴으로, 윈도우는 <code>ts_\w+\([^,]+,\s*(\d+)\)</code> 패턴으로 추출한다.</p>

<h4>10.1.3 학습 기반 트리 생성</h4>

<p>추출된 빈도 분포를 기반으로 AST 트리를 재귀적으로 생성한다. 각 노드에서 30%의 확률로 완전 랜덤 서브트리를 삽입하여 exploitation-exploration 균형을 유지한다. 나머지 70%에서는 다음 확률 분포에 따라 노드 유형을 선택한다:</p>

<table>
<caption>표 14: 학습 기반 노드 생성 확률</caption>
<thead><tr><th>확률 구간</th><th>노드 유형</th><th>소스</th><th>예시</th></tr></thead>
<tbody>
<tr><td>\(r < 0.35\)</td><td class="left">시계열 연산자</td><td class="left">빈출 ts_op + 빈출 윈도우</td><td class="left"><code>ts_decay_linear(close, 10)</code></td></tr>
<tr><td>\(0.35 \leq r < 0.55\)</td><td class="left">랭킹/중립화</td><td class="left">빈출 rank/group 연산자</td><td class="left"><code>group_rank(volume)</code></td></tr>
<tr><td>\(0.55 \leq r < 0.75\)</td><td class="left">산술 연산</td><td class="left">균일 랜덤 {+, -, *, /}</td><td class="left"><code>close / adv20</code></td></tr>
<tr><td>\(0.75 \leq r < 1.0\)</td><td class="left">단항 연산</td><td class="left">균일 랜덤 {rank, abs, log, sign, -1*}</td><td class="left"><code>rank(x)</code></td></tr>
</tbody>
</table>

<p class="no-indent">리프 노드에서는 70% 확률로 빈출 필드 상위 15개에서 선택하고, 30% 확률로 [0.01, 2.0] 범위의 상수를 생성한다. 학습 시드는 전체 population의 15%를 차지하며, <code>birth_operator = "pattern_learned"</code>로 태깅되어 AOS 통계에서 추적된다.</p>

<h4>10.1.4 온라인 갱신</h4>

<p>패턴 학습기는 엔진 초기화 시 기존 Hall of Fame 전체를 분석하고, 각 라운드 종료 시 해당 라운드에서 신규 발견된 알파만 추가 분석한다. 최소 5개 이상의 알파가 분석되어야 학습 기반 생성이 활성화되며, 그 이전에는 <code>rand_tree()</code>로 폴백한다.</p>

<h3>10.2 Surrogate Model (대리 모델)</h3>

<h4>10.2.1 동기</h4>

<p>BRAIN API 시뮬레이션은 건당 3~15초가 소요되며, 세대당 50개 개체를 평가하면 한 세대에 2.5~12.5분이 필요하다. 7라운드 전체(총 54세대)에서 약 2,700회의 API 호출이 발생하는데, 이 중 상당수는 Sharpe < 0인 수식에 대한 불필요한 호출이다. Surrogate-Assisted Evolutionary Computation(Jin, 2011)의 원리를 적용하여, 수식의 구조적 특징만으로 Sharpe를 사전 예측하고 유망한 후보만 실제 API로 평가한다.</p>

<h4>10.2.2 특징 벡터 설계</h4>

<p>수식 문자열에서 20차원 특징 벡터 \(\mathbf{x}_\alpha \in \mathbb{R}^{20}\)를 추출한다. 특징은 5개 카테고리로 구성된다:</p>

<table>
<caption>표 15: Surrogate 특징 벡터 (20차원)</caption>
<thead><tr><th>차원</th><th>카테고리</th><th>특징</th><th>추출 방법</th></tr></thead>
<tbody>
<tr><td>1-2</td><td class="left">길이</td><td class="left">수식 길이, 괄호 수</td><td class="left"><code>len(expr)</code>, <code>count("(")</code></td></tr>
<tr><td>3-5</td><td class="left">연산자 빈도</td><td class="left">ts_op 수, rank 수, group_op 수</td><td class="left">정규표현식 매칭</td></tr>
<tr><td>6-9</td><td class="left">산술 연산자</td><td class="left">+, -, *, / 각각의 출현 횟수</td><td class="left"><code>count()</code></td></tr>
<tr><td>10-12</td><td class="left">윈도우 통계</td><td class="left">평균, 최대, 최소</td><td class="left"><code>,\s*(\d+)\)</code> 패턴</td></tr>
<tr><td>13</td><td class="left">필드 다양성</td><td class="left">고유 필드 수</td><td class="left">토큰 - 연산자 사전</td></tr>
<tr><td>14</td><td class="left">구조</td><td class="left">멀티라인 여부</td><td class="left"><code>";" in expr</code></td></tr>
<tr><td>15-19</td><td class="left">패턴 존재</td><td class="left">ts_decay_linear, ts_zscore, ts_corr, group_neutralize, ts_regression</td><td class="left">이진 플래그</td></tr>
</tbody>
</table>

<h4>10.2.3 모델 학습</h4>

<p>XGBoost가 설치되어 있으면 자동으로 사용하고(<code>n_estimators=100, max_depth=4, lr=0.1, subsample=0.8</code>), 없으면 Ridge Regression으로 폴백한다. Ridge의 경우 특징을 z-score 정규화한 뒤 정규화 파라미터 \(\lambda = 1.0\)으로 가우스 소거법을 통해 해석적으로 풀이한다:</p>

<div class="math-block">
\[
\hat{\mathbf{w}} = (\mathbf{X}^\top \mathbf{X} + \lambda \mathbf{I})^{-1} \mathbf{X}^\top \mathbf{y}
\]
</div>

<p class="no-indent">학습 데이터는 매 시뮬레이션 완료 시 <code>(특징벡터, Sharpe)</code> 쌍으로 축적되며, 50개 단위로 재학습한다. 최소 30개 샘플이 축적되어야 모델이 활성화된다.</p>

<h4>10.2.4 사전 필터링</h4>

<p>모델 활성화 후, <code>_evaluate_population()</code>에서 미평가 개체가 10개 이상일 때 사전 필터링을 수행한다. 모든 미평가 수식에 대해 \(\hat{S}(\alpha)\)를 예측하고, 상위 60%만 실제 API 호출로 평가한다. 하위 40% 중에서도 10%를 랜덤으로 포함하여 surrogate의 편향(bias)을 완화하고, 모델이 과소평가하는 영역의 탐색을 보장한다.</p>

<pre><code><span class="cm"># Surrogate 필터링 의사코드</span>
scores = [(i, surrogate.predict(expr)) <span class="kw">for</span> i, expr <span class="kw">in</span> enumerate(unevaluated)]
scores.sort(key=<span class="kw">lambda</span> x: -x[<span class="nu">1</span>])
keep = scores[:int(len(scores) * <span class="nu">0.6</span>)]           <span class="cm"># 상위 60%</span>
random_add = random.sample(scores[len(keep):], <span class="nu">10</span>%)  <span class="cm"># 하위에서 10% 랜덤</span>
evaluate_only = keep + random_add</code></pre>

<h3>10.3 데이터필드 자동 탐색기 (Field Explorer)</h3>

<h4>10.3.1 동기</h4>

<p>BRAIN 플랫폼은 USA 리전에서만 수백 개의 데이터 필드를 제공한다. <code>alpha_ast.py</code>에 하드코딩된 기본 필드 풀은 44개(가격 11 + 펀더멘탈 20 + 애널리스트 3 + 기타 10)로, 전체 가용 필드의 일부에 불과하다. 수동으로 새 필드를 발견하고 테스트하는 과정은 비효율적이며, 경쟁이 덜한 비주류 필드에서 알파를 발견할 기회를 놓치게 된다.</p>

<h4>10.3.2 필드 로딩 및 분류</h4>

<p>Field Explorer는 <code>results/datafields_usa.csv</code>에서 전체 필드 목록을 CSV 파싱으로 로드한다. 각 필드는 <code>category</code>(또는 <code>dataset</code>) 컬럼 기준으로 카테고리별로 분류된다. 기존 <code>KNOWN_FIELDS</code>(44개)와 이미 테스트된 필드를 제외한 미사용 필드 목록을 산출한다.</p>

<h4>10.3.3 자동 스크리닝 프로토콜</h4>

<p>7라운드 진화 완료 후, 미사용 필드에서 15개를 랜덤 샘플링하여 자동 스크리닝을 수행한다. 각 필드에 대해 8가지 표준 테스트 수식을 생성하되, API 호출 효율을 위해 필드당 최대 3개만 실제 시뮬레이션한다:</p>

<table>
<caption>표 16: 필드 스크리닝 테스트 수식</caption>
<thead><tr><th>#</th><th>수식 템플릿</th><th>테스트 목적</th></tr></thead>
<tbody>
<tr><td>1</td><td class="left"><code>rank(ts_delta({field}, 5))</code></td><td class="left">단기 변화율 모멘텀</td></tr>
<tr><td>2</td><td class="left"><code>-1 * rank(ts_delta({field}, 10))</code></td><td class="left">중기 반전</td></tr>
<tr><td>3</td><td class="left"><code>rank(ts_zscore({field}, 20))</code></td><td class="left">정규화된 이탈도</td></tr>
<tr><td>4</td><td class="left"><code>-1 * ts_decay_linear(ts_delta({field}, 5), 10)</code></td><td class="left">감쇠 모멘텀</td></tr>
<tr><td>5</td><td class="left"><code>rank({field} / ts_mean({field}, 20) - 1)</code></td><td class="left">이동평균 대비 괴리</td></tr>
<tr><td>6</td><td class="left"><code>-1 * rank(ts_std_dev({field}, 20))</code></td><td class="left">변동성 역전</td></tr>
<tr><td>7</td><td class="left"><code>rank(ts_av_diff({field}, 20))</code></td><td class="left">평균 차이 추세</td></tr>
<tr><td>8</td><td class="left"><code>group_rank(ts_delta({field}, 5), subindustry)</code></td><td class="left">산업 내 상대 모멘텀</td></tr>
</tbody>
</table>

<h4>10.3.4 결과 분류 및 활용</h4>

<p>스크리닝 결과는 3단계로 분류된다:</p>

<table>
<caption>표 17: 필드 분류 기준</caption>
<thead><tr><th>분류</th><th>기준</th><th>후속 처리</th></tr></thead>
<tbody>
<tr><td class="left">유망 (Promising)</td><td>Sharpe &gt; 0.3</td><td class="left">유망 필드 풀에 등록, 최고 Sharpe 기록</td></tr>
<tr><td class="left">중립 (Neutral)</td><td>-0.5 &lt; Sharpe ≤ 0.3</td><td class="left">테스트 완료 표시, 재테스트 가능</td></tr>
<tr><td class="left">실패 (Failed)</td><td>Sharpe ≤ -0.5</td><td class="left">실패 목록 등록, 재테스트 방지</td></tr>
</tbody>
</table>

<p class="no-indent">유망 필드에서 Sharpe > 0.5인 경우, 해당 수식을 즉시 Hall of Fame에 등록하고 <code>--submit</code> 모드에서는 자동 제출을 시도한다. 모든 스크리닝 결과는 Surrogate Model의 학습 데이터로도 활용된다.</p>

<h3>10.4 MDL 복잡도 제어</h3>

<h4>10.4.1 이론적 배경</h4>

<p>Minimum Description Length(Rissanen, 1978) 원리에 따르면, 최적 모델은 데이터 기술 길이 \(L(D|H)\)와 모델 기술 길이 \(L(H)\)의 합을 최소화한다. 유전 프로그래밍에서 수식의 복잡도가 증가하면 in-sample 적합도는 향상되지만 out-of-sample 일반화 성능은 저하되는 과적합이 발생한다. v3의 시그모이드 기반 노드 수 페널티(Section 3.8)는 트리 구조의 크기만 반영하며, 수식의 정보론적 복잡도를 포착하지 못한다.</p>

<h4>10.4.2 기술 길이 추정</h4>

<p>수식의 정보량을 4가지 구성 요소의 가중합으로 추정한다. 각 구성 요소의 비트 수는 해당 요소의 선택 공간 크기의 로그에 근사한다:</p>

<div class="math-block">
\[
L(H) = 5 \cdot n_{\text{ops}} + 7 \cdot n_{\text{fields}} + 4 \cdot n_{\text{params}} + 10 \cdot n_{\text{vars}}
\]
</div>

<table>
<caption>표 18: 기술 길이 구성 요소</caption>
<thead><tr><th>구성 요소</th><th>비트/단위</th><th>근거</th><th>추출 방법</th></tr></thead>
<tbody>
<tr><td class="left">연산자 (\(n_{\text{ops}}\))</td><td>5</td><td class="left">\(\lceil \log_2 30 \rceil \approx 5\) (30개 연산자)</td><td class="left"><code>count("(")</code></td></tr>
<tr><td class="left">필드 (\(n_{\text{fields}}\))</td><td>7</td><td class="left">\(\lceil \log_2 100 \rceil \approx 7\) (100개 필드)</td><td class="left">고유 토큰 - 연산자 사전</td></tr>
<tr><td class="left">윈도우 (\(n_{\text{params}}\))</td><td>4</td><td class="left">\(\lceil \log_2 15 \rceil \approx 4\) (15개 윈도우 값)</td><td class="left"><code>,\s*(\d+)\)</code> 패턴</td></tr>
<tr><td class="left">멀티라인 변수 (\(n_{\text{vars}}\))</td><td>10</td><td class="left">변수 정의 = 연산자 + 필드 + 윈도우 복합</td><td class="left"><code>count(";")</code></td></tr>
</tbody>
</table>

<h4>10.4.3 페널티 함수</h4>

<p>기술 길이 80 bits 이하에서는 페널티를 부과하지 않는다. 이는 <code>rank(ts_delta(close, 5))</code> 수준의 단순 수식(약 2개 연산자 + 2개 필드 + 1개 윈도우 = 28 bits)이 페널티 없이 통과하도록 설계된 임계값이다. 80 bits 초과 시 선형적으로 증가하여 480 bits에서 최대 25%에 도달한다:</p>

<div class="math-block">
\[
\text{penalty}_{\text{MDL}} = \min\left(0.25, \; \frac{\max(0, \; L(H) - 80)}{400}\right)
\]
</div>

<p class="no-indent">이 페널티는 기존의 시그모이드 노드 수 페널티와 곱셈적으로 결합된다:</p>

<div class="math-block">
\[
\text{Score}_{\text{final}} = \text{Score}_{\text{raw}} \times (1 - 0.15 \cdot \sigma_{\text{node}}) \times (1 - \text{penalty}_{\text{MDL}})
\]
</div>

<table>
<caption>표 19: MDL 페널티 예시</caption>
<thead><tr><th>수식 예시</th><th>\(L(H)\)</th><th>페널티</th></tr></thead>
<tbody>
<tr><td class="left"><code>rank(ts_delta(close, 5))</code></td><td>28</td><td>0%</td></tr>
<tr><td class="left"><code>-1 * rank(ts_zscore(close / adv20, 20))</code></td><td>52</td><td>0%</td></tr>
<tr><td class="left">3-변수 멀티라인 (ts_corr + rank + group_rank)</td><td>105</td><td>6.3%</td></tr>
<tr><td class="left">5-변수 멀티라인 (복합 조건부 결합)</td><td>210</td><td>32.5% → cap 25%</td></tr>
</tbody>
</table>

<h3>10.5 실시간 대시보드</h3>

<h4>10.5.1 아키텍처</h4>

<p>Python 표준 라이브러리의 <code>http.server</code> 기반 경량 웹 서버로 구현하였다. 외부 의존성 없이 동작하며, <code>--dashboard</code> 옵션으로 진화 엔진과 동시에 데몬 스레드로 실행된다. 독립 실행(<code>python dashboard.py --port 8050</code>)도 지원한다.</p>

<h4>10.5.2 데이터 소스</h4>

<p>대시보드는 <code>results/</code> 디렉토리의 파일을 직접 읽어 데이터를 구성한다. <code>checkpoint_latest.json</code>을 우선 로드하고, <code>evolution_*.json</code> 파일들의 제출 기록을 합산한다. 30초 간격의 <code>meta http-equiv="refresh"</code>로 자동 갱신되므로, 진화 엔진이 체크포인트를 저장할 때마다 대시보드에 반영된다.</p>

<h4>10.5.3 표시 항목</h4>

<p>대시보드는 3개 계층으로 구성된다. 상단 카드 영역에 7개 핵심 지표(Hall of Fame 크기, 제출 수, 최고 IQC 점수, MAP-Elites 커버리지, 최고 Sharpe, 평균 HoF 점수, MAP 셀 수)를 표시한다. 중단에 AOS 연산자별 보상을 수평 바 차트로 시각화하여 어떤 연산자가 현재 가장 효과적인지 직관적으로 파악할 수 있다. 하단에 라운드 히스토리 테이블과 Hall of Fame 상위 20개 알파의 상세 정보(수식, IQC 점수, Sharpe, Fitness, Turnover, 제출 여부, 생성 연산자)를 표시한다.</p>

<h4>10.5.4 API 엔드포인트</h4>

<p><code>/</code> 경로는 HTML 대시보드를, <code>/api/data</code> 경로는 JSON 형식의 원시 데이터를 반환한다. JSON 엔드포인트는 외부 모니터링 도구나 커스텀 시각화와의 연동에 활용할 수 있다.</p>

<h3>10.6 멀티 리전 교차 수분 (Cross-Pollination)</h3>

<h4>10.6.1 v3 대비 개선</h4>

<p>v3의 R5(멀티 리전 확장)는 Hall of Fame 상위 20개 알파를 각 리전에서 독립적으로 시뮬레이션하는 단순 전이(transfer) 방식이었다. v4에서는 3단계 파이프라인으로 확장하였다:</p>

<table>
<caption>표 20: 멀티 리전 라운드 3단계 파이프라인</caption>
<thead><tr><th>Phase</th><th>내용</th><th>API 호출</th></tr></thead>
<tbody>
<tr><td class="left">Phase 1: Transfer</td><td class="left">HoF 상위 20개 알파를 전 리전(USA, ASI, CHN, EUR, KOR, JPN, TWN, GLB)에서 시뮬레이션</td><td class="left">20 × 8 = 160</td></tr>
<tr><td class="left">Phase 2: Mini Evolution</td><td class="left">각 리전에서 40개체 × 3세대 미니 진화 라운드 실행</td><td class="left">리전당 ~120</td></tr>
<tr><td class="left">Phase 3: Cross-Pollination</td><td class="left">서로 다른 리전에서 IQC > 2.0인 알파들 간 교배(최대 10회)</td><td class="left">최대 10</td></tr>
</tbody>
</table>

<h4>10.6.2 교차 수분 메커니즘</h4>

<p>Phase 1-2에서 수집된 리전별 결과 중 IQC > 2.0인 개체들을 교차 수분 후보 풀에 등록한다. 이 풀에서 2개를 랜덤 샘플링하여 표준 crossover를 적용하고, 첫 번째 부모의 리전 설정으로 시뮬레이션한다. 이는 서로 다른 시장 구조에서 유효한 수식 패턴을 결합하여, 단일 리전에 과적합되지 않는 범용적 알파 구조를 탐색하는 효과가 있다.</p>

<pre><code><span class="cm"># 교차 수분 의사코드</span>
cross_candidates = [ind <span class="kw">for</span> region_results <span class="kw">in</span> all_regions
                    <span class="kw">if</span> ind.iqc_score > <span class="nu">2.0</span>]
<span class="kw">for</span> _ <span class="kw">in</span> range(min(<span class="nu">10</span>, len(cross_candidates))):
    p1, p2 = random.sample(cross_candidates, <span class="nu">2</span>)
    child_tree = crossover(p1.tree, p2.tree)
    metrics = api.simulate(child.expression, p1.settings)
    <span class="kw">if</span> child.is_submittable():
        hall_of_fame.add(child)
        <span class="kw">if</span> auto_submit: try_submit(child)</code></pre>

<h3>10.7 v4 통합 파이프라인</h3>

<p>v4의 전체 실행 흐름은 다음과 같다. 엔진 초기화 시 이전 결과 로딩 → Pattern Learner에 HoF 주입 → Field Explorer CSV 로딩이 순차적으로 수행된다. 각 라운드의 <code>_create_population()</code>에서 패턴 학습 시드 15%가 주입되고, <code>_evaluate_population()</code>에서 Surrogate 필터링이 적용된다. 모든 시뮬레이션 결과는 Surrogate 학습 데이터로 축적된다. 7라운드 완료 후 <code>_explore_new_fields()</code>가 실행되어 미사용 필드를 스크리닝한다. IQC 점수 계산 시 MDL 페널티가 자동 적용된다.</p>

<pre><code><span class="cm"># v4 통합 실행 흐름</span>
engine = EvolutionEngine(api)          <span class="cm"># 초기화: load_previous → PatternLearner → FieldExplorer</span>
<span class="kw">for</span> rnd <span class="kw">in</span> [<span class="nu">1</span>..<span class="nu">7</span>]:
    pop = create_population(rnd)       <span class="cm"># 패턴 학습 시드 15% 포함</span>
    <span class="kw">for</span> gen <span class="kw">in</span> range(generations):
        evaluate_population(pop)       <span class="cm"># Surrogate 필터 → API 호출 → Surrogate 학습</span>
        next_generation(pop)           <span class="cm"># AOS + SHADE + MDL 페널티 반영</span>
explore_new_fields()                   <span class="cm"># 미사용 필드 15개 스크리닝</span>
save_final()                           <span class="cm"># pattern_learner/surrogate/field_explorer 통계 포함</span></code></pre><div class="section-divider">• • •</div>

<!-- 11. Glossary -->
<h2>11. 핵심 용어 해설</h2>

<p>본 시스템의 실행 로그에 출현하는 주요 용어와 그 의미를 정리한다. 유전 프로그래밍 및 BRAIN 플랫폼 고유 용어를 포함한다.</p>

<table class="glossary-table">
<thead>
<tr><th>용어</th><th>의미</th></tr>
</thead>
<tbody>
<tr><td>섬(Island)</td><td>독립적으로 진화하는 부분 개체군. 본 시스템은 4개 섬을 운용하며, 각 섬은 자체 SHADE 메모리와 AOS를 보유한다.</td></tr>
<tr><td>세대(Generation)</td><td>한 번의 평가-선택-교배-변이 사이클. 라운드별로 5~12세대를 수행한다.</td></tr>
<tr><td>이주(Migration)</td><td>2세대마다 Ring Topology로 섬 간 상위 3개체를 교환하는 다양성 유지 메커니즘.</td></tr>
<tr><td>카타클리즘(Cataclysm)</td><td>3세대 연속 정체 시 발동. 하위 50% 개체를 MAP-Elites 시드 + 랜덤으로 교체하여 지역 최적해를 탈출한다.</td></tr>
<tr><td>MAP-Elites</td><td>Sharpe(10구간) x Turnover(5구간) = 50셀 그리드에서 각 셀의 최고 개체만 보존하는 품질-다양성 아카이브.</td></tr>
<tr><td>명예의 전당(Hall of Fame)</td><td>IQC 점수 1.5 이상의 우수 개체를 저장하는 엘리트 아카이브. 상위 100개만 유지.</td></tr>
<tr><td>Surrogate 필터</td><td>경량 회귀 모델로 유망하지 않은 수식을 사전 필터링하여 BRAIN API 호출을 절약한다. 30샘플 이상 축적 시 활성화.</td></tr>
<tr><td>IQC 점수</td><td>Sharpe, Fitness, Turnover, Returns, Drawdown을 가중 합산한 종합 품질 지표. 복잡도 페널티 적용.</td></tr>
<tr><td>IS Check</td><td>BRAIN 플랫폼의 In-Sample Quality Check. SELF_CORRELATION, CONCENTRATED_WEIGHT, HIGH_TURNOVER 등의 기준을 통과해야 제출 가능.</td></tr>
<tr><td>SELF_CORRELATION</td><td>이미 제출된 알파와의 상관이 높아 독립적 시그널로 인정되지 않는 경우.</td></tr>
<tr><td>CONCENTRATED_WEIGHT</td><td>포지션이 소수 종목에 집중되어 분산이 부족한 경우.</td></tr>
<tr><td>HIGH_TURNOVER</td><td>일일 포지션 변동이 과도하여 거래 비용 대비 수익이 불충분한 경우.</td></tr>
<tr><td>LOW_SUB_UNIVERSE_SHARPE</td><td>하위 유니버스(시가총액 구간)에서 성과가 일관되지 않는 경우.</td></tr>
<tr><td>PROD_CORRELATION</td><td>프로덕션 환경의 기존 알파 포트폴리오와 상관이 높은 경우.</td></tr>
<tr><td>연산자 제한(64-op limit)</td><td>BRAIN 플랫폼이 단일 수식에 허용하는 최대 연산자 수. 초과 시 시뮬레이션이 거부된다.</td></tr>
<tr><td>다양성 강제 주입</td><td>매 세대 offspring의 15%를 희귀 필드 그룹에서 생성한 랜덤 트리로 교체하여 필드 다양성을 확보하는 메커니즘.</td></tr>
<tr><td>Self-Corr 사전 필터</td><td>필드 Jaccard 유사도 기반으로 기존 알파와 구조적으로 유사한 수식을 API 호출 전에 스킵하는 필터.</td></tr>
<tr><td>Trivial Alpha</td><td><code>sign(cap)</code> 등 자명한 수식. 비현실적으로 높은 Sharpe(6+)를 보이나 IS Check에서 반드시 탈락한다.</td></tr>
<tr><td>SA 온도(Temperature)</td><td>Simulated Annealing 온도. 높을수록 열악한 자식도 수용하여 탐색 범위를 확대한다. 세대 진행에 따라 냉각.</td></tr>
<tr><td>AOS(Adaptive Operator Selection)</td><td>UCB1 알고리즘으로 10개 유전 연산자의 선택 확률을 성과 기반으로 동적 조정.</td></tr>
<tr><td>SHADE</td><td>Differential Evolution의 F(스케일 팩터)와 CR(교배율)을 성공 이력 기반으로 적응적 제어하는 메커니즘.</td></tr>
<tr><td>Regular Expression</td><td>BRAIN의 멀티라인 수식 형식. 변수 할당(<code>a = expr;</code>)과 최종 수식으로 구성. 변수명은 단일 문자.</td></tr>
<tr><td>FastExpression</td><td>BRAIN의 단일라인 수식 형식. 모든 로직이 한 줄에 표현된다.</td></tr>
<tr><td>체크포인트(Checkpoint)</td><td>매 세대 종료 시 저장되는 상태 스냅샷. 명예의 전당, MAP-Elites, AOS 통계, 라운드 진행 정보를 포함.</td></tr>
<tr><td>사이클(Cycle)</td><td>11개 리전을 순회하며 7라운드 진화를 수행하는 단위. <code>--region ALL</code> 모드에서 사용.</td></tr>
</tbody>
</table>

<div class="section-divider">• • •</div>

<!-- References -->
<h2>References</h2>

<div class="references">
<p>Tanabe, R. & Fukunaga, A. (2013). Success-History Based Parameter Adaptation for Differential Evolution. <em>IEEE CEC</em>, pp. 71–78.</p>
<p>Mouret, J.-B. & Clune, J. (2015). Illuminating search spaces by mapping elites. <em>arXiv:1504.04909</em>.</p>
<p>La Cava, W. et al. (2016). Epsilon-Lexicase Selection for Regression. <em>GECCO</em>, pp. 741–748.</p>
<p>Deb, K. et al. (2002). A Fast and Elitist Multiobjective Genetic Algorithm: NSGA-II. <em>IEEE Trans. Evol. Comput.</em>, 6(2), pp. 182–197.</p>
<p>Auer, P. et al. (2002). Finite-time Analysis of the Multiarmed Bandit Problem. <em>Machine Learning</em>, 47(2), pp. 235–256.</p>
<p>Koza, J. R. (1992). <em>Genetic Programming</em>. MIT Press.</p>
<p>Storn, R. & Price, K. (1997). Differential Evolution. <em>J. Global Optimization</em>, 11(4), pp. 341–359.</p>
<p>Ursem, R. K. (2000). Multinational GAs: Multimodal Optimization in Dynamic Environments. <em>GECCO</em>, pp. 19–26.</p>
<p>WorldQuant BRAIN Platform. <em>FastExpression Language Reference</em>. <a href="https://platform.worldquantbrain.com" target="_blank">platform.worldquantbrain.com</a></p>
<p>Rissanen, J. (1978). Modeling by shortest data description. <em>Automatica</em>, 14(5), pp. 465–471.</p>
<p>Jin, Y. (2011). Surrogate-assisted evolutionary computation: Recent advances and future challenges. <em>Swarm and Evolutionary Computation</em>, 1(2), pp. 61–70.</p>
</div>

</div><!-- /.paper-content -->
</div><!-- /.container -->
</div><!-- /.main-wrapper -->

<script>
const syms = ['Σ','∫','∂','√','∞','π','θ','σ','μ','λ','α','β','γ','δ','Δ','Γ','κ','ρ','φ','ψ','dx','dt','dW','E[X]','Var','ln','exp'];
const bg = document.getElementById('formulaBg');
const items = [];
for(let i = 0; i < 30; i++) {
    const el = document.createElement('div');
    el.className = 'f';
    el.textContent = syms[Math.floor(Math.random() * syms.length)];
    el.style.fontSize = (14 + Math.random() * 20) + 'px';
    el.style.color = `rgba(0,0,0,${0.03 + Math.random() * 0.04})`;
    el.style.left = Math.random() * 100 + '%';
    el.style.top = Math.random() * 100 + '%';
    bg.appendChild(el);
    items.push({el, x: parseFloat(el.style.left), y: parseFloat(el.style.top), vx: (Math.random()-.5)*.02, vy: (Math.random()-.5)*.02});
}
let mx = -1000, my = -1000;
document.addEventListener('mousemove', e => { mx = (e.clientX/window.innerWidth)*100; my = (e.clientY/window.innerHeight)*100; });
function tick() {
    for(const it of items) {
        it.x += it.vx; it.y += it.vy;
        if(it.x < 0 || it.x > 100) it.vx *= -1;
        if(it.y < 0 || it.y > 100) it.vy *= -1;
        const dx = it.x - mx, dy = it.y - my, dist = Math.sqrt(dx*dx + dy*dy);
        let px = 0, py = 0;
        if(dist < 12) { const f = (12-dist)/12*3; px = (dx/dist)*f; py = (dy/dist)*f; }
        it.el.style.left = (it.x + px) + '%';
        it.el.style.top = (it.y + py) + '%';
    }
    requestAnimationFrame(tick);
}
tick();
</script>
{% include market-data.html %}
</body>
</html>
